/*!
OutSystems Maps 2.1.0 
Website:
 • hhttps://outsystemsui.outsystems.com/OutSystemsMapsSample/
GitHub:
 • https://github.com/OutSystems/outsystems-maps
*/ 
"use strict";
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Constants;
        (function (Constants) {
            Constants.OSMapsVersion = '2.1.0';
            Constants.OSPlatform = '';
        })(Constants = Maps.Constants || (Maps.Constants = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var ProviderVersion;
        (function (ProviderVersion) {
            function Change(provider, version, forceRefresh = false) {
                let versionChanged = false;
                switch (provider) {
                    case OSFramework.Maps.Enum.ProviderType.Google:
                        versionChanged = Provider.Maps.Google.Version.Change(version);
                        break;
                    case OSFramework.Maps.Enum.ProviderType.Leaflet:
                        versionChanged = Provider.Maps.Leaflet.Version.Change(version);
                        break;
                    default:
                        throw new Error(`There provider '${provider}' is not supported.`);
                }
                if (forceRefresh && versionChanged) {
                    window.location.reload();
                }
            }
            ProviderVersion.Change = Change;
            function Get(provider) {
                let version = '';
                switch (provider) {
                    case OSFramework.Maps.Enum.ProviderType.Google:
                        version = Provider.Maps.Google.Version.Get();
                        break;
                    case OSFramework.Maps.Enum.ProviderType.Leaflet:
                        version = Provider.Maps.Leaflet.Version.Get();
                        break;
                    default:
                        throw new Error(`There provider '${provider}' is not supported.`);
                }
                return version;
            }
            ProviderVersion.Get = Get;
        })(ProviderVersion = Maps.ProviderVersion || (Maps.ProviderVersion = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Configuration;
        (function (Configuration) {
            class AbstractConfiguration {
                constructor(config) {
                    const _localConfig = config;
                    let key;
                    for (key in _localConfig) {
                        if (_localConfig[key] !== undefined) {
                            this[key] = _localConfig[key];
                        }
                    }
                }
            }
            Configuration.AbstractConfiguration = AbstractConfiguration;
        })(Configuration = Maps.Configuration || (Maps.Configuration = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var DrawingTools;
        (function (DrawingTools) {
            class AbstractDrawingTools {
                constructor(map, uniqueId, config) {
                    this._map = map;
                    this._uniqueId = uniqueId;
                    this._config = config;
                    this._built = false;
                    this._drawingToolsEvents = new Maps.Event.DrawingTools.DrawingToolsEventsManager(this);
                    this._tools = new Map();
                    this._toolsSet = new Set();
                    this._createElements = [];
                }
                get config() {
                    return this._config;
                }
                get createdElements() {
                    return this._createElements;
                }
                get drawingToolsEvents() {
                    return this._drawingToolsEvents;
                }
                get isReady() {
                    return this._built;
                }
                get map() {
                    return this._map;
                }
                get provider() {
                    return this._provider;
                }
                get tools() {
                    return Array.from(this._toolsSet);
                }
                get uniqueId() {
                    return this._uniqueId;
                }
                get widgetId() {
                    if (this._widgetId === undefined || this._widgetId === '') {
                        this._setWidgetId();
                    }
                    return this._widgetId;
                }
                _setWidgetId() {
                    this._widgetId = Maps.Helper.GetElementByUniqueId(this.uniqueId, false)
                        ? Maps.Helper.GetElementByUniqueId(this.uniqueId).closest(Maps.Helper.Constants.drawingToolsTag).id
                        : undefined;
                }
                finishBuild() {
                    this._built = true;
                    this.drawingToolsEvents.trigger(Maps.Event.DrawingTools.DrawingToolsEventType.Initialized);
                }
                addTool(tool) {
                    this._tools.set(tool.uniqueId, tool);
                    this._toolsSet.add(tool);
                    return tool;
                }
                build() {
                    if (this._built)
                        return;
                    this._setWidgetId();
                }
                changeProperty(propertyName, propertyValue) {
                    if (this.config.hasOwnProperty(propertyName)) {
                        this.config[propertyName] = propertyValue;
                    }
                    else {
                        this.map.mapEvents.trigger(Maps.Event.OSMap.MapEventType.OnError, this.map, Maps.Enum.ErrorCodes.GEN_InvalidChangePropertyDrawingTools, `${propertyName}`);
                    }
                }
                changeToolProperty(toolId, propertyName, propertyValue) {
                    const tool = this._tools.get(toolId);
                    tool.changeProperty(propertyName, propertyValue);
                }
                dispose() {
                    this._built = false;
                    this.removeAllTools();
                }
                equalsToID(id) {
                    return id === this._uniqueId || id === this.widgetId;
                }
                getProviderConfig() {
                    return this._config.getProviderConfig();
                }
                hasTool(toolId) {
                    return this._tools.has(toolId);
                }
                removeAllTools() {
                    this._tools.forEach((tool) => {
                        tool.dispose();
                    });
                    this._tools.clear();
                    this._toolsSet.clear();
                }
                removeTool(toolId) {
                    if (this.hasTool(toolId)) {
                        const tool = this._tools.get(toolId);
                        tool.dispose();
                        this._tools.delete(toolId);
                        this._toolsSet.delete(tool);
                    }
                }
                toolAlreadyExists(toolType) {
                    return Array.from(this._tools.values()).some((tool) => tool.type === toolType);
                }
                validateProviderEvent(eventName) {
                    return this.providerEvents.indexOf(eventName) !== -1;
                }
            }
            DrawingTools.AbstractDrawingTools = AbstractDrawingTools;
        })(DrawingTools = Maps.DrawingTools || (Maps.DrawingTools = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var DrawingTools;
        (function (DrawingTools) {
            class AbstractTool {
                constructor(map, drawingTools, uniqueId, type, config) {
                    this._map = map;
                    this._drawingTools = drawingTools;
                    this._uniqueId = uniqueId;
                    this._config = config;
                    this._built = false;
                    this._type = type;
                }
                get config() {
                    return this._config;
                }
                get drawingTools() {
                    return this._drawingTools;
                }
                get isReady() {
                    return this._built;
                }
                get map() {
                    return this._map;
                }
                get type() {
                    return this._type;
                }
                get uniqueId() {
                    return this._uniqueId;
                }
                get widgetId() {
                    if (this._widgetId === undefined || this._widgetId === '') {
                        this._setWidgetId();
                    }
                    return this._widgetId;
                }
                _setWidgetId() {
                    this._widgetId = Maps.Helper.GetElementByUniqueId(this.uniqueId, false)
                        ? Maps.Helper.GetElementByUniqueId(this.uniqueId).closest(Maps.Helper.Constants.drawingToolsTag).id
                        : undefined;
                }
                finishBuild() {
                    this._built = true;
                }
                build() {
                    if (this._built)
                        return;
                    this._setWidgetId();
                }
                changeProperty(propertyName, propertyValue) {
                    if (this.config.hasOwnProperty(propertyName)) {
                        this.config[propertyName] = propertyValue;
                    }
                    else {
                        this.map.mapEvents.trigger(Maps.Event.OSMap.MapEventType.OnError, this.map, Maps.Enum.ErrorCodes.GEN_InvalidChangePropertyTools, `${propertyName}`);
                    }
                }
                dispose() {
                    this._built = false;
                }
                equalsToID(id) {
                    return id === this._uniqueId || id === this.widgetId;
                }
                getProviderConfig() {
                    return this._config.getProviderConfig();
                }
            }
            DrawingTools.AbstractTool = AbstractTool;
        })(DrawingTools = Maps.DrawingTools || (Maps.DrawingTools = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var DrawingTools;
        (function (DrawingTools) {
            let DrawingToolsFactory;
            (function (DrawingToolsFactory) {
                function MakeDrawingTools(map, drawingToolsId, configs) {
                    switch (map.providerType) {
                        case Maps.Enum.ProviderType.Google:
                            return Provider.Maps.Google.DrawingTools.DrawingToolsFactory.MakeDrawingTools(map, drawingToolsId, configs);
                        case Maps.Enum.ProviderType.Leaflet:
                            return Provider.Maps.Leaflet.DrawingTools.DrawingToolsFactory.MakeDrawingTools(map, drawingToolsId, configs);
                        default:
                            throw new Error(`There is no factory for the DrawingTools using the provider ${map.providerType}`);
                    }
                }
                DrawingToolsFactory.MakeDrawingTools = MakeDrawingTools;
                function MakeTool(map, drawingTools, toolId, type, configs) {
                    switch (map.providerType) {
                        case Maps.Enum.ProviderType.Google:
                            return Provider.Maps.Google.DrawingTools.DrawingToolsFactory.MakeTool(map, drawingTools, toolId, type, configs);
                        case Maps.Enum.ProviderType.Leaflet:
                            return Provider.Maps.Leaflet.DrawingTools.DrawingToolsFactory.MakeTool(map, drawingTools, toolId, type, configs);
                        default:
                            throw new Error(`There is no factory for the Tool (${type}) using the provider ${map.providerType}`);
                    }
                }
                DrawingToolsFactory.MakeTool = MakeTool;
            })(DrawingToolsFactory = DrawingTools.DrawingToolsFactory || (DrawingTools.DrawingToolsFactory = {}));
        })(DrawingTools = Maps.DrawingTools || (Maps.DrawingTools = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Enum;
        (function (Enum) {
            let DrawingToolsTypes;
            (function (DrawingToolsTypes) {
                DrawingToolsTypes["Circle"] = "circle";
                DrawingToolsTypes["Marker"] = "marker";
                DrawingToolsTypes["Polygon"] = "polygon";
                DrawingToolsTypes["Polyline"] = "polyline";
                DrawingToolsTypes["Rectangle"] = "rectangle";
            })(DrawingToolsTypes = Enum.DrawingToolsTypes || (Enum.DrawingToolsTypes = {}));
        })(Enum = Maps.Enum || (Maps.Enum = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Enum;
        (function (Enum) {
            Enum.Success = {
                code: '200',
                message: 'Success',
            };
            Enum.Unsupported = {
                code: 'MAPS-GEN-01003',
                message: 'The action ContainsLocation can’t verify if a given marker is inside a Polyline shape. Please, change the ShapeWidgetId parameter to a Circle, Rectangle, or Polygon.',
            };
            let ErrorCodes;
            (function (ErrorCodes) {
                ErrorCodes["CFG_APIKeyAlreadySetMap"] = "MAPS-CFG-01001";
                ErrorCodes["CFG_LocalizationAlreadySetMap"] = "MAPS-CFG-01003";
                ErrorCodes["CFG_APIKeyAlreadySetStaticMap"] = "MAPS-CFG-02001";
                ErrorCodes["CFG_CantChangeParamsStaticMap"] = "MAPS-CFG-02002";
                ErrorCodes["CFG_LocalizationAlreadySetStaticMap"] = "MAPS-CFG-02003";
                ErrorCodes["CFG_InvalidPolylineShapeLocations"] = "MAPS-CFG-05001";
                ErrorCodes["CFG_InvalidPolygonShapeLocations"] = "MAPS-CFG-05002";
                ErrorCodes["CFG_InvalidCircleShapeCenter"] = "MAPS-CFG-05003";
                ErrorCodes["CFG_InvalidRectangleShapeBounds"] = "MAPS-CFG-05004";
                ErrorCodes["CFG_APIKeyDiffersFromPlacesToMaps"] = "MAPS-CFG-01002";
                ErrorCodes["CFG_APIKeyAlreadySetSearchPlaces"] = "MAPS-CFG-10001";
                ErrorCodes["CFG_InvalidSearchPlacesSearchArea"] = "MAPS-CFG-10002";
                ErrorCodes["CFG_MaximumCountriesNumber"] = "MAPS-CFG-10003";
                ErrorCodes["CFG_InvalidInputSearchPlaces"] = "MAPS-CFG-10004";
                ErrorCodes["CFG_InvalidTravelMode"] = "MAPS-CFG-04001";
                ErrorCodes["CFG_InvalidDrawingToolsPosition"] = "MAPS-CFG-06001";
                ErrorCodes["CFG_InvalidMapId"] = "MAPS-CFG-10005";
                ErrorCodes["LIB_InvalidApiKeyMap"] = "MAPS-LIB-01001";
                ErrorCodes["LIB_FailedGeocodingMap"] = "MAPS-LIB-01002";
                ErrorCodes["LIB_InvalidApiKeyStaticMap"] = "MAPS-LIB-02001";
                ErrorCodes["LIB_FailedGeocodingMarker"] = "MAPS-LIB-03001";
                ErrorCodes["LIB_FailedGeocodingLeafletMarker"] = "MAPS-LIB-03002";
                ErrorCodes["LIB_FailedSetDirections"] = "MAPS-LIB-04001";
                ErrorCodes["LIB_FailedGeocodingShapeLocations"] = "MAPS-LIB-05001";
                ErrorCodes["LIB_FailedGeocodingLeafletShapeLocations"] = "MAPS-LIB-05002";
                ErrorCodes["LIB_InvalidApiKeySearchPlaces"] = "MAPS-LIB-10001";
                ErrorCodes["LIB_FailedGeocodingSearchAreaLocations"] = "MAPS-LIB-10002";
                ErrorCodes["LIB_FailedGeocodingLeafletMap"] = "MAPS-LIB-11001";
                ErrorCodes["API_FailedRemoveDirections"] = "MAPS-API-03001";
                ErrorCodes["API_FailedGettingShapePath"] = "MAPS-API-05001";
                ErrorCodes["API_FailedGettingCircleShape"] = "MAPS-API-05002";
                ErrorCodes["API_FailedGettingShapeCenter"] = "MAPS-API-05003";
                ErrorCodes["API_FailedGettingShapeRadius"] = "MAPS-API-05004";
                ErrorCodes["API_FailedLoadingPlugin"] = "MAPS-API-04002";
                ErrorCodes["API_FailedNoPluginDirections"] = "MAPS-API-04003";
                ErrorCodes["API_FailedRemoveMarkerFromCluster"] = "MAPS-API-09001";
                ErrorCodes["API_FailedContainsLocation"] = "MAPS-API-05005";
                ErrorCodes["API_FailedGettingCenterCoordinates"] = "MAPS-API-01001";
                ErrorCodes["API_FailedCreateMarker"] = "MAPS-API-09002";
                ErrorCodes["API_FailedRemoveMarker"] = "MAPS-API-09003";
                ErrorCodes["API_FailedRemoveMarkers"] = "MAPS-API-09004";
                ErrorCodes["API_FailedSubscribeMarkerEvent"] = "MAPS-API-09005";
                ErrorCodes["API_FailedUnsubscribeMarkerEvent"] = "MAPS-API-09006";
                ErrorCodes["GEN_InvalidChangePropertyMap"] = "MAPS-GEN-01001";
                ErrorCodes["GEN_InvalidChangePropertyMarker"] = "MAPS-GEN-03001";
                ErrorCodes["GEN_UnsupportedEventMap"] = "MAPS-GEN-01002";
                ErrorCodes["GEN_UnsupportedEventMarker"] = "MAPS-GEN-03002";
                ErrorCodes["GEN_InvalidChangePropertyShape"] = "MAPS-GEN-05001";
                ErrorCodes["GEN_InvalidChangePropertyDrawingTools"] = "MAPS-GEN-06001";
                ErrorCodes["GEN_InvalidChangePropertyTools"] = "MAPS-GEN-06002";
                ErrorCodes["GEN_InvalidChangePropertyUseAdvancedMarkers"] = "MAPS-GEN-06005";
                ErrorCodes["GEN_InvalidChangePropertyMapStyleId"] = "MAPS-GEN-06006";
                ErrorCodes["GEN_UnsupportedEventShape"] = "MAPS-GEN-05002";
                ErrorCodes["GEN_UnsupportedEventDrawingTools"] = "MAPS-GEN-06003";
                ErrorCodes["GEN_ToolTypeAlreadyExists"] = "MAPS-GEN-06004";
                ErrorCodes["GEN_InvalidChangePropertyFileLayer"] = "MAPS-GEN-07001";
                ErrorCodes["GEN_UnsupportedEventFileLayer"] = "MAPS-GEN-07002";
                ErrorCodes["GEN_InvalidChangePropertyHeatmapLayer"] = "MAPS-GEN-08001";
                ErrorCodes["GEN_InvalidChangePropertyMarkerClusterer"] = "MAPS-GEN-09001";
                ErrorCodes["GEN_InvalidChangePropertySearchPlaces"] = "MAPS-GEN-10001";
                ErrorCodes["GEN_UnsupportedEventSearchPlaces"] = "MAPS-GEN-10002";
                ErrorCodes["GEN_NoPluginDirectionsNeeded"] = "MAPS-GEN-04001";
            })(ErrorCodes = Enum.ErrorCodes || (Enum.ErrorCodes = {}));
        })(Enum = Maps.Enum || (Maps.Enum = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Enum;
        (function (Enum) {
            let Feature;
            (function (Feature) {
                Feature["Marker"] = "Marker";
                Feature["MarkerPopup"] = "MarkerPopup";
                Feature["Shapes"] = "Shapes";
                Feature["Directions"] = "Directions";
                Feature["DrawingTools"] = "DrawingTools";
                Feature["FileLayer"] = "FileLayer";
                Feature["HeatmapLayer"] = "HeatmapLayer";
            })(Feature = Enum.Feature || (Enum.Feature = {}));
        })(Enum = Maps.Enum || (Maps.Enum = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Enum;
        (function (Enum) {
            let MapType;
            (function (MapType) {
                MapType["Map"] = "Map";
                MapType["StaticMap"] = "StaticMap";
            })(MapType = Enum.MapType || (Enum.MapType = {}));
        })(Enum = Maps.Enum || (Maps.Enum = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Enum;
        (function (Enum) {
            let MarkerType;
            (function (MarkerType) {
                MarkerType["Marker"] = "Marker";
                MarkerType["MarkerPopup"] = "MarkerPopup";
            })(MarkerType = Enum.MarkerType || (Enum.MarkerType = {}));
        })(Enum = Maps.Enum || (Maps.Enum = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Enum;
        (function (Enum) {
            let OS_Config_DrawingTools;
            (function (OS_Config_DrawingTools) {
                OS_Config_DrawingTools[OS_Config_DrawingTools["position"] = 0] = "position";
            })(OS_Config_DrawingTools = Enum.OS_Config_DrawingTools || (Enum.OS_Config_DrawingTools = {}));
        })(Enum = Maps.Enum || (Maps.Enum = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Enum;
        (function (Enum) {
            let OS_Config_FileLayer;
            (function (OS_Config_FileLayer) {
                OS_Config_FileLayer[OS_Config_FileLayer["layerUrl"] = 0] = "layerUrl";
                OS_Config_FileLayer[OS_Config_FileLayer["preserveViewport"] = 1] = "preserveViewport";
                OS_Config_FileLayer[OS_Config_FileLayer["suppressPopups"] = 2] = "suppressPopups";
            })(OS_Config_FileLayer = Enum.OS_Config_FileLayer || (Enum.OS_Config_FileLayer = {}));
        })(Enum = Maps.Enum || (Maps.Enum = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Enum;
        (function (Enum) {
            let OS_Config_HeatmapLayer;
            (function (OS_Config_HeatmapLayer) {
                OS_Config_HeatmapLayer[OS_Config_HeatmapLayer["dissipateOnZoom"] = 0] = "dissipateOnZoom";
                OS_Config_HeatmapLayer[OS_Config_HeatmapLayer["gradient"] = 1] = "gradient";
                OS_Config_HeatmapLayer[OS_Config_HeatmapLayer["maxIntensity"] = 2] = "maxIntensity";
                OS_Config_HeatmapLayer[OS_Config_HeatmapLayer["points"] = 3] = "points";
                OS_Config_HeatmapLayer[OS_Config_HeatmapLayer["opacity"] = 4] = "opacity";
                OS_Config_HeatmapLayer[OS_Config_HeatmapLayer["radius"] = 5] = "radius";
            })(OS_Config_HeatmapLayer = Enum.OS_Config_HeatmapLayer || (Enum.OS_Config_HeatmapLayer = {}));
        })(Enum = Maps.Enum || (Maps.Enum = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Enum;
        (function (Enum) {
            let OS_Config_Map;
            (function (OS_Config_Map) {
                OS_Config_Map[OS_Config_Map["advancedFormat"] = 0] = "advancedFormat";
                OS_Config_Map[OS_Config_Map["apiKey"] = 1] = "apiKey";
                OS_Config_Map[OS_Config_Map["height"] = 2] = "height";
                OS_Config_Map[OS_Config_Map["center"] = 3] = "center";
                OS_Config_Map[OS_Config_Map["localization"] = 4] = "localization";
                OS_Config_Map[OS_Config_Map["mapStyleId"] = 5] = "mapStyleId";
                OS_Config_Map[OS_Config_Map["markerClustererActive"] = 6] = "markerClustererActive";
                OS_Config_Map[OS_Config_Map["markerClustererMaxZoom"] = 7] = "markerClustererMaxZoom";
                OS_Config_Map[OS_Config_Map["markerClustererMinClusterSize"] = 8] = "markerClustererMinClusterSize";
                OS_Config_Map[OS_Config_Map["markerClustererZoomOnClick"] = 9] = "markerClustererZoomOnClick";
                OS_Config_Map[OS_Config_Map["offset"] = 10] = "offset";
                OS_Config_Map[OS_Config_Map["respectUserZoom"] = 11] = "respectUserZoom";
                OS_Config_Map[OS_Config_Map["showTraffic"] = 12] = "showTraffic";
                OS_Config_Map[OS_Config_Map["staticMap"] = 13] = "staticMap";
                OS_Config_Map[OS_Config_Map["style"] = 14] = "style";
                OS_Config_Map[OS_Config_Map["type"] = 15] = "type";
                OS_Config_Map[OS_Config_Map["uniqueId"] = 16] = "uniqueId";
                OS_Config_Map[OS_Config_Map["useAdvancedMarkers"] = 17] = "useAdvancedMarkers";
                OS_Config_Map[OS_Config_Map["zoom"] = 18] = "zoom";
            })(OS_Config_Map = Enum.OS_Config_Map || (Enum.OS_Config_Map = {}));
        })(Enum = Maps.Enum || (Maps.Enum = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Enum;
        (function (Enum) {
            let OS_Config_Marker;
            (function (OS_Config_Marker) {
                OS_Config_Marker[OS_Config_Marker["advancedFormat"] = 0] = "advancedFormat";
                OS_Config_Marker[OS_Config_Marker["allowDrag"] = 1] = "allowDrag";
                OS_Config_Marker[OS_Config_Marker["iconHeight"] = 2] = "iconHeight";
                OS_Config_Marker[OS_Config_Marker["iconUrl"] = 3] = "iconUrl";
                OS_Config_Marker[OS_Config_Marker["iconWidth"] = 4] = "iconWidth";
                OS_Config_Marker[OS_Config_Marker["label"] = 5] = "label";
                OS_Config_Marker[OS_Config_Marker["location"] = 6] = "location";
                OS_Config_Marker[OS_Config_Marker["title"] = 7] = "title";
                OS_Config_Marker[OS_Config_Marker["uniqueId"] = 8] = "uniqueId";
            })(OS_Config_Marker = Enum.OS_Config_Marker || (Enum.OS_Config_Marker = {}));
        })(Enum = Maps.Enum || (Maps.Enum = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Enum;
        (function (Enum) {
            let OS_Config_MarkerClusterer;
            (function (OS_Config_MarkerClusterer) {
                OS_Config_MarkerClusterer[OS_Config_MarkerClusterer["markerClustererActive"] = 0] = "markerClustererActive";
                OS_Config_MarkerClusterer[OS_Config_MarkerClusterer["markerClustererMinClusterSize"] = 1] = "markerClustererMinClusterSize";
                OS_Config_MarkerClusterer[OS_Config_MarkerClusterer["markerClustererMaxZoom"] = 2] = "markerClustererMaxZoom";
                OS_Config_MarkerClusterer[OS_Config_MarkerClusterer["markerClustererZoomOnClick"] = 3] = "markerClustererZoomOnClick";
            })(OS_Config_MarkerClusterer = Enum.OS_Config_MarkerClusterer || (Enum.OS_Config_MarkerClusterer = {}));
        })(Enum = Maps.Enum || (Maps.Enum = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Enum;
        (function (Enum) {
            let OS_Config_SearchPlaces;
            (function (OS_Config_SearchPlaces) {
                OS_Config_SearchPlaces[OS_Config_SearchPlaces["apiKey"] = 0] = "apiKey";
                OS_Config_SearchPlaces[OS_Config_SearchPlaces["localization"] = 1] = "localization";
                OS_Config_SearchPlaces[OS_Config_SearchPlaces["countries"] = 2] = "countries";
                OS_Config_SearchPlaces[OS_Config_SearchPlaces["searchArea"] = 3] = "searchArea";
                OS_Config_SearchPlaces[OS_Config_SearchPlaces["searchType"] = 4] = "searchType";
            })(OS_Config_SearchPlaces = Enum.OS_Config_SearchPlaces || (Enum.OS_Config_SearchPlaces = {}));
        })(Enum = Maps.Enum || (Maps.Enum = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Enum;
        (function (Enum) {
            let OS_Config_Shape;
            (function (OS_Config_Shape) {
                OS_Config_Shape[OS_Config_Shape["allowDrag"] = 0] = "allowDrag";
                OS_Config_Shape[OS_Config_Shape["allowEdit"] = 1] = "allowEdit";
                OS_Config_Shape[OS_Config_Shape["bounds"] = 2] = "bounds";
                OS_Config_Shape[OS_Config_Shape["center"] = 3] = "center";
                OS_Config_Shape[OS_Config_Shape["fillColor"] = 4] = "fillColor";
                OS_Config_Shape[OS_Config_Shape["fillOpacity"] = 5] = "fillOpacity";
                OS_Config_Shape[OS_Config_Shape["locations"] = 6] = "locations";
                OS_Config_Shape[OS_Config_Shape["radius"] = 7] = "radius";
                OS_Config_Shape[OS_Config_Shape["strokeColor"] = 8] = "strokeColor";
                OS_Config_Shape[OS_Config_Shape["strokeOpacity"] = 9] = "strokeOpacity";
                OS_Config_Shape[OS_Config_Shape["strokeWeight"] = 10] = "strokeWeight";
                OS_Config_Shape[OS_Config_Shape["uniqueId"] = 11] = "uniqueId";
            })(OS_Config_Shape = Enum.OS_Config_Shape || (Enum.OS_Config_Shape = {}));
        })(Enum = Maps.Enum || (Maps.Enum = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Enum;
        (function (Enum) {
            let OS_Config_StaticMap;
            (function (OS_Config_StaticMap) {
                OS_Config_StaticMap[OS_Config_StaticMap["apiKey"] = 0] = "apiKey";
                OS_Config_StaticMap[OS_Config_StaticMap["localization"] = 1] = "localization";
                OS_Config_StaticMap[OS_Config_StaticMap["height"] = 2] = "height";
                OS_Config_StaticMap[OS_Config_StaticMap["center"] = 3] = "center";
                OS_Config_StaticMap[OS_Config_StaticMap["type"] = 4] = "type";
                OS_Config_StaticMap[OS_Config_StaticMap["uniqueId"] = 5] = "uniqueId";
                OS_Config_StaticMap[OS_Config_StaticMap["zoom"] = 6] = "zoom";
            })(OS_Config_StaticMap = Enum.OS_Config_StaticMap || (Enum.OS_Config_StaticMap = {}));
        })(Enum = Maps.Enum || (Maps.Enum = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Enum;
        (function (Enum) {
            let ProviderType;
            (function (ProviderType) {
                ProviderType["Google"] = "Google";
                ProviderType["Leaflet"] = "Leaflet";
            })(ProviderType = Enum.ProviderType || (Enum.ProviderType = {}));
        })(Enum = Maps.Enum || (Maps.Enum = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Enum;
        (function (Enum) {
            let SearchTypes;
            (function (SearchTypes) {
                SearchTypes[SearchTypes["Addresses"] = 0] = "Addresses";
                SearchTypes[SearchTypes["Cities"] = 1] = "Cities";
                SearchTypes[SearchTypes["Establishments"] = 2] = "Establishments";
                SearchTypes[SearchTypes["Geocodes"] = 3] = "Geocodes";
                SearchTypes[SearchTypes["Regions"] = 4] = "Regions";
            })(SearchTypes = Enum.SearchTypes || (Enum.SearchTypes = {}));
        })(Enum = Maps.Enum || (Maps.Enum = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Enum;
        (function (Enum) {
            let ShapeMinPath;
            (function (ShapeMinPath) {
                ShapeMinPath[ShapeMinPath["Polygon"] = 3] = "Polygon";
                ShapeMinPath[ShapeMinPath["Polyline"] = 2] = "Polyline";
            })(ShapeMinPath = Enum.ShapeMinPath || (Enum.ShapeMinPath = {}));
        })(Enum = Maps.Enum || (Maps.Enum = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Enum;
        (function (Enum) {
            let ShapeType;
            (function (ShapeType) {
                ShapeType["Circle"] = "Circle";
                ShapeType["Polygon"] = "Polygon";
                ShapeType["Polyline"] = "Polyline";
                ShapeType["Rectangle"] = "Rectangle";
            })(ShapeType = Enum.ShapeType || (Enum.ShapeType = {}));
        })(Enum = Maps.Enum || (Maps.Enum = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Enum;
        (function (Enum) {
            var OSMap;
            (function (OSMap) {
                let Style;
                (function (Style) {
                    Style[Style["Standard"] = 0] = "Standard";
                    Style[Style["Silver"] = 1] = "Silver";
                    Style[Style["Retro"] = 2] = "Retro";
                    Style[Style["Dark"] = 3] = "Dark";
                    Style[Style["Night"] = 4] = "Night";
                    Style[Style["Aubergine"] = 5] = "Aubergine";
                })(Style = OSMap.Style || (OSMap.Style = {}));
            })(OSMap = Enum.OSMap || (Enum.OSMap = {}));
        })(Enum = Maps.Enum || (Maps.Enum = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Enum;
        (function (Enum) {
            var OSMap;
            (function (OSMap) {
                let Type;
                (function (Type) {
                    Type["Roadmap"] = "Roadmap";
                    Type["Satellite"] = "Satellite";
                    Type["Hybrid"] = "Hybrid";
                    Type["Terrain"] = "Terrain";
                })(Type = OSMap.Type || (OSMap.Type = {}));
            })(OSMap = Enum.OSMap || (Enum.OSMap = {}));
        })(Enum = Maps.Enum || (Maps.Enum = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Enum;
        (function (Enum) {
            var OSMap;
            (function (OSMap) {
                let Zoom;
                (function (Zoom) {
                    Zoom[Zoom["Auto"] = 0] = "Auto";
                    Zoom[Zoom["Zoom1_World"] = 1] = "Zoom1_World";
                    Zoom[Zoom["Zoom2"] = 2] = "Zoom2";
                    Zoom[Zoom["Zoom3"] = 3] = "Zoom3";
                    Zoom[Zoom["Zoom4"] = 4] = "Zoom4";
                    Zoom[Zoom["Zoom5_Continent"] = 5] = "Zoom5_Continent";
                    Zoom[Zoom["Zoom6"] = 6] = "Zoom6";
                    Zoom[Zoom["Zoom7"] = 7] = "Zoom7";
                    Zoom[Zoom["Zoom8"] = 8] = "Zoom8";
                    Zoom[Zoom["Zoom9"] = 9] = "Zoom9";
                    Zoom[Zoom["Zoom10_City"] = 10] = "Zoom10_City";
                    Zoom[Zoom["Zoom11"] = 11] = "Zoom11";
                    Zoom[Zoom["Zoom12"] = 12] = "Zoom12";
                    Zoom[Zoom["Zoom13"] = 13] = "Zoom13";
                    Zoom[Zoom["Zoom14"] = 14] = "Zoom14";
                    Zoom[Zoom["Zoom15_Streets"] = 15] = "Zoom15_Streets";
                    Zoom[Zoom["Zoom16"] = 16] = "Zoom16";
                    Zoom[Zoom["Zoom17"] = 17] = "Zoom17";
                    Zoom[Zoom["Zoom18"] = 18] = "Zoom18";
                    Zoom[Zoom["Zoom19"] = 19] = "Zoom19";
                    Zoom[Zoom["Zoom20_Buildings"] = 20] = "Zoom20_Buildings";
                })(Zoom = OSMap.Zoom || (OSMap.Zoom = {}));
            })(OSMap = Enum.OSMap || (Enum.OSMap = {}));
        })(Enum = Maps.Enum || (Maps.Enum = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            class AbstractEvent {
                constructor() {
                    this._handlers = [];
                }
                get handlers() {
                    return this._handlers;
                }
                addHandler(handler, eventUniqueId) {
                    this._handlers.push({
                        eventHandler: handler,
                        uniqueId: eventUniqueId,
                    });
                }
                hasHandlers() {
                    return this._handlers.length > 0;
                }
                removeHandler(handler) {
                    const index = this._handlers.findIndex((hd) => {
                        return hd.eventHandler === handler;
                    });
                    if (index !== -1) {
                        this._handlers.splice(index, 1);
                    }
                }
                trigger(data, ...args) {
                    this._handlers.slice(0).forEach((h) => Maps.Helper.CallbackAsyncInvocation(h.eventHandler, data, ...args));
                }
            }
            Event.AbstractEvent = AbstractEvent;
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            class AbstractEventsManager {
                constructor() {
                    this._handlers = new Map();
                }
                get handlers() {
                    return this._handlers;
                }
                addHandler(eventType, handler, eventUniqueId) {
                    if (this._handlers && this._handlers.has(eventType)) {
                        this._handlers.get(eventType).addHandler(handler, eventUniqueId);
                    }
                    else {
                        const ev = this.getInstanceOfEventType(eventType);
                        if (ev !== undefined) {
                            ev.addHandler(handler, eventUniqueId);
                            this._handlers.set(eventType, ev);
                        }
                    }
                }
                hasHandlers(eventType) {
                    let returnValue = false;
                    if (this._handlers.has(eventType)) {
                        const event = this._handlers.get(eventType);
                        returnValue = event.hasHandlers();
                    }
                    return returnValue;
                }
                removeHandler(eventType, handler) {
                    if (this._handlers.has(eventType)) {
                        const event = this._handlers.get(eventType);
                        event.removeHandler(handler);
                    }
                }
                trigger(eventType, data, ...args) {
                    if (this._handlers.has(eventType)) {
                        this._handlers.get(eventType).trigger(data, ...args);
                    }
                }
            }
            Event.AbstractEventsManager = AbstractEventsManager;
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var DrawingTools;
            (function (DrawingTools) {
                class AbstractDrawingToolsEvent extends Event.AbstractEvent {
                    trigger(mapId, drawingToolsId, ...args) {
                        this.handlers
                            .slice(0)
                            .forEach((h) => Maps.Helper.CallbackAsyncInvocation(h.eventHandler, mapId, drawingToolsId, ...args));
                    }
                }
                DrawingTools.AbstractDrawingToolsEvent = AbstractDrawingToolsEvent;
            })(DrawingTools = Event.DrawingTools || (Event.DrawingTools = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var DrawingTools;
            (function (DrawingTools) {
                let DrawingToolsEventType;
                (function (DrawingToolsEventType) {
                    DrawingToolsEventType["Initialized"] = "Initialized";
                    DrawingToolsEventType["ProviderEvent"] = "ProviderEvent";
                })(DrawingToolsEventType = DrawingTools.DrawingToolsEventType || (DrawingTools.DrawingToolsEventType = {}));
            })(DrawingTools = Event.DrawingTools || (Event.DrawingTools = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var DrawingTools;
            (function (DrawingTools) {
                class DrawingToolsEventsManager extends Event.AbstractEventsManager {
                    constructor(drawingTools) {
                        super();
                        this._drawingTools = drawingTools;
                    }
                    getInstanceOfEventType(eventType) {
                        let event;
                        switch (eventType) {
                            case DrawingTools.DrawingToolsEventType.Initialized:
                                event = new DrawingTools.DrawingToolsInitializedEvent();
                                break;
                            default:
                                if (this._drawingTools.validateProviderEvent(eventType) === true) {
                                    event = new DrawingTools.DrawingToolsProviderEvent();
                                    break;
                                }
                                this._drawingTools.map.mapEvents.trigger(Event.OSMap.MapEventType.OnError, this._drawingTools.map, Maps.Enum.ErrorCodes.GEN_UnsupportedEventDrawingTools, `${eventType}`);
                                return;
                        }
                        return event;
                    }
                    trigger(eventType, eventInfo, eventParams, ...args) {
                        const hasEvents = eventType === DrawingTools.DrawingToolsEventType.ProviderEvent
                            ? this.handlers.has(eventInfo)
                            : this.handlers.has(eventType);
                        if (hasEvents) {
                            const handlerEvent = this.handlers.get(eventType);
                            switch (eventType) {
                                case DrawingTools.DrawingToolsEventType.Initialized:
                                    handlerEvent.trigger(this._drawingTools.map.widgetId, this._drawingTools.widgetId || this._drawingTools.uniqueId, ...args);
                                    break;
                                case DrawingTools.DrawingToolsEventType.ProviderEvent:
                                    if (this._drawingTools.validateProviderEvent(eventInfo) === true) {
                                        const handler = this.handlers.get(eventInfo);
                                        handler.trigger(this._drawingTools.map.widgetId, eventParams.uniqueId || this._drawingTools.widgetId || this._drawingTools.uniqueId, eventParams.isNewElement, eventParams.coordinates, eventParams.location, ...args);
                                        break;
                                    }
                                default:
                                    this._drawingTools.map.mapEvents.trigger(Event.OSMap.MapEventType.OnError, this._drawingTools.map, Maps.Enum.ErrorCodes.GEN_UnsupportedEventDrawingTools, `${eventType}`);
                                    return;
                            }
                        }
                    }
                }
                DrawingTools.DrawingToolsEventsManager = DrawingToolsEventsManager;
            })(DrawingTools = Event.DrawingTools || (Event.DrawingTools = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var DrawingTools;
            (function (DrawingTools) {
                class DrawingToolsInitializedEvent extends DrawingTools.AbstractDrawingToolsEvent {
                }
                DrawingTools.DrawingToolsInitializedEvent = DrawingToolsInitializedEvent;
            })(DrawingTools = Event.DrawingTools || (Event.DrawingTools = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var DrawingTools;
            (function (DrawingTools) {
                class DrawingToolsProviderEvent extends DrawingTools.AbstractDrawingToolsEvent {
                    trigger(mapId, drawingToolsId, isNewElement, coordinates, location) {
                        this.handlers
                            .slice(0)
                            .forEach((h) => Maps.Helper.CallbackAsyncInvocation(h.eventHandler, mapId, drawingToolsId, isNewElement, coordinates, location));
                    }
                }
                DrawingTools.DrawingToolsProviderEvent = DrawingToolsProviderEvent;
            })(DrawingTools = Event.DrawingTools || (Event.DrawingTools = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var FileLayer;
            (function (FileLayer) {
                class AbstractFileLayersEvent extends Event.AbstractEvent {
                    trigger(mapId, fileLayerId, ...args) {
                        this.handlers
                            .slice(0)
                            .forEach((h) => Maps.Helper.CallbackAsyncInvocation(h.eventHandler, mapId, fileLayerId, ...args));
                    }
                }
                FileLayer.AbstractFileLayersEvent = AbstractFileLayersEvent;
            })(FileLayer = Event.FileLayer || (Event.FileLayer = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var FileLayer;
            (function (FileLayer) {
                let FileLayersEventType;
                (function (FileLayersEventType) {
                    FileLayersEventType["Initialized"] = "Initialized";
                    FileLayersEventType["OnClick"] = "OnClick";
                })(FileLayersEventType = FileLayer.FileLayersEventType || (FileLayer.FileLayersEventType = {}));
            })(FileLayer = Event.FileLayer || (Event.FileLayer = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var FileLayer;
            (function (FileLayer) {
                class FileLayersEventsManager extends Event.AbstractEventsManager {
                    constructor(fileLayer) {
                        super();
                        this._fileLayer = fileLayer;
                    }
                    getInstanceOfEventType(eventType) {
                        let event;
                        switch (eventType) {
                            case FileLayer.FileLayersEventType.Initialized:
                                event = new FileLayer.FileLayersInitializedEvent();
                                break;
                            case FileLayer.FileLayersEventType.OnClick:
                                event = new FileLayer.FileLayersOnClickEvent();
                                break;
                            default:
                                this._fileLayer.map.mapEvents.trigger(Event.OSMap.MapEventType.OnError, this._fileLayer.map, Maps.Enum.ErrorCodes.GEN_UnsupportedEventFileLayer, `${eventType}`);
                                return;
                        }
                        return event;
                    }
                    trigger(eventType, data, fileLayerEventParams, ...args) {
                        if (this.handlers.has(eventType)) {
                            const handlerEvent = this.handlers.get(eventType);
                            switch (eventType) {
                                case FileLayer.FileLayersEventType.Initialized:
                                    handlerEvent.trigger(this._fileLayer.map.widgetId, this._fileLayer.widgetId || this._fileLayer.uniqueId);
                                    break;
                                case FileLayer.FileLayersEventType.OnClick:
                                    handlerEvent.trigger(this._fileLayer.map.widgetId, this._fileLayer.widgetId || this._fileLayer.uniqueId, fileLayerEventParams.coordinates, fileLayerEventParams.featureData, ...args);
                                    break;
                                default:
                                    this._fileLayer.map.mapEvents.trigger(Event.OSMap.MapEventType.OnError, this._fileLayer.map, Maps.Enum.ErrorCodes.GEN_UnsupportedEventFileLayer, `${eventType}`);
                                    return;
                            }
                        }
                    }
                }
                FileLayer.FileLayersEventsManager = FileLayersEventsManager;
            })(FileLayer = Event.FileLayer || (Event.FileLayer = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var FileLayer;
            (function (FileLayer) {
                class FileLayersInitializedEvent extends FileLayer.AbstractFileLayersEvent {
                }
                FileLayer.FileLayersInitializedEvent = FileLayersInitializedEvent;
            })(FileLayer = Event.FileLayer || (Event.FileLayer = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var FileLayer;
            (function (FileLayer) {
                class FileLayersOnClickEvent extends FileLayer.AbstractFileLayersEvent {
                }
                FileLayer.FileLayersOnClickEvent = FileLayersOnClickEvent;
            })(FileLayer = Event.FileLayer || (Event.FileLayer = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var Marker;
            (function (Marker) {
                class AbstractMarkerEvent extends Event.AbstractEvent {
                    trigger(mapId, markerId, ...args) {
                        this.handlers
                            .slice(0)
                            .forEach((h) => Maps.Helper.CallbackAsyncInvocation(h.eventHandler, mapId, markerId, ...args));
                    }
                }
                Marker.AbstractMarkerEvent = AbstractMarkerEvent;
            })(Marker = Event.Marker || (Event.Marker = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var Marker;
            (function (Marker) {
                let MarkerEventType;
                (function (MarkerEventType) {
                    MarkerEventType["Initialized"] = "Initialized";
                    MarkerEventType["OnEventTriggered"] = "OnEventTriggered";
                    MarkerEventType["OnClick"] = "OnClick";
                    MarkerEventType["OnMouseover"] = "OnMouseover";
                    MarkerEventType["OnMouseout"] = "OnMouseout";
                    MarkerEventType["ProviderEvent"] = "ProviderEvent";
                })(MarkerEventType = Marker.MarkerEventType || (Marker.MarkerEventType = {}));
            })(Marker = Event.Marker || (Event.Marker = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var Marker;
            (function (Marker) {
                class MarkerEventsManager extends Event.AbstractEventsManager {
                    constructor(marker) {
                        super();
                        this._marker = marker;
                    }
                    getInstanceOfEventType(eventType) {
                        let event;
                        switch (eventType) {
                            case Marker.MarkerEventType.Initialized:
                                event = new Marker.MarkerInitializedEvent();
                                break;
                            case Marker.MarkerEventType.OnClick:
                                event = new Marker.MarkerOnClickEvent();
                                break;
                            case Marker.MarkerEventType.OnMouseout:
                                event = new Marker.MarkerOnMouseoutEvent();
                                break;
                            case Marker.MarkerEventType.OnMouseover:
                                event = new Marker.MarkerOnMouseoverEvent();
                                break;
                            case Marker.MarkerEventType.OnEventTriggered:
                                event = new Marker.MarkerOnEventTriggered();
                                break;
                            default:
                                if (this._marker.validateProviderEvent(eventType) === true) {
                                    event = new Marker.MarkerProviderEvent();
                                    break;
                                }
                                this._marker.map.mapEvents.trigger(Event.OSMap.MapEventType.OnError, this._marker.map, Maps.Enum.ErrorCodes.GEN_UnsupportedEventMarker, `${eventType}`);
                                return;
                        }
                        return event;
                    }
                    trigger(eventType, eventInfo, ...args) {
                        const hasEvents = eventType === Marker.MarkerEventType.ProviderEvent
                            ? this.handlers.has(eventInfo)
                            : this.handlers.has(eventType);
                        if (hasEvents) {
                            const handlerEvent = this.handlers.get(eventType);
                            switch (eventType) {
                                case Marker.MarkerEventType.Initialized:
                                case Marker.MarkerEventType.OnMouseout:
                                case Marker.MarkerEventType.OnMouseover:
                                    handlerEvent.trigger(this._marker.map.widgetId, this._marker.widgetId || this._marker.uniqueId, eventType, this._marker.index);
                                    break;
                                case Marker.MarkerEventType.OnClick:
                                    handlerEvent.trigger(this._marker.map.widgetId, this._marker.widgetId || this._marker.uniqueId, eventType, ...args);
                                    break;
                                case Marker.MarkerEventType.OnEventTriggered:
                                    handlerEvent.trigger(this._marker.map.widgetId, this._marker.widgetId || this._marker.uniqueId, this._marker.index, eventInfo);
                                    break;
                                case Marker.MarkerEventType.ProviderEvent:
                                    if (this._marker.validateProviderEvent(eventInfo) === true) {
                                        const handler = this.handlers.get(eventInfo);
                                        handler.trigger(this._marker.map.widgetId, this._marker.widgetId || this._marker.uniqueId, eventInfo, ...args);
                                        break;
                                    }
                                default:
                                    this._marker.map.mapEvents.trigger(Event.OSMap.MapEventType.OnError, this._marker.map, Maps.Enum.ErrorCodes.GEN_UnsupportedEventMarker, `${eventType}`);
                                    return;
                            }
                        }
                    }
                }
                Marker.MarkerEventsManager = MarkerEventsManager;
            })(Marker = Event.Marker || (Event.Marker = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var Marker;
            (function (Marker) {
                class MarkerInitializedEvent extends Marker.AbstractMarkerEvent {
                }
                Marker.MarkerInitializedEvent = MarkerInitializedEvent;
            })(Marker = Event.Marker || (Event.Marker = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var Marker;
            (function (Marker) {
                class MarkerOnClickEvent extends Marker.AbstractMarkerEvent {
                }
                Marker.MarkerOnClickEvent = MarkerOnClickEvent;
            })(Marker = Event.Marker || (Event.Marker = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var Marker;
            (function (Marker) {
                class MarkerOnEventTriggered extends Marker.AbstractMarkerEvent {
                }
                Marker.MarkerOnEventTriggered = MarkerOnEventTriggered;
            })(Marker = Event.Marker || (Event.Marker = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var Marker;
            (function (Marker) {
                class MarkerOnMouseoutEvent extends Marker.AbstractMarkerEvent {
                }
                Marker.MarkerOnMouseoutEvent = MarkerOnMouseoutEvent;
            })(Marker = Event.Marker || (Event.Marker = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var Marker;
            (function (Marker) {
                class MarkerOnMouseoverEvent extends Marker.AbstractMarkerEvent {
                }
                Marker.MarkerOnMouseoverEvent = MarkerOnMouseoverEvent;
            })(Marker = Event.Marker || (Event.Marker = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var Marker;
            (function (Marker) {
                class MarkerProviderEvent extends Marker.AbstractMarkerEvent {
                    trigger(mapId, markerId, eventName, coords) {
                        this.handlers
                            .slice(0)
                            .forEach((h) => Maps.Helper.CallbackAsyncInvocation(h.eventHandler, mapId, markerId, eventName, coords));
                    }
                }
                Marker.MarkerProviderEvent = MarkerProviderEvent;
            })(Marker = Event.Marker || (Event.Marker = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var OSMap;
            (function (OSMap) {
                class AbstractMapEvent extends Event.AbstractEvent {
                    trigger(mapObj, mapId, ...args) {
                        this.handlers
                            .slice(0)
                            .forEach((h) => Maps.Helper.CallbackAsyncInvocation(h.eventHandler, mapObj, mapId, ...args));
                    }
                }
                OSMap.AbstractMapEvent = AbstractMapEvent;
            })(OSMap = Event.OSMap || (Event.OSMap = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var OSMap;
            (function (OSMap) {
                let MapEventType;
                (function (MapEventType) {
                    MapEventType["Initialized"] = "Initialized";
                    MapEventType["OnError"] = "OnError";
                    MapEventType["OnEventTriggered"] = "OnEventTriggered";
                    MapEventType["ProviderEvent"] = "ProviderEvent";
                })(MapEventType = OSMap.MapEventType || (OSMap.MapEventType = {}));
            })(OSMap = Event.OSMap || (Event.OSMap = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var OSMap;
            (function (OSMap) {
                class MapEventsManager extends Event.AbstractEventsManager {
                    constructor(map) {
                        super();
                        this._map = map;
                    }
                    getInstanceOfEventType(eventType) {
                        let event;
                        switch (eventType) {
                            case OSMap.MapEventType.Initialized:
                                event = new OSMap.MapInitializedEvent();
                                break;
                            case OSMap.MapEventType.OnError:
                                event = new OSMap.MapOnError();
                                break;
                            case OSMap.MapEventType.OnEventTriggered:
                                event = new OSMap.MapOnEventTriggered();
                                break;
                            default:
                                if (this._map.validateProviderEvent(eventType) === true) {
                                    event = new OSMap.MapProviderEvent();
                                    break;
                                }
                                this._map.mapEvents.trigger(OSMap.MapEventType.OnError, this._map, Maps.Enum.ErrorCodes.GEN_UnsupportedEventMap, `${eventType}`);
                                return;
                        }
                        return event;
                    }
                    addHandler(eventType, handler, eventUniqueId) {
                        if (eventType === OSMap.MapEventType.Initialized && this._map.isReady) {
                            Maps.Helper.CallbackAsyncInvocation(handler, this._map, this._map.widgetId);
                        }
                        else {
                            super.addHandler(eventType, handler, eventUniqueId);
                        }
                    }
                    trigger(eventType, map, eventInfo, ...args) {
                        const hasEvents = eventType === OSMap.MapEventType.ProviderEvent
                            ? this.handlers.has(eventInfo)
                            : this.handlers.has(eventType);
                        if (hasEvents) {
                            const handlerEvent = this.handlers.get(eventType);
                            switch (eventType) {
                                case OSMap.MapEventType.Initialized:
                                    handlerEvent.trigger(map, map.widgetId);
                                    break;
                                case OSMap.MapEventType.OnError:
                                    handlerEvent.trigger(map, map.widgetId, eventInfo, ...args);
                                    break;
                                case OSMap.MapEventType.OnEventTriggered:
                                    handlerEvent.trigger(map, map.widgetId, eventInfo);
                                    break;
                                case OSMap.MapEventType.ProviderEvent:
                                    if (this._map.validateProviderEvent(eventInfo) === true) {
                                        const handler = this.handlers.get(eventInfo);
                                        handler.trigger(map, map.widgetId, eventInfo, ...args);
                                        break;
                                    }
                                default:
                                    this._map.mapEvents.trigger(OSMap.MapEventType.OnError, map, Maps.Enum.ErrorCodes.GEN_UnsupportedEventMap, `${eventType}`);
                                    return;
                            }
                        }
                    }
                }
                OSMap.MapEventsManager = MapEventsManager;
            })(OSMap = Event.OSMap || (Event.OSMap = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var OSMap;
            (function (OSMap) {
                class MapInitializedEvent extends OSMap.AbstractMapEvent {
                }
                OSMap.MapInitializedEvent = MapInitializedEvent;
            })(OSMap = Event.OSMap || (Event.OSMap = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var OSMap;
            (function (OSMap) {
                class MapOnError extends OSMap.AbstractMapEvent {
                    trigger(mapObj, mapId, eventName, errorMessage) {
                        this.handlers
                            .slice(0)
                            .forEach((h) => Maps.Helper.CallbackAsyncInvocation(h.eventHandler, mapObj, mapId, eventName, errorMessage));
                    }
                }
                OSMap.MapOnError = MapOnError;
            })(OSMap = Event.OSMap || (Event.OSMap = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var OSMap;
            (function (OSMap) {
                class MapOnEventTriggered extends OSMap.AbstractMapEvent {
                }
                OSMap.MapOnEventTriggered = MapOnEventTriggered;
            })(OSMap = Event.OSMap || (Event.OSMap = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var OSMap;
            (function (OSMap) {
                class MapProviderEvent extends OSMap.AbstractMapEvent {
                    trigger(mapObj, mapId, eventName, coords, eventUniqueId) {
                        this.handlers.slice(0).forEach((h) => {
                            if (document.querySelector('.event-preview[name="' + h.uniqueId + '"]')) {
                                Maps.Helper.CallbackAsyncInvocation(h.eventHandler, mapObj, mapId, eventName, coords, eventUniqueId);
                            }
                        });
                    }
                }
                OSMap.MapProviderEvent = MapProviderEvent;
            })(OSMap = Event.OSMap || (Event.OSMap = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var SearchPlaces;
            (function (SearchPlaces) {
                class AbstractSearchPlacesEvent extends Event.AbstractEvent {
                    trigger(searchPlacesObj, searchPlacesId, ...args) {
                        this.handlers
                            .slice(0)
                            .forEach((h) => Maps.Helper.CallbackAsyncInvocation(h.eventHandler, searchPlacesObj, searchPlacesId, ...args));
                    }
                }
                SearchPlaces.AbstractSearchPlacesEvent = AbstractSearchPlacesEvent;
            })(SearchPlaces = Event.SearchPlaces || (Event.SearchPlaces = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var SearchPlaces;
            (function (SearchPlaces) {
                let SearchPlacesEventType;
                (function (SearchPlacesEventType) {
                    SearchPlacesEventType["Initialized"] = "Initialized";
                    SearchPlacesEventType["OnError"] = "OnError";
                    SearchPlacesEventType["OnPlaceSelect"] = "OnPlaceSelect";
                })(SearchPlacesEventType = SearchPlaces.SearchPlacesEventType || (SearchPlaces.SearchPlacesEventType = {}));
            })(SearchPlaces = Event.SearchPlaces || (Event.SearchPlaces = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var SearchPlaces;
            (function (SearchPlaces) {
                class SearchPlacesEventsManager extends Event.AbstractEventsManager {
                    constructor(searchPlaces) {
                        super();
                        this._searchPlaces = searchPlaces;
                    }
                    getInstanceOfEventType(eventType) {
                        let event;
                        switch (eventType) {
                            case SearchPlaces.SearchPlacesEventType.Initialized:
                                event = new SearchPlaces.SearchPlacesInitializedEvent();
                                break;
                            case SearchPlaces.SearchPlacesEventType.OnError:
                                event = new SearchPlaces.SearchPlacesOnError();
                                break;
                            case SearchPlaces.SearchPlacesEventType.OnPlaceSelect:
                                event = new SearchPlaces.SearchPlacesOnPlaceSelect();
                                break;
                            default:
                                this._searchPlaces.searchPlacesEvents.trigger(SearchPlaces.SearchPlacesEventType.OnError, this._searchPlaces, Maps.Enum.ErrorCodes.GEN_UnsupportedEventSearchPlaces, undefined, `${eventType}`);
                                return;
                        }
                        return event;
                    }
                    addHandler(eventType, handler, eventUniqueId) {
                        if (eventType === SearchPlaces.SearchPlacesEventType.Initialized && this._searchPlaces.isReady) {
                            Maps.Helper.CallbackAsyncInvocation(handler, this._searchPlaces, this._searchPlaces.widgetId);
                        }
                        else {
                            super.addHandler(eventType, handler, eventUniqueId);
                        }
                    }
                    trigger(eventType, searchPlaces, eventInfo, searchPlacesEventParams, ...args) {
                        if (this.handlers.has(eventType)) {
                            const handlerEvent = this.handlers.get(eventType);
                            switch (eventType) {
                                case SearchPlaces.SearchPlacesEventType.Initialized:
                                    handlerEvent.trigger(searchPlaces, searchPlaces.widgetId || searchPlaces.uniqueId);
                                    break;
                                case SearchPlaces.SearchPlacesEventType.OnError:
                                    handlerEvent.trigger(searchPlaces, searchPlaces.widgetId || searchPlaces.uniqueId, eventInfo, ...args);
                                    break;
                                case SearchPlaces.SearchPlacesEventType.OnPlaceSelect:
                                    handlerEvent.trigger(searchPlaces, searchPlaces.widgetId || searchPlaces.uniqueId, searchPlacesEventParams.name, searchPlacesEventParams.coordinates, searchPlacesEventParams.address);
                                    break;
                                default:
                                    this._searchPlaces.searchPlacesEvents.trigger(SearchPlaces.SearchPlacesEventType.OnError, searchPlaces, Maps.Enum.ErrorCodes.GEN_UnsupportedEventSearchPlaces, undefined, `${eventType}`);
                                    return;
                            }
                        }
                    }
                }
                SearchPlaces.SearchPlacesEventsManager = SearchPlacesEventsManager;
            })(SearchPlaces = Event.SearchPlaces || (Event.SearchPlaces = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var SearchPlaces;
            (function (SearchPlaces) {
                class SearchPlacesInitializedEvent extends SearchPlaces.AbstractSearchPlacesEvent {
                }
                SearchPlaces.SearchPlacesInitializedEvent = SearchPlacesInitializedEvent;
            })(SearchPlaces = Event.SearchPlaces || (Event.SearchPlaces = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var SearchPlaces;
            (function (SearchPlaces) {
                class SearchPlacesOnError extends SearchPlaces.AbstractSearchPlacesEvent {
                    trigger(searchPlacesObj, searchPlacesId, eventName, errorMessage) {
                        this.handlers
                            .slice(0)
                            .forEach((h) => Maps.Helper.CallbackAsyncInvocation(h.eventHandler, searchPlacesObj, searchPlacesId, eventName, errorMessage));
                    }
                }
                SearchPlaces.SearchPlacesOnError = SearchPlacesOnError;
            })(SearchPlaces = Event.SearchPlaces || (Event.SearchPlaces = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var SearchPlaces;
            (function (SearchPlaces) {
                class SearchPlacesOnPlaceSelect extends SearchPlaces.AbstractSearchPlacesEvent {
                }
                SearchPlaces.SearchPlacesOnPlaceSelect = SearchPlacesOnPlaceSelect;
            })(SearchPlaces = Event.SearchPlaces || (Event.SearchPlaces = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var Shape;
            (function (Shape) {
                class AbstractShapeEvent extends Event.AbstractEvent {
                    trigger(mapId, shapeId, ...args) {
                        this.handlers
                            .slice(0)
                            .forEach((h) => Maps.Helper.CallbackAsyncInvocation(h.eventHandler, mapId, shapeId, ...args));
                    }
                }
                Shape.AbstractShapeEvent = AbstractShapeEvent;
            })(Shape = Event.Shape || (Event.Shape = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var Shape;
            (function (Shape) {
                let ShapeEventType;
                (function (ShapeEventType) {
                    ShapeEventType["Initialized"] = "Initialized";
                    ShapeEventType["OnClick"] = "OnClick";
                    ShapeEventType["ProviderEvent"] = "ProviderEvent";
                })(ShapeEventType = Shape.ShapeEventType || (Shape.ShapeEventType = {}));
            })(Shape = Event.Shape || (Event.Shape = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var Shape;
            (function (Shape) {
                class ShapeEventsManager extends Event.AbstractEventsManager {
                    constructor(shape) {
                        super();
                        this._shape = shape;
                    }
                    getInstanceOfEventType(eventType) {
                        let event;
                        switch (eventType) {
                            case Shape.ShapeEventType.Initialized:
                                event = new Shape.ShapeInitializedEvent();
                                break;
                            case Shape.ShapeEventType.OnClick:
                                event = new Shape.ShapeOnClickEvent();
                                break;
                            default:
                                if (this._shape.validateProviderEvent(eventType) === true) {
                                    event = new Shape.ShapeProviderEvent();
                                    break;
                                }
                                this._shape.map.mapEvents.trigger(Event.OSMap.MapEventType.OnError, this._shape.map, Maps.Enum.ErrorCodes.GEN_UnsupportedEventShape, `${eventType}`);
                                return;
                        }
                        return event;
                    }
                    trigger(eventType, eventInfo, ...args) {
                        const hasEvents = eventType === Shape.ShapeEventType.ProviderEvent
                            ? this.handlers.has(eventInfo)
                            : this.handlers.has(eventType);
                        if (hasEvents) {
                            const handlerEvent = this.handlers.get(eventType);
                            switch (eventType) {
                                case Shape.ShapeEventType.Initialized:
                                    handlerEvent.trigger(this._shape.map.widgetId, this._shape.widgetId || this._shape.uniqueId);
                                    break;
                                case Shape.ShapeEventType.OnClick:
                                    handlerEvent.trigger(this._shape.map.widgetId, this._shape.widgetId || this._shape.uniqueId);
                                    break;
                                case Shape.ShapeEventType.ProviderEvent:
                                    if (this._shape.validateProviderEvent(eventInfo) === true) {
                                        const handler = this.handlers.get(eventInfo);
                                        handler.trigger(this._shape.map.widgetId, this._shape.widgetId || this._shape.uniqueId, eventInfo, ...args);
                                        break;
                                    }
                                default:
                                    this._shape.map.mapEvents.trigger(Event.OSMap.MapEventType.OnError, this._shape.map, Maps.Enum.ErrorCodes.GEN_UnsupportedEventMarker, `${eventType}`);
                                    return;
                            }
                        }
                    }
                }
                Shape.ShapeEventsManager = ShapeEventsManager;
            })(Shape = Event.Shape || (Event.Shape = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var Shape;
            (function (Shape) {
                class ShapeInitializedEvent extends Shape.AbstractShapeEvent {
                }
                Shape.ShapeInitializedEvent = ShapeInitializedEvent;
            })(Shape = Event.Shape || (Event.Shape = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var Shape;
            (function (Shape) {
                class ShapeOnClickEvent extends Shape.AbstractShapeEvent {
                }
                Shape.ShapeOnClickEvent = ShapeOnClickEvent;
            })(Shape = Event.Shape || (Event.Shape = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Event;
        (function (Event) {
            var Shape;
            (function (Shape) {
                class ShapeProviderEvent extends Shape.AbstractShapeEvent {
                    trigger(mapId, shapeId, eventName, coords) {
                        this.handlers
                            .slice(0)
                            .forEach((h) => Maps.Helper.CallbackAsyncInvocation(h.eventHandler, mapId, shapeId, eventName, coords));
                    }
                }
                Shape.ShapeProviderEvent = ShapeProviderEvent;
            })(Shape = Event.Shape || (Event.Shape = {}));
        })(Event = Maps.Event || (Maps.Event = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Feature;
        (function (Feature) {
            class ExposedFeatures {
            }
            Feature.ExposedFeatures = ExposedFeatures;
        })(Feature = Maps.Feature || (Maps.Feature = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var FileLayer;
        (function (FileLayer) {
            class AbstractFileLayer {
                constructor(map, uniqueId, config) {
                    this._map = map;
                    this._uniqueId = uniqueId;
                    this._config = config;
                    this._built = false;
                    this._fileLayerEvents = new Maps.Event.FileLayer.FileLayersEventsManager(this);
                    this._createElements = [];
                }
                get config() {
                    return this._config;
                }
                get createdElements() {
                    return this._createElements;
                }
                get fileLayerEvents() {
                    return this._fileLayerEvents;
                }
                get isReady() {
                    return this._built;
                }
                get map() {
                    return this._map;
                }
                get provider() {
                    return this._provider;
                }
                get uniqueId() {
                    return this._uniqueId;
                }
                get widgetId() {
                    if (this._widgetId === undefined || this._widgetId === '') {
                        this._setWidgetId();
                    }
                    return this._widgetId;
                }
                _setWidgetId() {
                    this._widgetId = Maps.Helper.GetElementByUniqueId(this.uniqueId, false)
                        ? Maps.Helper.GetElementByUniqueId(this.uniqueId).closest(Maps.Helper.Constants.fileLayerTag).id
                        : undefined;
                }
                finishBuild() {
                    this._built = true;
                    this.fileLayerEvents.trigger(Maps.Event.FileLayer.FileLayersEventType.Initialized);
                }
                build() {
                    if (this._built)
                        return;
                    this._setWidgetId();
                }
                changeProperty(propertyName, propertyValue) {
                    if (this.config.hasOwnProperty(propertyName)) {
                        this.config[propertyName] = propertyValue;
                    }
                    else {
                        this.map.mapEvents.trigger(Maps.Event.OSMap.MapEventType.OnError, this.map, Maps.Enum.ErrorCodes.GEN_InvalidChangePropertyFileLayer, `${propertyName}`);
                    }
                }
                dispose() {
                    this._built = false;
                }
                equalsToID(id) {
                    return id === this._uniqueId || id === this.widgetId;
                }
                getProviderConfig() {
                    return this._config.getProviderConfig();
                }
            }
            FileLayer.AbstractFileLayer = AbstractFileLayer;
        })(FileLayer = Maps.FileLayer || (Maps.FileLayer = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var HeatmapLayer;
        (function (HeatmapLayer) {
            class AbstractHeatmapLayer {
                constructor(map, uniqueId, config) {
                    this._map = map;
                    this._uniqueId = uniqueId;
                    this._config = config;
                    this._built = false;
                }
                get config() {
                    return this._config;
                }
                get isReady() {
                    return this._built;
                }
                get map() {
                    return this._map;
                }
                get provider() {
                    return this._provider;
                }
                get uniqueId() {
                    return this._uniqueId;
                }
                get widgetId() {
                    if (this._widgetId === undefined || this._widgetId === '') {
                        this._setWidgetId();
                    }
                    return this._widgetId;
                }
                _setWidgetId() {
                    this._widgetId = Maps.Helper.GetElementByUniqueId(this.uniqueId, false)
                        ? Maps.Helper.GetElementByUniqueId(this.uniqueId).closest(Maps.Helper.Constants.heatmapLayerTag).id
                        : undefined;
                }
                finishBuild() {
                    this._built = true;
                }
                build() {
                    if (this._built)
                        return;
                    this._setWidgetId();
                }
                changeProperty(propertyName, propertyValue) {
                    if (this.config.hasOwnProperty(propertyName)) {
                        this.config[propertyName] = propertyValue;
                    }
                    else {
                        this.map.mapEvents.trigger(Maps.Event.OSMap.MapEventType.OnError, this.map, Maps.Enum.ErrorCodes.GEN_InvalidChangePropertyHeatmapLayer, `${propertyName}`);
                    }
                }
                dispose() {
                    this._built = false;
                }
                equalsToID(id) {
                    return id === this._uniqueId || id === this.widgetId;
                }
                getProviderConfig() {
                    return this._config.getProviderConfig();
                }
            }
            HeatmapLayer.AbstractHeatmapLayer = AbstractHeatmapLayer;
        })(HeatmapLayer = Maps.HeatmapLayer || (Maps.HeatmapLayer = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Helper;
        (function (Helper) {
            function CallbackAsyncInvocation(callback, ...args) {
                if (callback) {
                    setTimeout(callback, 0, ...args);
                }
            }
            Helper.CallbackAsyncInvocation = CallbackAsyncInvocation;
        })(Helper = Maps.Helper || (Maps.Helper = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Helper;
        (function (Helper) {
            var Constants;
            (function (Constants) {
                Constants.markerGeneric = '[data-block*="Marker.Marker"]';
                Constants.markerTag = '[data-block="Marker.Marker"]';
                Constants.markerPopupTag = '[data-block="Marker.MarkerPopup"]';
                Constants.shapeGeneric = '[data-block*="Shapes."]';
                Constants.shapePolylineTag = '[data-block="Shapes.Polyline"]';
                Constants.shapePolygonTag = '[data-block="Shapes.Polygon"]';
                Constants.shapeCircleTag = '[data-block="Shapes.Circle"]';
                Constants.shapeRectangleTag = '[data-block="Shapes.Rectangle"]';
                Constants.fileLayerTag = '[data-block="FileLayer.FileLayer"]';
                Constants.heatmapLayerTag = '[data-block="HeatmapLayer.HeatmapLayer"]';
                Constants.searchPlacesTag = '[data-block="SearchPlaces.SearchPlaces"]';
                Constants.searchPlacesTag_Legacy = '[data-block="SearchPlaces_Legacy.SearchPlaces_Legacy"]';
                Constants.outsystemsWidgetTag = '[data-block]';
                Constants.staticMapTag = '[data-block="Maps.StaticMap"]';
                Constants.mapTag = `[data-block*="Maps."]:not(${Constants.staticMapTag})`;
                Constants.drawingToolsTag = '[data-block="Drawing_Tools.Drawing_Tools"]';
                Constants.drawingToolsGeneric = '[data-block*="Drawing_Tools.Draw"]';
                Constants.runtimeMapUniqueIdCss = '.runtime-map-container';
                Constants.mapUniqueIdCss = '.map-container';
                Constants.markerPopup = '.marker-popup-placeholder';
                Constants.markerUniqueIdCss = '.ss-marker';
                Constants.staticMapCss = '.staticMap-image';
                Constants.shapeUniqueIdCss = '.ss-shape';
                Constants.drawingToolsUniqueIdCss = '.ss-drawingTools';
                Constants.uniqueIdAttribute = 'name';
                Constants.runtimeSearchPlacesUniqueIdCss = '.ss-searchPlaces';
                Constants.defaultMapCenter = { lat: 42.3517926, lng: -71.0467845 };
                Constants.zoomAutofit = Maps.Enum.OSMap.Zoom.Zoom8;
                Constants.shapeChangedEvent = 'shape_changed';
                Constants.drawingMarkerCompleted = 'markercomplete';
                Constants.drawingPolylineCompleted = 'polylinecomplete';
                Constants.drawingPolygonCompleted = 'polygoncomplete';
                Constants.drawingCircleCompleted = 'circlecomplete';
                Constants.drawingRectangleCompleted = 'rectanglecomplete';
                Constants.clusterIconCSSClass = 'custom-clustericon';
            })(Constants = Helper.Constants || (Helper.Constants = {}));
        })(Helper = Maps.Helper || (Maps.Helper = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Helper;
        (function (Helper) {
            function HasAllEmptyBounds(location) {
                if (!location) {
                    return true;
                }
                return (Helper.IsEmptyString(location.north) &&
                    Helper.IsEmptyString(location.south) &&
                    Helper.IsEmptyString(location.east) &&
                    Helper.IsEmptyString(location.west));
            }
            Helper.HasAllEmptyBounds = HasAllEmptyBounds;
            function HasAnyEmptyBound(location) {
                if (!location) {
                    return true;
                }
                return (Helper.IsEmptyString(location.north) ||
                    Helper.IsEmptyString(location.south) ||
                    Helper.IsEmptyString(location.east) ||
                    Helper.IsEmptyString(location.west));
            }
            Helper.HasAnyEmptyBound = HasAnyEmptyBound;
        })(Helper = Maps.Helper || (Maps.Helper = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Helper;
        (function (Helper) {
            function GenerateHashCode(str) {
                let hash = 0;
                let i = 0;
                let chr;
                for (; i < str.length; i++) {
                    chr = str.charCodeAt(i);
                    hash = (hash << 5) - hash + chr;
                    hash |= 0;
                }
                return hash;
            }
            Helper.GenerateHashCode = GenerateHashCode;
        })(Helper = Maps.Helper || (Maps.Helper = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Helper;
        (function (Helper) {
            function GenerateUniqueId() {
                return Math.random().toString(36);
            }
            Helper.GenerateUniqueId = GenerateUniqueId;
        })(Helper = Maps.Helper || (Maps.Helper = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Helper;
        (function (Helper) {
            function GetClosestMapId(elem) {
                let child;
                if (typeof elem === 'string' || elem instanceof String)
                    child = Helper.GetElementByUniqueId(elem);
                else
                    child = elem;
                const domMap = child.closest(Helper.Constants.mapTag);
                if (domMap) {
                    const uniqueId = domMap
                        .querySelector(Helper.Constants.mapUniqueIdCss)
                        .getAttribute(Helper.Constants.uniqueIdAttribute);
                    return uniqueId;
                }
                return null;
            }
            Helper.GetClosestMapId = GetClosestMapId;
            function GetClosestMarkerId(elem) {
                let child;
                if (typeof elem === 'string' || elem instanceof String)
                    child = Helper.GetElementByUniqueId(elem);
                else
                    child = elem;
                const domMarker = child.closest(Helper.Constants.markerGeneric);
                if (domMarker) {
                    const uniqueId = domMarker
                        .querySelector(Helper.Constants.markerUniqueIdCss)
                        .getAttribute(Helper.Constants.uniqueIdAttribute);
                    return uniqueId;
                }
                throw new Error("The marker doesn't exist on the DOM");
            }
            Helper.GetClosestMarkerId = GetClosestMarkerId;
            function GetClosestShapeId(elem) {
                let child;
                if (typeof elem === 'string' || elem instanceof String)
                    child = Helper.GetElementByUniqueId(elem);
                else
                    child = elem;
                const domShape = child.closest(Helper.Constants.shapeGeneric);
                if (domShape) {
                    const uniqueId = domShape
                        .querySelector(Helper.Constants.shapeUniqueIdCss)
                        .getAttribute(Helper.Constants.uniqueIdAttribute);
                    return uniqueId;
                }
                throw new Error("The shape doesn't exist on the DOM");
            }
            Helper.GetClosestShapeId = GetClosestShapeId;
            function GetClosestDrawingToolsId(elem) {
                let child;
                if (typeof elem === 'string' || elem instanceof String)
                    child = Helper.GetElementByUniqueId(elem);
                else
                    child = elem;
                const domShape = child.closest(Helper.Constants.drawingToolsTag);
                if (domShape) {
                    const uniqueId = domShape
                        .querySelector(Helper.Constants.drawingToolsUniqueIdCss)
                        .getAttribute(Helper.Constants.uniqueIdAttribute);
                    return uniqueId;
                }
                throw new Error("The DrawingTools element doesn't exist on the DOM");
            }
            Helper.GetClosestDrawingToolsId = GetClosestDrawingToolsId;
            function GetClosestSearchPlacesId(elem) {
                let child;
                if (typeof elem === 'string' || elem instanceof String)
                    child = Helper.GetElementByUniqueId(elem);
                else
                    child = elem;
                const domMap = child.closest(Helper.Constants.searchPlacesTag);
                if (domMap) {
                    const uniqueId = domMap
                        .querySelector(Helper.Constants.runtimeSearchPlacesUniqueIdCss)
                        .getAttribute(Helper.Constants.uniqueIdAttribute);
                    return uniqueId;
                }
                throw new Error("The SearchPlaces element doesn't exist on the DOM");
            }
            Helper.GetClosestSearchPlacesId = GetClosestSearchPlacesId;
        })(Helper = Maps.Helper || (Maps.Helper = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Helper;
        (function (Helper) {
            function GetElementByUniqueId(uniqueId, raiseError = true) {
                const obj = document.getElementsByName(uniqueId);
                if (obj.length) {
                    return obj[0];
                }
                else if (raiseError) {
                    throw new Error(`Object with name '${uniqueId}' not found.`);
                }
                else {
                    return undefined;
                }
            }
            Helper.GetElementByUniqueId = GetElementByUniqueId;
        })(Helper = Maps.Helper || (Maps.Helper = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Helper;
        (function (Helper) {
            function GetElementByWidgetId(widgetId) {
                const obj = document.getElementById(widgetId);
                if (obj)
                    return obj;
                else
                    throw new Error(`Object with name '${widgetId}' not found.`);
            }
            Helper.GetElementByWidgetId = GetElementByWidgetId;
        })(Helper = Maps.Helper || (Maps.Helper = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Helper;
        (function (Helper) {
            function IsEmptyString(text) {
                return typeof text !== 'string' || text === '' || text.trim().length === 0;
            }
            Helper.IsEmptyString = IsEmptyString;
        })(Helper = Maps.Helper || (Maps.Helper = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Helper;
        (function (Helper) {
            function IsValidNumber(value) {
                return !isNaN(value);
            }
            Helper.IsValidNumber = IsValidNumber;
        })(Helper = Maps.Helper || (Maps.Helper = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Helper;
        (function (Helper) {
            function JsonFormatter(text) {
                let json = {};
                if (text === undefined || text === '')
                    return json;
                json = eval('(' + text + ')');
                return json;
            }
            Helper.JsonFormatter = JsonFormatter;
        })(Helper = Maps.Helper || (Maps.Helper = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Helper;
        (function (Helper) {
            var LocalStorage;
            (function (LocalStorage) {
                function GetItem(key) {
                    return window.localStorage.getItem(key);
                }
                LocalStorage.GetItem = GetItem;
                function HasItem(key) {
                    return window.localStorage.getItem(key) !== null;
                }
                LocalStorage.HasItem = HasItem;
                function SetItem(key, value) {
                    window.localStorage.setItem(key, value);
                }
                LocalStorage.SetItem = SetItem;
            })(LocalStorage = Helper.LocalStorage || (Helper.LocalStorage = {}));
        })(Helper = Maps.Helper || (Maps.Helper = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Helper;
        (function (Helper) {
            Helper.warningMessage = 'This API is deprecated please use the new api';
            function LogWarningMessage(message) {
                console.warn(message);
            }
            Helper.LogWarningMessage = LogWarningMessage;
        })(Helper = Maps.Helper || (Maps.Helper = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Helper;
        (function (Helper) {
            function ThrowError(map, errorCode, extraMessage) {
                map.mapEvents.trigger(Maps.Event.OSMap.MapEventType.OnError, map, errorCode, `${extraMessage || ''}`);
            }
            Helper.ThrowError = ThrowError;
        })(Helper = Maps.Helper || (Maps.Helper = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Helper;
        (function (Helper) {
            function ValidateFeatureProvider(map, feature) {
                if (map.providerType === Maps.Enum.ProviderType.Google)
                    return true;
                switch (feature) {
                    case Maps.Enum.Feature.Marker:
                    case Maps.Enum.Feature.MarkerPopup:
                    case Maps.Enum.Feature.Shapes:
                    case Maps.Enum.Feature.Directions:
                    case Maps.Enum.Feature.DrawingTools:
                        return true;
                    case Maps.Enum.Feature.HeatmapLayer:
                    case Maps.Enum.Feature.FileLayer:
                    default:
                        console.warn(`Feature ${feature} is not implemented for the Map Leaflet`);
                        return false;
                }
            }
            Helper.ValidateFeatureProvider = ValidateFeatureProvider;
        })(Helper = Maps.Helper || (Maps.Helper = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Marker;
        (function (Marker) {
            class AbstractMarker {
                constructor(map, uniqueId, type, config) {
                    this._map = map;
                    this._uniqueId = uniqueId;
                    this._config = config;
                    this._built = false;
                    this._destroyed = false;
                    this._markerEvents = new Maps.Event.Marker.MarkerEventsManager(this);
                }
                get config() {
                    return this._config;
                }
                get hasPopup() {
                    return false;
                }
                get index() {
                    return this._map.markers.findIndex((marker) => marker.uniqueId === this.uniqueId);
                }
                get isReady() {
                    return this._built;
                }
                get map() {
                    return this._map;
                }
                get markerEvents() {
                    return this._markerEvents;
                }
                get provider() {
                    return this._provider;
                }
                get uniqueId() {
                    return this._uniqueId;
                }
                get widgetId() {
                    return this._widgetId;
                }
                finishBuild() {
                    this._built = true;
                    this.markerEvents.trigger(Maps.Event.Marker.MarkerEventType.Initialized);
                    this._map.hasMarkerClusterer() && this._map.features.markerClusterer.addMarker(this);
                }
                build() {
                    if (this._built)
                        return;
                    this._widgetId = Maps.Helper.GetElementByUniqueId(this.uniqueId, false)
                        ? Maps.Helper.GetElementByUniqueId(this.uniqueId).closest(this.markerTag).id
                        : undefined;
                }
                changeProperty(propertyName, propertyValue) {
                    if (this.config.hasOwnProperty(propertyName)) {
                        this.config[propertyName] = propertyValue;
                    }
                    else {
                        this.map.mapEvents.trigger(Maps.Event.OSMap.MapEventType.OnError, this.map, Maps.Enum.ErrorCodes.GEN_InvalidChangePropertyMarker, `${propertyName}`);
                    }
                }
                dispose() {
                    this._built = false;
                    this._destroyed = true;
                }
                equalsToID(id) {
                    return id === this._uniqueId || id === this._widgetId;
                }
                getPosition() {
                    const provider = this._provider;
                    const position = provider.getPosition ? provider.getPosition() : provider.position;
                    return position;
                }
                getProviderConfig() {
                    return this.config.getProviderConfig();
                }
            }
            Marker.AbstractMarker = AbstractMarker;
        })(Marker = Maps.Marker || (Maps.Marker = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Marker;
        (function (Marker) {
            let MarkerFactory;
            (function (MarkerFactory) {
                function MakeMarker(map, markerId, type, configs) {
                    switch (map.providerType) {
                        case Maps.Enum.ProviderType.Google:
                            return Provider.Maps.Google.Marker.MarkerFactory.MakeMarker(map, markerId, type, configs);
                        case Maps.Enum.ProviderType.Leaflet:
                            return Provider.Maps.Leaflet.Marker.MarkerFactory.MakeMarker(map, markerId, type, configs);
                        default:
                            throw new Error(`There is no factory for the Marker using the provider ${map.providerType}`);
                    }
                }
                MarkerFactory.MakeMarker = MakeMarker;
            })(MarkerFactory = Marker.MarkerFactory || (Marker.MarkerFactory = {}));
        })(Marker = Maps.Marker || (Maps.Marker = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var OSMap;
        (function (OSMap) {
            class AbstractMap {
                constructor(uniqueId, providerType, config, mapType) {
                    this._uniqueId = uniqueId;
                    this._fileLayers = new Map();
                    this._heatmapLayers = new Map();
                    this._markers = new Map();
                    this._shapes = new Map();
                    this._fileLayersSet = new Set();
                    this._heatmapLayersSet = new Set();
                    this._markersSet = new Set();
                    this._shapesSet = new Set();
                    this._config = config;
                    this._isReady = false;
                    this._mapEvents = new Maps.Event.OSMap.MapEventsManager(this);
                    this._mapType = mapType;
                    this._mapRefreshRequest = 0;
                    this._providerType = providerType;
                    this._zoomChanged = false;
                    this._mapZoomChangeCallback = this._mapZoomChangeHandler.bind(this);
                }
                get allowRefreshZoom() {
                    return !(this.config.respectUserZoom && this._zoomChanged);
                }
                get shapes() {
                    return Array.from(this._shapesSet);
                }
                get config() {
                    return this._config;
                }
                get features() {
                    return this._features;
                }
                get isReady() {
                    return this._isReady;
                }
                get drawingTools() {
                    return this._drawingTools;
                }
                get fileLayers() {
                    return Array.from(this._fileLayersSet);
                }
                get heatmapLayers() {
                    return Array.from(this._heatmapLayersSet);
                }
                get markers() {
                    return Array.from(this._markersSet);
                }
                get markersReady() {
                    return this.markers.filter((marker) => marker.isReady).map((marker) => marker.provider);
                }
                get mapEvents() {
                    return this._mapEvents;
                }
                get provider() {
                    return this._provider;
                }
                get providerType() {
                    return this._providerType;
                }
                get uniqueId() {
                    return this._uniqueId;
                }
                get widgetId() {
                    return this._widgetId;
                }
                _mapZoomChangeHandler() {
                    if (this.config.respectUserZoom) {
                        this._zoomChanged = true;
                    }
                }
                finishBuild() {
                    this._isReady = true;
                    this.mapEvents.trigger(Maps.Event.OSMap.MapEventType.Initialized, this);
                }
                addDrawingTools(drawingTools) {
                    this._drawingTools = drawingTools;
                    return drawingTools;
                }
                addFileLayer(fileLayer) {
                    this._fileLayers.set(fileLayer.uniqueId, fileLayer);
                    this._fileLayersSet.add(fileLayer);
                    return fileLayer;
                }
                addHeatmapLayer(heatmapLayer) {
                    this._heatmapLayers.set(heatmapLayer.uniqueId, heatmapLayer);
                    this._heatmapLayersSet.add(heatmapLayer);
                    return heatmapLayer;
                }
                addMarker(marker) {
                    this._markers.set(marker.uniqueId, marker);
                    this._markersSet.add(marker);
                    return marker;
                }
                addShape(shape) {
                    this._shapes.set(shape.uniqueId, shape);
                    this._shapesSet.add(shape);
                    return shape;
                }
                build() {
                    this._widgetId = Maps.Helper.GetElementByUniqueId(this.uniqueId).closest(this.mapTag).id;
                }
                cancelScheduledResfresh() {
                    if (this._mapRefreshRequest !== 0) {
                        clearTimeout(this._mapRefreshRequest);
                        this._mapRefreshRequest = 0;
                    }
                }
                changeProperty(propertyName, propertyValue) {
                    if (this.config.hasOwnProperty(propertyName)) {
                        const propName = Maps.Enum.OS_Config_Map[propertyName];
                        if (propName === Maps.Enum.OS_Config_Map.offset || propName === Maps.Enum.OS_Config_Map.localization) {
                            propertyValue = JSON.parse(propertyValue);
                        }
                        this.config[propertyName] = propertyValue;
                        if (Maps.Enum.OS_Config_Map.respectUserZoom === Maps.Enum.OS_Config_Map[propertyName]) {
                            this._zoomChanged = false;
                        }
                    }
                    else {
                        this.mapEvents.trigger(Maps.Event.OSMap.MapEventType.OnError, this, Maps.Enum.ErrorCodes.GEN_InvalidChangePropertyMap, `${propertyName}`);
                    }
                }
                dispose() {
                    this._isReady = undefined;
                    this._markers.forEach((marker, markerId) => {
                        this.removeMarker(markerId);
                    });
                    this._shapes.forEach((shape, shapeId) => {
                        this.removeShape(shapeId);
                    });
                    this.drawingTools && this.removeDrawingTools(this.drawingTools.uniqueId);
                }
                equalsToID(mapId) {
                    return mapId === this._uniqueId || mapId === this._widgetId;
                }
                getFileLayer(fileLayerId) {
                    if (this._fileLayers.has(fileLayerId)) {
                        return this._fileLayers.get(fileLayerId);
                    }
                    else {
                        return this.fileLayers.find((p) => p && p.equalsToID(fileLayerId));
                    }
                }
                getHeatmapLayer(heatmapLayerId) {
                    if (this._heatmapLayers.has(heatmapLayerId)) {
                        return this._heatmapLayers.get(heatmapLayerId);
                    }
                    else {
                        return this.heatmapLayers.find((p) => p && p.equalsToID(heatmapLayerId));
                    }
                }
                getMarker(markerId) {
                    if (this._markers.has(markerId)) {
                        return this._markers.get(markerId);
                    }
                    else {
                        return this.markers.find((p) => p && p.equalsToID(markerId));
                    }
                }
                getShape(shape) {
                    if (this._shapes.has(shape)) {
                        return this._shapes.get(shape);
                    }
                    else {
                        return this.shapes.find((p) => p && p.equalsToID(shape));
                    }
                }
                hasFileLayer(fileLayerId) {
                    return this._fileLayers.has(fileLayerId);
                }
                hasHeatmapLayer(heatmapLayerId) {
                    return this._heatmapLayers.has(heatmapLayerId);
                }
                hasMarker(markerId) {
                    return this._markers.has(markerId);
                }
                hasMarkerClusterer() {
                    var _a, _b;
                    return (_b = (_a = this._features) === null || _a === void 0 ? void 0 : _a.markerClusterer) === null || _b === void 0 ? void 0 : _b.isEnabled;
                }
                hasShape(shapeId) {
                    return this._shapes.has(shapeId);
                }
                removeAllFileLayers() {
                    if (this._mapType === Maps.Enum.MapType.StaticMap && this.isReady) {
                        this.mapEvents.trigger(Maps.Event.OSMap.MapEventType.OnError, this, Maps.Enum.ErrorCodes.CFG_CantChangeParamsStaticMap);
                        return;
                    }
                    this._fileLayers.forEach((marker) => {
                        marker.dispose();
                    });
                    this._fileLayers.clear();
                    this._fileLayersSet.clear();
                    if (this._isReady) {
                        this.refresh();
                    }
                }
                removeAllMarkers() {
                    if (this._mapType === Maps.Enum.MapType.StaticMap && this.isReady) {
                        this.mapEvents.trigger(Maps.Event.OSMap.MapEventType.OnError, this, Maps.Enum.ErrorCodes.CFG_CantChangeParamsStaticMap);
                        return;
                    }
                    this._markers.forEach((marker) => {
                        this.hasMarkerClusterer() && this.features.markerClusterer.removeMarker(marker);
                        marker.dispose();
                    });
                    this._markers.clear();
                    this._markersSet.clear();
                    if (this._isReady) {
                        this.refresh();
                    }
                }
                removeAllShapes() {
                    if (this._mapType === Maps.Enum.MapType.StaticMap && this.isReady) {
                        this.mapEvents.trigger(Maps.Event.OSMap.MapEventType.OnError, this, Maps.Enum.ErrorCodes.CFG_CantChangeParamsStaticMap);
                        return;
                    }
                    this._shapes.forEach((shape) => {
                        shape.dispose();
                    });
                    this._shapes.clear();
                    this._shapesSet.clear();
                    if (this._isReady) {
                        this.refresh();
                    }
                }
                removeDrawingTools(drawingToolsId) {
                    if (this._mapType === Maps.Enum.MapType.StaticMap && this.isReady) {
                        this.mapEvents.trigger(Maps.Event.OSMap.MapEventType.OnError, this, Maps.Enum.ErrorCodes.CFG_CantChangeParamsStaticMap);
                        return;
                    }
                    if (this._drawingTools && this._drawingTools.uniqueId === drawingToolsId) {
                        this._drawingTools.dispose();
                        this._drawingTools = undefined;
                    }
                }
                removeFileLayer(fileLayerId) {
                    if (this._mapType === Maps.Enum.MapType.StaticMap && this.isReady) {
                        this.mapEvents.trigger(Maps.Event.OSMap.MapEventType.OnError, this, Maps.Enum.ErrorCodes.CFG_CantChangeParamsStaticMap);
                        return;
                    }
                    if (this._fileLayers.has(fileLayerId)) {
                        const fileLayer = this._fileLayers.get(fileLayerId);
                        fileLayer.dispose();
                        this._fileLayers.delete(fileLayerId);
                        this._fileLayersSet.delete(fileLayer);
                    }
                }
                removeHeatmapLayer(heatmapLayerId) {
                    if (this._mapType === Maps.Enum.MapType.StaticMap && this.isReady) {
                        this.mapEvents.trigger(Maps.Event.OSMap.MapEventType.OnError, this, Maps.Enum.ErrorCodes.CFG_CantChangeParamsStaticMap);
                        return;
                    }
                    if (this._heatmapLayers.has(heatmapLayerId)) {
                        const fileLayer = this._heatmapLayers.get(heatmapLayerId);
                        fileLayer.dispose();
                        this._heatmapLayers.delete(heatmapLayerId);
                        this._heatmapLayersSet.delete(fileLayer);
                    }
                }
                removeMarker(markerId) {
                    if (this._mapType === Maps.Enum.MapType.StaticMap && this.isReady) {
                        this.mapEvents.trigger(Maps.Event.OSMap.MapEventType.OnError, this, Maps.Enum.ErrorCodes.CFG_CantChangeParamsStaticMap);
                        return;
                    }
                    if (this._markers.has(markerId)) {
                        const marker = this._markers.get(markerId);
                        this.hasMarkerClusterer() && this.features.markerClusterer.removeMarker(marker);
                        marker.dispose();
                        this._markers.delete(markerId);
                        this._markersSet.delete(marker);
                        if (this._isReady) {
                            this.refresh();
                        }
                    }
                }
                removeShape(shapeId) {
                    if (this._mapType === Maps.Enum.MapType.StaticMap && this.isReady) {
                        this.mapEvents.trigger(Maps.Event.OSMap.MapEventType.OnError, this, Maps.Enum.ErrorCodes.CFG_CantChangeParamsStaticMap);
                        return;
                    }
                    if (this._shapes.has(shapeId)) {
                        const shape = this._shapes.get(shapeId);
                        shape.dispose();
                        this._shapes.delete(shapeId);
                        this._shapesSet.delete(shape);
                        if (this._isReady) {
                            this.refresh();
                        }
                    }
                }
                scheduleRefresh() {
                    this.cancelScheduledResfresh();
                    this._mapRefreshRequest = setTimeout(() => {
                        this.refresh();
                    }, 0);
                }
                updateHeight() {
                    return;
                }
            }
            OSMap.AbstractMap = AbstractMap;
        })(OSMap = Maps.OSMap || (Maps.OSMap = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var OSMap;
        (function (OSMap) {
            let MapFactory;
            (function (MapFactory) {
                function MakeMap(provider, type, mapdId, configs) {
                    switch (provider) {
                        case Maps.Enum.ProviderType.Google:
                            return Provider.Maps.Google.OSMap.MapFactory.MakeMap(type, mapdId, configs);
                        case Maps.Enum.ProviderType.Leaflet:
                            return Provider.Maps.Leaflet.OSMap.MapFactory.MakeMap(type, mapdId, configs);
                        default:
                            throw new Error(`There is no factory for this Map provider (${provider})`);
                    }
                }
                MapFactory.MakeMap = MakeMap;
            })(MapFactory = OSMap.MapFactory || (OSMap.MapFactory = {}));
        })(OSMap = Maps.OSMap || (Maps.OSMap = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var OSStructures;
        (function (OSStructures) {
            var API;
            (function (API) {
                class CircleProperties {
                }
                API.CircleProperties = CircleProperties;
            })(API = OSStructures.API || (OSStructures.API = {}));
        })(OSStructures = Maps.OSStructures || (Maps.OSStructures = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var OSStructures;
        (function (OSStructures) {
            var API;
            (function (API) {
                class PendingTools {
                }
                API.PendingTools = PendingTools;
            })(API = OSStructures.API || (OSStructures.API = {}));
        })(OSStructures = Maps.OSStructures || (Maps.OSStructures = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var OSStructures;
        (function (OSStructures) {
            var Directions;
            (function (Directions) {
                class Options {
                }
                Directions.Options = Options;
                class ExcludeCriteria {
                }
                Directions.ExcludeCriteria = ExcludeCriteria;
            })(Directions = OSStructures.Directions || (OSStructures.Directions = {}));
        })(OSStructures = Maps.OSStructures || (Maps.OSStructures = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var OSStructures;
        (function (OSStructures) {
            var OSMap;
            (function (OSMap) {
                class BoundsString {
                }
                OSMap.BoundsString = BoundsString;
                class Bounds {
                }
                OSMap.Bounds = Bounds;
            })(OSMap = OSStructures.OSMap || (OSStructures.OSMap = {}));
        })(OSStructures = Maps.OSStructures || (Maps.OSStructures = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var OSStructures;
        (function (OSStructures) {
            var OSMap;
            (function (OSMap) {
                class Coordinates {
                }
                OSMap.Coordinates = Coordinates;
                class OSCoordinates {
                    constructor(lat, lng) {
                        this.Lat = lat;
                        this.Lng = lng;
                    }
                }
                OSMap.OSCoordinates = OSCoordinates;
            })(OSMap = OSStructures.OSMap || (OSStructures.OSMap = {}));
        })(OSStructures = Maps.OSStructures || (Maps.OSStructures = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var OSStructures;
        (function (OSStructures) {
            var Directions;
            (function (Directions) {
                class DirectionLegs {
                }
                Directions.DirectionLegs = DirectionLegs;
            })(Directions = OSStructures.Directions || (OSStructures.Directions = {}));
        })(OSStructures = Maps.OSStructures || (Maps.OSStructures = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var OSStructures;
        (function (OSStructures) {
            var OSMap;
            (function (OSMap) {
                class Offset {
                }
                OSMap.Offset = Offset;
                class Localization {
                }
                OSMap.Localization = Localization;
            })(OSMap = OSStructures.OSMap || (OSStructures.OSMap = {}));
        })(OSStructures = Maps.OSStructures || (Maps.OSStructures = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var OSStructures;
        (function (OSStructures) {
            class ReturnMessage {
            }
            OSStructures.ReturnMessage = ReturnMessage;
        })(OSStructures = Maps.OSStructures || (Maps.OSStructures = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var SearchPlaces;
        (function (SearchPlaces) {
            class AbstractSearchPlaces {
                constructor(uniqueId, config) {
                    this._uniqueId = uniqueId;
                    this._config = config;
                    this._built = false;
                    this._searchPlacesEvents = new Maps.Event.SearchPlaces.SearchPlacesEventsManager(this);
                }
                get config() {
                    return this._config;
                }
                get isReady() {
                    return this._built;
                }
                get provider() {
                    return this._provider;
                }
                get searchPlacesEvents() {
                    return this._searchPlacesEvents;
                }
                get uniqueId() {
                    return this._uniqueId;
                }
                get widgetId() {
                    if (this._widgetId === undefined || this._widgetId === '') {
                        this._setWidgetId();
                    }
                    return this._widgetId;
                }
                _setWidgetId() {
                    this._widgetId = Maps.Helper.GetElementByUniqueId(this.uniqueId, false)
                        ? Maps.Helper.GetElementByUniqueId(this.uniqueId).closest(this._searchPlacesTag).id
                        : undefined;
                }
                finishBuild() {
                    this._built = true;
                    this.searchPlacesEvents.trigger(Maps.Event.SearchPlaces.SearchPlacesEventType.Initialized, this);
                }
                build() {
                    if (this._built)
                        return;
                    this._setWidgetId();
                }
                changeProperty(propertyName, propertyValue) {
                    if (this.config.hasOwnProperty(propertyName)) {
                        this.config[propertyName] = propertyValue;
                    }
                    else {
                        this.searchPlacesEvents.trigger(Maps.Event.SearchPlaces.SearchPlacesEventType.OnError, this, Maps.Enum.ErrorCodes.GEN_InvalidChangePropertySearchPlaces, undefined, `${propertyName}`);
                    }
                }
                dispose() {
                    this._built = undefined;
                }
                equalsToID(id) {
                    return id === this._uniqueId || id === this.widgetId;
                }
                getProviderConfig() {
                    return this.config.getProviderConfig();
                }
            }
            SearchPlaces.AbstractSearchPlaces = AbstractSearchPlaces;
        })(SearchPlaces = Maps.SearchPlaces || (Maps.SearchPlaces = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Shape;
        (function (Shape) {
            class AbstractShape {
                constructor(map, uniqueId, type, config) {
                    this._map = map;
                    this._uniqueId = uniqueId;
                    this._config = config;
                    this._built = false;
                    this._shapeEvents = new Maps.Event.Shape.ShapeEventsManager(this);
                    this._type = type;
                    this._addedEvents = [];
                }
                get config() {
                    return this._config;
                }
                get isReady() {
                    return this._built;
                }
                get map() {
                    return this._map;
                }
                get minPath() {
                    return Maps.Enum.ShapeMinPath[this._type];
                }
                get provider() {
                    return this._provider;
                }
                get shapeEvents() {
                    return this._shapeEvents;
                }
                get type() {
                    return this._type;
                }
                get uniqueId() {
                    return this._uniqueId;
                }
                get widgetId() {
                    if (this._widgetId === undefined || this._widgetId === '') {
                        this._setWidgetId();
                    }
                    return this._widgetId;
                }
                _setWidgetId() {
                    this._widgetId = Maps.Helper.GetElementByUniqueId(this.uniqueId, false)
                        ? Maps.Helper.GetElementByUniqueId(this.uniqueId).closest(this.shapeTag).id
                        : undefined;
                }
                finishBuild() {
                    this._built = true;
                    this.shapeEvents.trigger(Maps.Event.Shape.ShapeEventType.Initialized);
                }
                triggerShapeChangedEvent() {
                    const shapeLocation = this.getShapeCoordinates();
                    this.shapeEvents.trigger(Maps.Event.Shape.ShapeEventType.ProviderEvent, Maps.Helper.Constants.shapeChangedEvent, shapeLocation);
                }
                build() {
                    if (this._built)
                        return;
                    this._setWidgetId();
                }
                changeProperty(propertyName, propertyValue) {
                    if (this.config.hasOwnProperty(propertyName)) {
                        this.config[propertyName] = propertyValue;
                    }
                    else {
                        this.map.mapEvents.trigger(Maps.Event.OSMap.MapEventType.OnError, this.map, Maps.Enum.ErrorCodes.GEN_InvalidChangePropertyShape, `${propertyName}`);
                    }
                }
                dispose() {
                    this._built = false;
                }
                equalsToID(id) {
                    return id === this._uniqueId || id === this.widgetId;
                }
                getProviderConfig() {
                    return this.config.getProviderConfig();
                }
                validateProviderEvent(eventName) {
                    return this.shapeProviderEvents.indexOf(eventName) !== -1;
                }
            }
            Shape.AbstractShape = AbstractShape;
        })(Shape = Maps.Shape || (Maps.Shape = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OSFramework;
(function (OSFramework) {
    var Maps;
    (function (Maps) {
        var Shape;
        (function (Shape) {
            let ShapeFactory;
            (function (ShapeFactory) {
                function MakeShape(map, shapeId, type, configs) {
                    switch (map.providerType) {
                        case Maps.Enum.ProviderType.Google:
                            return Provider.Maps.Google.Shape.ShapeFactory.MakeShape(map, shapeId, type, configs);
                        case Maps.Enum.ProviderType.Leaflet:
                            return Provider.Maps.Leaflet.Shape.ShapeFactory.MakeShape(map, shapeId, type, configs);
                        default:
                            throw new Error(`There is no factory for the Shape using the provider ${map.providerType}`);
                    }
                }
                ShapeFactory.MakeShape = MakeShape;
            })(ShapeFactory = Shape.ShapeFactory || (Shape.ShapeFactory = {}));
        })(Shape = Maps.Shape || (Maps.Shape = {}));
    })(Maps = OSFramework.Maps || (OSFramework.Maps = {}));
})(OSFramework || (OSFramework = {}));
var OutSystems;
(function (OutSystems) {
    var Maps;
    (function (Maps) {
        function GetVersion() {
            return OSFramework.Maps.Constants.OSMapsVersion;
        }
        Maps.GetVersion = GetVersion;
    })(Maps = OutSystems.Maps || (OutSystems.Maps = {}));
})(OutSystems || (OutSystems = {}));
var OutSystems;
(function (OutSystems) {
    var Maps;
    (function (Maps) {
        var MapAPI;
        (function (MapAPI) {
            var Auxiliary;
            (function (Auxiliary) {
                function GetHashCode(str) {
                    return OSFramework.Maps.Helper.GenerateHashCode(str);
                }
                Auxiliary.GetHashCode = GetHashCode;
            })(Auxiliary = MapAPI.Auxiliary || (MapAPI.Auxiliary = {}));
        })(MapAPI = Maps.MapAPI || (Maps.MapAPI = {}));
    })(Maps = OutSystems.Maps || (OutSystems.Maps = {}));
})(OutSystems || (OutSystems = {}));
var MapAPI;
(function (MapAPI) {
    var Auxiliary;
    (function (Auxiliary) {
        function GetHashCode(str) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.Auxiliary.GetHashCode()'`);
            return OutSystems.Maps.MapAPI.Auxiliary.GetHashCode(str);
        }
        Auxiliary.GetHashCode = GetHashCode;
    })(Auxiliary = MapAPI.Auxiliary || (MapAPI.Auxiliary = {}));
})(MapAPI || (MapAPI = {}));
var OutSystems;
(function (OutSystems) {
    var Maps;
    (function (Maps) {
        var MapAPI;
        (function (MapAPI) {
            var Directions;
            (function (Directions) {
                function GetLegsFromDirection(mapId) {
                    const map = OutSystems.Maps.MapAPI.MapManager.GetMapById(mapId, true);
                    return JSON.stringify(map.features.directions.getLegsFromDirection());
                }
                Directions.GetLegsFromDirection = GetLegsFromDirection;
                function GetTotalDistanceFromDirection(mapId) {
                    const map = MapAPI.MapManager.GetMapById(mapId, true);
                    return map.features.directions.getTotalDistanceFromDirection();
                }
                Directions.GetTotalDistanceFromDirection = GetTotalDistanceFromDirection;
                function GetTotalDurationFromDirection(mapId) {
                    const map = MapAPI.MapManager.GetMapById(mapId, true);
                    return map.features.directions.getTotalDurationFromDirection();
                }
                Directions.GetTotalDurationFromDirection = GetTotalDurationFromDirection;
                function LoadPlugin(mapId, providerName, apiKey) {
                    const map = MapAPI.MapManager.GetMapById(mapId, true);
                    const pluginResponse = map.features.directions.setPlugin(providerName, apiKey);
                    return JSON.stringify(pluginResponse);
                }
                Directions.LoadPlugin = LoadPlugin;
                async function SetDirections(mapId, options) {
                    const map = MapAPI.MapManager.GetMapById(mapId, true);
                    const directionOptions = JSON.parse(options);
                    return map.features.directions
                        .setRoute(directionOptions)
                        .then((result) => {
                        return JSON.stringify(result);
                    })
                        .catch((error) => {
                        return JSON.stringify(error);
                    });
                }
                Directions.SetDirections = SetDirections;
                function RemoveDirections(mapId) {
                    const map = MapAPI.MapManager.GetMapById(mapId, true);
                    return JSON.stringify(map.features.directions.removeRoute());
                }
                Directions.RemoveDirections = RemoveDirections;
            })(Directions = MapAPI.Directions || (MapAPI.Directions = {}));
        })(MapAPI = Maps.MapAPI || (Maps.MapAPI = {}));
    })(Maps = OutSystems.Maps || (OutSystems.Maps = {}));
})(OutSystems || (OutSystems = {}));
var MapAPI;
(function (MapAPI) {
    var Directions;
    (function (Directions) {
        function GetLegsFromDirection(mapId) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.Directions.GetLegsFromDirection()'`);
            return OutSystems.Maps.MapAPI.Directions.GetLegsFromDirection(mapId);
        }
        Directions.GetLegsFromDirection = GetLegsFromDirection;
        function GetTotalDistanceFromDirection(mapId) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.Directions.GetTotalDistanceFromDirection()'`);
            return OutSystems.Maps.MapAPI.Directions.GetTotalDistanceFromDirection(mapId);
        }
        Directions.GetTotalDistanceFromDirection = GetTotalDistanceFromDirection;
        function GetTotalDurationFromDirection(mapId) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.Directions.GetTotalDurationFromDirection()'`);
            return OutSystems.Maps.MapAPI.Directions.GetTotalDurationFromDirection(mapId);
        }
        Directions.GetTotalDurationFromDirection = GetTotalDurationFromDirection;
        function LoadPlugin(mapId, providerName, apiKey) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.Directions.LoadPlugin()'`);
            return OutSystems.Maps.MapAPI.Directions.LoadPlugin(mapId, providerName, apiKey);
        }
        Directions.LoadPlugin = LoadPlugin;
        function SetDirections(mapId, options) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.Directions.SetDirections()'`);
            return OutSystems.Maps.MapAPI.Directions.SetDirections(mapId, options);
        }
        Directions.SetDirections = SetDirections;
        function RemoveDirections(mapId) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.Directions.RemoveDirections()'`);
            return OutSystems.Maps.MapAPI.Directions.RemoveDirections(mapId);
        }
        Directions.RemoveDirections = RemoveDirections;
    })(Directions = MapAPI.Directions || (MapAPI.Directions = {}));
})(MapAPI || (MapAPI = {}));
var OutSystems;
(function (OutSystems) {
    var Maps;
    (function (Maps) {
        var MapAPI;
        (function (MapAPI) {
            var DrawingToolsManager;
            (function (DrawingToolsManager) {
                var Events;
                (function (Events) {
                    const _pendingEvents = new Map();
                    function CheckPendingEvents(drawingTools) {
                        for (const key of _pendingEvents.keys()) {
                            if (drawingTools.equalsToID(key)) {
                                _pendingEvents.get(key).forEach((obj) => {
                                    drawingTools.drawingToolsEvents.addHandler(obj.event, obj.cb, obj.uniqueId);
                                });
                                drawingTools.refreshProviderEvents();
                                _pendingEvents.delete(key);
                            }
                        }
                    }
                    Events.CheckPendingEvents = CheckPendingEvents;
                    function SubscribeByToolUniqueId(toolUniqueId, eventName, callback) {
                        const drawingToolsId = DrawingToolsManager.GetDrawingToolsByToolUniqueId(toolUniqueId);
                        const drawingTools = DrawingToolsManager.GetDrawingToolsById(drawingToolsId, false);
                        if (drawingTools === undefined) {
                            if (_pendingEvents.has(drawingToolsId)) {
                                _pendingEvents.get(drawingToolsId).push({
                                    event: eventName,
                                    cb: callback,
                                    uniqueId: toolUniqueId,
                                });
                            }
                            else {
                                _pendingEvents.set(drawingToolsId, [
                                    {
                                        event: eventName,
                                        cb: callback,
                                        uniqueId: toolUniqueId,
                                    },
                                ]);
                            }
                        }
                        else {
                            drawingTools.drawingToolsEvents.addHandler(eventName, callback, toolUniqueId);
                        }
                    }
                    Events.SubscribeByToolUniqueId = SubscribeByToolUniqueId;
                    function UnsubscribeByToolId(toolUniqueId, eventName, callback) {
                        const drawingToolsId = DrawingToolsManager.GetDrawingToolsByToolUniqueId(toolUniqueId);
                        const drawingTools = DrawingToolsManager.GetDrawingToolsById(drawingToolsId, false);
                        if (drawingTools !== undefined) {
                            drawingTools.drawingToolsEvents.removeHandler(eventName, callback);
                            drawingTools.refreshProviderEvents();
                        }
                        else {
                            if (_pendingEvents.has(drawingToolsId)) {
                                const index = _pendingEvents.get(drawingToolsId).findIndex((element) => {
                                    return element.event === eventName && element.cb === callback;
                                });
                                if (index !== -1) {
                                    _pendingEvents.get(drawingToolsId).splice(index, 1);
                                }
                            }
                        }
                    }
                    Events.UnsubscribeByToolId = UnsubscribeByToolId;
                })(Events = DrawingToolsManager.Events || (DrawingToolsManager.Events = {}));
            })(DrawingToolsManager = MapAPI.DrawingToolsManager || (MapAPI.DrawingToolsManager = {}));
        })(MapAPI = Maps.MapAPI || (Maps.MapAPI = {}));
    })(Maps = OutSystems.Maps || (OutSystems.Maps = {}));
})(OutSystems || (OutSystems = {}));
var MapAPI;
(function (MapAPI) {
    var DrawingToolsManager;
    (function (DrawingToolsManager) {
        var Events;
        (function (Events) {
            function CheckPendingEvents(drawingTools) {
                OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.DrawingToolsManager.Events.CheckPendingEvents()'`);
                OutSystems.Maps.MapAPI.DrawingToolsManager.Events.CheckPendingEvents(drawingTools);
            }
            Events.CheckPendingEvents = CheckPendingEvents;
            function SubscribeByToolUniqueId(toolUniqueId, eventName, callback) {
                OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.DrawingToolsManager.Events.SubscribeByToolUniqueId()'`);
                OutSystems.Maps.MapAPI.DrawingToolsManager.Events.SubscribeByToolUniqueId(toolUniqueId, eventName, callback);
            }
            Events.SubscribeByToolUniqueId = SubscribeByToolUniqueId;
            function UnsubscribeByToolId(toolUniqueId, eventName, callback) {
                OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.DrawingToolsManager.Events.UnsubscribeByToolId()'`);
                OutSystems.Maps.MapAPI.DrawingToolsManager.Events.UnsubscribeByToolId(toolUniqueId, eventName, callback);
            }
            Events.UnsubscribeByToolId = UnsubscribeByToolId;
        })(Events = DrawingToolsManager.Events || (DrawingToolsManager.Events = {}));
    })(DrawingToolsManager = MapAPI.DrawingToolsManager || (MapAPI.DrawingToolsManager = {}));
})(MapAPI || (MapAPI = {}));
var OutSystems;
(function (OutSystems) {
    var Maps;
    (function (Maps) {
        var MapAPI;
        (function (MapAPI) {
            var DrawingToolsManager;
            (function (DrawingToolsManager) {
                const drawingToolsMap = new Map();
                let drawingToolsElement = undefined;
                const _pendingTools = new Map();
                function CreateTool(drawingTools, toolId, type, configs) {
                    if (!drawingTools.hasTool(toolId) && !drawingTools.toolAlreadyExists(type)) {
                        const _tool = OSFramework.Maps.DrawingTools.DrawingToolsFactory.MakeTool(drawingTools.map, drawingTools, toolId, type, JSON.parse(configs));
                        drawingTools.addTool(_tool);
                        DrawingToolsManager.Events.CheckPendingEvents(drawingTools);
                        return _tool;
                    }
                    else {
                        OSFramework.Maps.Helper.ThrowError(drawingTools.map, OSFramework.Maps.Enum.ErrorCodes.GEN_ToolTypeAlreadyExists, type);
                    }
                }
                function GetMapByDrawingToolsId(drawingToolsId) {
                    let map;
                    if (drawingToolsMap.has(drawingToolsId)) {
                        map = MapAPI.MapManager.GetMapById(drawingToolsMap.get(drawingToolsId), false);
                    }
                    else {
                        const elem = OSFramework.Maps.Helper.GetElementByUniqueId(drawingToolsId, false);
                        if (elem !== undefined) {
                            const mapId = OSFramework.Maps.Helper.GetClosestMapId(elem);
                            map = OutSystems.Maps.MapAPI.MapManager.GetMapById(mapId);
                        }
                    }
                    return map;
                }
                function AddTool(toolId, type, configs) {
                    const drawingToolsId = GetDrawingToolsByToolUniqueId(toolId);
                    const drawingTools = GetDrawingToolsById(drawingToolsId, false);
                    if (drawingTools !== undefined) {
                        return CreateTool(drawingTools, toolId, type, configs);
                    }
                    else {
                        if (_pendingTools.has(drawingToolsId)) {
                            _pendingTools.get(drawingToolsId).push({ toolId, type, configs });
                        }
                        else {
                            _pendingTools.set(drawingToolsId, [{ toolId, type, configs }]);
                        }
                    }
                }
                DrawingToolsManager.AddTool = AddTool;
                function ChangeProperty(drawingToolsId, propertyName, propertyValue) {
                    const drawingTools = GetDrawingToolsById(drawingToolsId);
                    const map = drawingTools.map;
                    if (map !== undefined) {
                        map.changeDrawingToolsProperty(drawingToolsId, propertyName, propertyValue);
                    }
                }
                DrawingToolsManager.ChangeProperty = ChangeProperty;
                function ChangeToolProperty(toolId, propertyName, propertyValue) {
                    const drawingToolsId = GetDrawingToolsByToolUniqueId(toolId);
                    const drawingTools = GetDrawingToolsById(drawingToolsId, false);
                    if (drawingTools !== undefined) {
                        drawingTools.changeToolProperty(toolId, propertyName, propertyValue);
                    }
                }
                DrawingToolsManager.ChangeToolProperty = ChangeToolProperty;
                function CheckPendingTools(drawingTools) {
                    for (const key of _pendingTools.keys()) {
                        if (drawingTools.equalsToID(key)) {
                            _pendingTools.get(key).forEach((tool) => {
                                CreateTool(drawingTools, tool.toolId, tool.type, tool.configs);
                            });
                            drawingTools.refreshProviderEvents();
                            _pendingTools.delete(key);
                        }
                    }
                }
                DrawingToolsManager.CheckPendingTools = CheckPendingTools;
                function CreateDrawingTools(drawingToolsId, configs) {
                    const map = GetMapByDrawingToolsId(drawingToolsId);
                    if (OSFramework.Maps.Helper.ValidateFeatureProvider(map, OSFramework.Maps.Enum.Feature.DrawingTools) === false) {
                        return;
                    }
                    if (!map.drawingTools) {
                        const _drawingTools = OSFramework.Maps.DrawingTools.DrawingToolsFactory.MakeDrawingTools(map, drawingToolsId, JSON.parse(configs));
                        drawingToolsElement = _drawingTools;
                        drawingToolsMap.set(drawingToolsId, map.uniqueId);
                        map.addDrawingTools(_drawingTools);
                        CheckPendingTools(_drawingTools);
                        return _drawingTools;
                    }
                    else {
                        console.error(`There is already a DrawingTools registered on the specified Map under id:${drawingToolsId}`);
                    }
                }
                DrawingToolsManager.CreateDrawingTools = CreateDrawingTools;
                function GetDrawingToolsById(drawingToolsId, raiseError = true) {
                    const drawingTools = drawingToolsElement && drawingToolsElement.equalsToID(drawingToolsId) ? drawingToolsElement : undefined;
                    if (drawingTools === undefined && raiseError) {
                        throw new Error(`DrawingTools id:${drawingToolsId} not found`);
                    }
                    return drawingTools;
                }
                DrawingToolsManager.GetDrawingToolsById = GetDrawingToolsById;
                function GetDrawingToolsByToolUniqueId(toolUniqueId) {
                    const toolElement = OSFramework.Maps.Helper.GetElementByUniqueId(toolUniqueId);
                    return OSFramework.Maps.Helper.GetClosestDrawingToolsId(toolElement);
                }
                DrawingToolsManager.GetDrawingToolsByToolUniqueId = GetDrawingToolsByToolUniqueId;
                function RemoveDrawingTools(drawingToolsId) {
                    const drawingTools = GetDrawingToolsById(drawingToolsId, false);
                    if (drawingTools !== undefined) {
                        const map = drawingTools.map;
                        map && map.removeDrawingTools(drawingToolsId);
                        drawingToolsMap.delete(drawingToolsId);
                        drawingToolsElement = undefined;
                    }
                }
                DrawingToolsManager.RemoveDrawingTools = RemoveDrawingTools;
                function RemoveTool(toolId) {
                    const drawingToolsId = GetDrawingToolsByToolUniqueId(toolId);
                    const drawingTools = GetDrawingToolsById(drawingToolsId, false);
                    drawingTools && drawingTools.removeTool(toolId);
                }
                DrawingToolsManager.RemoveTool = RemoveTool;
            })(DrawingToolsManager = MapAPI.DrawingToolsManager || (MapAPI.DrawingToolsManager = {}));
        })(MapAPI = Maps.MapAPI || (Maps.MapAPI = {}));
    })(Maps = OutSystems.Maps || (OutSystems.Maps = {}));
})(OutSystems || (OutSystems = {}));
var MapAPI;
(function (MapAPI) {
    var DrawingToolsManager;
    (function (DrawingToolsManager) {
        function AddTool(toolId, type, configs) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.DrawingToolsManager.AddTool()'`);
            return OutSystems.Maps.MapAPI.DrawingToolsManager.AddTool(toolId, type, configs);
        }
        DrawingToolsManager.AddTool = AddTool;
        function ChangeProperty(drawingToolsId, propertyName, propertyValue) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.DrawingToolsManager.ChangeProperty()'`);
            OutSystems.Maps.MapAPI.DrawingToolsManager.ChangeProperty(drawingToolsId, propertyName, propertyValue);
        }
        DrawingToolsManager.ChangeProperty = ChangeProperty;
        function ChangeToolProperty(toolId, propertyName, propertyValue) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.DrawingToolsManager.ChangeToolProperty()'`);
            OutSystems.Maps.MapAPI.DrawingToolsManager.ChangeToolProperty(toolId, propertyName, propertyValue);
        }
        DrawingToolsManager.ChangeToolProperty = ChangeToolProperty;
        function CheckPendingTools(drawingTools) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.DrawingToolsManager.CheckPendingTools()'`);
            OutSystems.Maps.MapAPI.DrawingToolsManager.CheckPendingTools(drawingTools);
        }
        DrawingToolsManager.CheckPendingTools = CheckPendingTools;
        function CreateDrawingTools(drawingToolsId, configs) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.DrawingToolsManager.CreateDrawingTools()'`);
            return OutSystems.Maps.MapAPI.DrawingToolsManager.CreateDrawingTools(drawingToolsId, configs);
        }
        DrawingToolsManager.CreateDrawingTools = CreateDrawingTools;
        function GetDrawingToolsById(drawingToolsId, raiseError = true) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.DrawingToolsManager.GetDrawingToolsById()'`);
            return OutSystems.Maps.MapAPI.DrawingToolsManager.GetDrawingToolsById(drawingToolsId, raiseError);
        }
        DrawingToolsManager.GetDrawingToolsById = GetDrawingToolsById;
        function GetDrawingToolsByToolUniqueId(toolUniqueId) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.DrawingToolsManager.GetDrawingToolsByToolUniqueId()'`);
            return OutSystems.Maps.MapAPI.DrawingToolsManager.GetDrawingToolsByToolUniqueId(toolUniqueId);
        }
        DrawingToolsManager.GetDrawingToolsByToolUniqueId = GetDrawingToolsByToolUniqueId;
        function RemoveDrawingTools(drawingToolsId) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.DrawingToolsManager.RemoveDrawingTools()'`);
            OutSystems.Maps.MapAPI.DrawingToolsManager.RemoveDrawingTools(drawingToolsId);
        }
        DrawingToolsManager.RemoveDrawingTools = RemoveDrawingTools;
        function RemoveTool(toolId) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.DrawingToolsManager.RemoveTool()'`);
            OutSystems.Maps.MapAPI.DrawingToolsManager.RemoveTool(toolId);
        }
        DrawingToolsManager.RemoveTool = RemoveTool;
    })(DrawingToolsManager = MapAPI.DrawingToolsManager || (MapAPI.DrawingToolsManager = {}));
})(MapAPI || (MapAPI = {}));
var OutSystems;
(function (OutSystems) {
    var Maps;
    (function (Maps) {
        var MapAPI;
        (function (MapAPI) {
            var FileLayerManager;
            (function (FileLayerManager) {
                var Events;
                (function (Events) {
                    const _pendingEvents = new Map();
                    function CheckPendingEvents(fileLayer) {
                        for (const key of _pendingEvents.keys()) {
                            if (fileLayer.equalsToID(key)) {
                                _pendingEvents.get(key).forEach((obj) => {
                                    fileLayer.fileLayerEvents.addHandler(obj.event, obj.cb, obj.uniqueId);
                                });
                                fileLayer.refreshProviderEvents();
                                _pendingEvents.delete(key);
                            }
                        }
                    }
                    Events.CheckPendingEvents = CheckPendingEvents;
                    function Subscribe(fileLayerId, eventName, callback) {
                        const fileLayer = FileLayerManager.GetFileLayerById(fileLayerId, false);
                        if (fileLayer === undefined) {
                            if (_pendingEvents.has(fileLayerId)) {
                                _pendingEvents.get(fileLayerId).push({
                                    event: eventName,
                                    cb: callback,
                                    uniqueId: fileLayerId,
                                });
                            }
                            else {
                                _pendingEvents.set(fileLayerId, [
                                    {
                                        event: eventName,
                                        cb: callback,
                                        uniqueId: fileLayerId,
                                    },
                                ]);
                            }
                        }
                        else {
                            fileLayer.fileLayerEvents.addHandler(eventName, callback, fileLayerId);
                            fileLayer.refreshProviderEvents();
                        }
                    }
                    Events.Subscribe = Subscribe;
                    function Unsubscribe(fileLayerId, eventName, callback) {
                        const fileLayer = FileLayerManager.GetFileLayerById(fileLayerId, false);
                        if (fileLayer !== undefined) {
                            fileLayer.fileLayerEvents.removeHandler(eventName, callback);
                            fileLayer.refreshProviderEvents();
                        }
                        else {
                            if (_pendingEvents.has(fileLayerId)) {
                                const index = _pendingEvents.get(fileLayerId).findIndex((element) => {
                                    return element.event === eventName && element.cb === callback;
                                });
                                if (index !== -1) {
                                    _pendingEvents.get(fileLayerId).splice(index, 1);
                                }
                            }
                        }
                    }
                    Events.Unsubscribe = Unsubscribe;
                })(Events = FileLayerManager.Events || (FileLayerManager.Events = {}));
            })(FileLayerManager = MapAPI.FileLayerManager || (MapAPI.FileLayerManager = {}));
        })(MapAPI = Maps.MapAPI || (Maps.MapAPI = {}));
    })(Maps = OutSystems.Maps || (OutSystems.Maps = {}));
})(OutSystems || (OutSystems = {}));
var MapAPI;
(function (MapAPI) {
    var FileLayerManager;
    (function (FileLayerManager) {
        var Events;
        (function (Events) {
            function CheckPendingEvents(fileLayer) {
                OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.FileLayerManager.Events.CheckPendingEvents()'`);
                OutSystems.Maps.MapAPI.FileLayerManager.Events.CheckPendingEvents(fileLayer);
            }
            Events.CheckPendingEvents = CheckPendingEvents;
            function Subscribe(fileLayerId, eventName, callback) {
                OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.FileLayerManager.Events.Subscribe()'`);
                OutSystems.Maps.MapAPI.FileLayerManager.Events.Subscribe(fileLayerId, eventName, callback);
            }
            Events.Subscribe = Subscribe;
            function Unsubscribe(fileLayerId, eventName, callback) {
                OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.FileLayerManager.Events.Unsubscribe()'`);
                OutSystems.Maps.MapAPI.FileLayerManager.Events.Unsubscribe(fileLayerId, eventName, callback);
            }
            Events.Unsubscribe = Unsubscribe;
        })(Events = FileLayerManager.Events || (FileLayerManager.Events = {}));
    })(FileLayerManager = MapAPI.FileLayerManager || (MapAPI.FileLayerManager = {}));
})(MapAPI || (MapAPI = {}));
var OutSystems;
(function (OutSystems) {
    var Maps;
    (function (Maps) {
        var MapAPI;
        (function (MapAPI) {
            var FileLayerManager;
            (function (FileLayerManager) {
                const fileLayerMap = new Map();
                const fileLayerArr = new Array();
                function GetMapByFileLayerId(fileLayerId) {
                    let map;
                    if (fileLayerMap.has(fileLayerId)) {
                        map = MapAPI.MapManager.GetMapById(fileLayerMap.get(fileLayerId), false);
                    }
                    else {
                        const elem = OSFramework.Maps.Helper.GetElementByUniqueId(fileLayerId, false);
                        if (elem !== undefined) {
                            const mapId = OSFramework.Maps.Helper.GetClosestMapId(elem);
                            map = MapAPI.MapManager.GetMapById(mapId);
                        }
                    }
                    return map;
                }
                function ChangeProperty(fileLayerId, propertyName, propertyValue) {
                    const fileLayer = GetFileLayerById(fileLayerId);
                    const map = fileLayer.map;
                    if (map !== undefined) {
                        map.changeFileLayerProperty(fileLayerId, propertyName, propertyValue);
                    }
                }
                FileLayerManager.ChangeProperty = ChangeProperty;
                function CreateFileLayer(fileLayerId, configs) {
                    const map = GetMapByFileLayerId(fileLayerId);
                    if (OSFramework.Maps.Helper.ValidateFeatureProvider(map, OSFramework.Maps.Enum.Feature.FileLayer) === false) {
                        return;
                    }
                    if (!map.hasFileLayer(fileLayerId)) {
                        const _fileLayer = Provider.Maps.Google.FileLayer.FileLayerFactory.MakeFileLayer(map, fileLayerId, JSON.parse(configs));
                        fileLayerArr.push(_fileLayer);
                        fileLayerMap.set(fileLayerId, map.uniqueId);
                        map.addFileLayer(_fileLayer);
                        return _fileLayer;
                    }
                    else {
                        console.error(`There is already a FileLayer registered on the specified Map under id:${fileLayerId}`);
                    }
                }
                FileLayerManager.CreateFileLayer = CreateFileLayer;
                function GetFileLayerById(fileLayerId, raiseError = true) {
                    const fileLayer = fileLayerArr.find((p) => p && p.equalsToID(fileLayerId));
                    if (fileLayer === undefined && raiseError) {
                        throw new Error(`FileLayer id:${fileLayerId} not found`);
                    }
                    return fileLayer;
                }
                FileLayerManager.GetFileLayerById = GetFileLayerById;
                function RemoveFileLayer(fileLayerId) {
                    const fileLayer = GetFileLayerById(fileLayerId);
                    const map = fileLayer.map;
                    map && map.removeFileLayer(fileLayerId);
                    fileLayerMap.delete(fileLayerId);
                    fileLayerArr.splice(fileLayerArr.findIndex((p) => {
                        return p && p.equalsToID(fileLayerId);
                    }), 1);
                }
                FileLayerManager.RemoveFileLayer = RemoveFileLayer;
            })(FileLayerManager = MapAPI.FileLayerManager || (MapAPI.FileLayerManager = {}));
        })(MapAPI = Maps.MapAPI || (Maps.MapAPI = {}));
    })(Maps = OutSystems.Maps || (OutSystems.Maps = {}));
})(OutSystems || (OutSystems = {}));
var MapAPI;
(function (MapAPI) {
    var FileLayerManager;
    (function (FileLayerManager) {
        function ChangeProperty(fileLayerId, propertyName, propertyValue) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.FileLayerManager.ChangeProperty()'`);
            OutSystems.Maps.MapAPI.FileLayerManager.ChangeProperty(fileLayerId, propertyName, propertyValue);
        }
        FileLayerManager.ChangeProperty = ChangeProperty;
        function CreateFileLayer(fileLayerId, configs) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.FileLayerManager.CreateFileLayer()'`);
            return OutSystems.Maps.MapAPI.FileLayerManager.CreateFileLayer(fileLayerId, configs);
        }
        FileLayerManager.CreateFileLayer = CreateFileLayer;
        function GetFileLayerById(fileLayerId, raiseError = true) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.FileLayerManager.GetFileLayerById()'`);
            return OutSystems.Maps.MapAPI.FileLayerManager.GetFileLayerById(fileLayerId, raiseError);
        }
        FileLayerManager.GetFileLayerById = GetFileLayerById;
        function RemoveFileLayer(fileLayerId) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.FileLayerManager.RemoveFileLayer()'`);
            return OutSystems.Maps.MapAPI.FileLayerManager.RemoveFileLayer(fileLayerId);
        }
        FileLayerManager.RemoveFileLayer = RemoveFileLayer;
    })(FileLayerManager = MapAPI.FileLayerManager || (MapAPI.FileLayerManager = {}));
})(MapAPI || (MapAPI = {}));
var OutSystems;
(function (OutSystems) {
    var Maps;
    (function (Maps) {
        var MapAPI;
        (function (MapAPI) {
            var HeatmapLayerManager;
            (function (HeatmapLayerManager) {
                const heatmapLayerMap = new Map();
                const heatmapLayerArr = new Array();
                function GetMapByHeatmapLayerId(heatmapLayerId) {
                    let map;
                    if (heatmapLayerMap.has(heatmapLayerId)) {
                        map = MapAPI.MapManager.GetMapById(heatmapLayerMap.get(heatmapLayerId), false);
                    }
                    else {
                        const elem = OSFramework.Maps.Helper.GetElementByUniqueId(heatmapLayerId, false);
                        if (elem !== undefined) {
                            const mapId = OSFramework.Maps.Helper.GetClosestMapId(elem);
                            map = MapAPI.MapManager.GetMapById(mapId);
                        }
                    }
                    return map;
                }
                function ChangeProperty(heatmapLayerId, propertyName, propertyValue) {
                    const heatmapLayer = GetHeatmapLayerById(heatmapLayerId);
                    const map = heatmapLayer.map;
                    if (map !== undefined) {
                        map.changeHeatmapLayerProperty(heatmapLayerId, propertyName, propertyValue);
                    }
                }
                HeatmapLayerManager.ChangeProperty = ChangeProperty;
                function CreateHeatmapLayer(heatmapLayerId, configs) {
                    const map = GetMapByHeatmapLayerId(heatmapLayerId);
                    if (OSFramework.Maps.Helper.ValidateFeatureProvider(map, OSFramework.Maps.Enum.Feature.HeatmapLayer) === false) {
                        return;
                    }
                    if (!map.hasHeatmapLayer(heatmapLayerId)) {
                        const _heatmapLayer = Provider.Maps.Google.HeatmapLayer.HeatmapLayerFactory.MakeHeatmapLayer(map, heatmapLayerId, JSON.parse(configs));
                        heatmapLayerArr.push(_heatmapLayer);
                        heatmapLayerMap.set(heatmapLayerId, map.uniqueId);
                        map.addHeatmapLayer(_heatmapLayer);
                        return _heatmapLayer;
                    }
                    else {
                        console.error(`There is already a HeatmapLayer registered on the specified Map under id:${heatmapLayerId}`);
                    }
                }
                HeatmapLayerManager.CreateHeatmapLayer = CreateHeatmapLayer;
                function GetHeatmapLayerById(heatmapLayerId, raiseError = true) {
                    const heatmapLayer = heatmapLayerArr.find((p) => p && p.equalsToID(heatmapLayerId));
                    if (heatmapLayer === undefined && raiseError) {
                        throw new Error(`Marker id:${heatmapLayerId} not found`);
                    }
                    return heatmapLayer;
                }
                HeatmapLayerManager.GetHeatmapLayerById = GetHeatmapLayerById;
                function RemoveHeatmapLayer(heatmapLayerId) {
                    const heatmapLayer = GetHeatmapLayerById(heatmapLayerId);
                    const map = heatmapLayer.map;
                    map && map.removeHeatmapLayer(heatmapLayerId);
                    heatmapLayerMap.delete(heatmapLayerId);
                    heatmapLayerArr.splice(heatmapLayerArr.findIndex((p) => {
                        return p && p.equalsToID(heatmapLayerId);
                    }), 1);
                }
                HeatmapLayerManager.RemoveHeatmapLayer = RemoveHeatmapLayer;
            })(HeatmapLayerManager = MapAPI.HeatmapLayerManager || (MapAPI.HeatmapLayerManager = {}));
        })(MapAPI = Maps.MapAPI || (Maps.MapAPI = {}));
    })(Maps = OutSystems.Maps || (OutSystems.Maps = {}));
})(OutSystems || (OutSystems = {}));
var MapAPI;
(function (MapAPI) {
    var HeatmapLayerManager;
    (function (HeatmapLayerManager) {
        function ChangeProperty(heatmapLayerId, propertyName, propertyValue) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.HeatmapLayerManager.ChangeProperty()'`);
            OutSystems.Maps.MapAPI.HeatmapLayerManager.ChangeProperty(heatmapLayerId, propertyName, propertyValue);
        }
        HeatmapLayerManager.ChangeProperty = ChangeProperty;
        function CreateHeatmapLayer(heatmapLayerId, configs) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.HeatmapLayerManager.CreateHeatmapLayer()'`);
            return OutSystems.Maps.MapAPI.HeatmapLayerManager.CreateHeatmapLayer(heatmapLayerId, configs);
        }
        HeatmapLayerManager.CreateHeatmapLayer = CreateHeatmapLayer;
        function GetHeatmapLayerById(heatmapLayerId, raiseError = true) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.HeatmapLayerManager.GetHeatmapLayerById()'`);
            return OutSystems.Maps.MapAPI.HeatmapLayerManager.GetHeatmapLayerById(heatmapLayerId, raiseError);
        }
        HeatmapLayerManager.GetHeatmapLayerById = GetHeatmapLayerById;
        function RemoveHeatmapLayer(heatmapLayerId) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.HeatmapLayerManager.RemoveHeatmapLayer()'`);
            OutSystems.Maps.MapAPI.HeatmapLayerManager.RemoveHeatmapLayer(heatmapLayerId);
        }
        HeatmapLayerManager.RemoveHeatmapLayer = RemoveHeatmapLayer;
    })(HeatmapLayerManager = MapAPI.HeatmapLayerManager || (MapAPI.HeatmapLayerManager = {}));
})(MapAPI || (MapAPI = {}));
var OutSystems;
(function (OutSystems) {
    var Maps;
    (function (Maps) {
        var MapAPI;
        (function (MapAPI) {
            var ProviderLibrary;
            (function (ProviderLibrary) {
                function GetVersion(provider) {
                    return OSFramework.Maps.ProviderVersion.Get(provider);
                }
                ProviderLibrary.GetVersion = GetVersion;
                function SetVersion(provider, version, forceRefresh = false) {
                    OSFramework.Maps.ProviderVersion.Change(provider, version, forceRefresh);
                }
                ProviderLibrary.SetVersion = SetVersion;
            })(ProviderLibrary = MapAPI.ProviderLibrary || (MapAPI.ProviderLibrary = {}));
        })(MapAPI = Maps.MapAPI || (Maps.MapAPI = {}));
    })(Maps = OutSystems.Maps || (OutSystems.Maps = {}));
})(OutSystems || (OutSystems = {}));
var OutSystems;
(function (OutSystems) {
    var Maps;
    (function (Maps) {
        var MapAPI;
        (function (MapAPI) {
            var MapManager;
            (function (MapManager) {
                var Events;
                (function (Events) {
                    const _pendingEvents = new Map();
                    const _eventsToMapId = new Map();
                    function CheckPendingEvents(map) {
                        for (const key of _pendingEvents.keys()) {
                            if (map.equalsToID(key)) {
                                _pendingEvents.get(key).forEach((obj) => {
                                    map.mapEvents.addHandler(obj.event, obj.cb, obj.uniqueId);
                                });
                                _pendingEvents.delete(key);
                            }
                        }
                    }
                    Events.CheckPendingEvents = CheckPendingEvents;
                    function GetMapByEventUniqueId(eventUniqueId, lookUpDOM = true) {
                        if (lookUpDOM && !_eventsToMapId.has(eventUniqueId)) {
                            const eventElement = OSFramework.Maps.Helper.GetElementByUniqueId(eventUniqueId);
                            const mapId = OSFramework.Maps.Helper.GetClosestMapId(eventElement);
                            const map = MapManager.GetMapById(mapId);
                            if (map) {
                                _eventsToMapId.set(eventUniqueId, mapId);
                            }
                        }
                        return _eventsToMapId.get(eventUniqueId);
                    }
                    Events.GetMapByEventUniqueId = GetMapByEventUniqueId;
                    function Subscribe(mapId, eventName, callback) {
                        const map = MapManager.GetMapById(mapId, false);
                        if (map === undefined) {
                            if (_pendingEvents.has(mapId)) {
                                _pendingEvents.get(mapId).push({
                                    event: eventName,
                                    cb: callback,
                                    uniqueId: mapId,
                                });
                            }
                            else {
                                _pendingEvents.set(mapId, [
                                    {
                                        event: eventName,
                                        cb: callback,
                                        uniqueId: mapId,
                                    },
                                ]);
                            }
                        }
                        else {
                            map.mapEvents.addHandler(eventName, callback);
                        }
                    }
                    Events.Subscribe = Subscribe;
                    function SubscribeByUniqueId(eventUniqueId, eventName, callback) {
                        const mapId = GetMapByEventUniqueId(eventUniqueId);
                        const map = MapManager.GetMapById(mapId, false);
                        if (map === undefined) {
                            if (_pendingEvents.has(mapId)) {
                                _pendingEvents.get(mapId).push({
                                    event: eventName,
                                    cb: callback,
                                    uniqueId: eventUniqueId,
                                });
                            }
                            else {
                                _pendingEvents.set(mapId, [
                                    {
                                        event: eventName,
                                        cb: callback,
                                        uniqueId: eventUniqueId,
                                    },
                                ]);
                            }
                        }
                        else {
                            map.mapEvents.addHandler(eventName, callback, eventUniqueId);
                            map.refreshProviderEvents();
                        }
                    }
                    Events.SubscribeByUniqueId = SubscribeByUniqueId;
                    function Unsubscribe(eventUniqueId, eventName, callback) {
                        const mapId = GetMapByEventUniqueId(eventUniqueId);
                        const map = MapManager.GetMapById(mapId, false);
                        if (map !== undefined) {
                            map.mapEvents.removeHandler(eventName, callback);
                            map.refreshProviderEvents();
                        }
                        else {
                            if (_pendingEvents.has(mapId)) {
                                const index = _pendingEvents.get(mapId).findIndex((element) => {
                                    return element.event === eventName && element.cb === callback;
                                });
                                if (index !== -1) {
                                    _pendingEvents.get(mapId).splice(index, 1);
                                }
                            }
                        }
                    }
                    Events.Unsubscribe = Unsubscribe;
                })(Events = MapManager.Events || (MapManager.Events = {}));
            })(MapManager = MapAPI.MapManager || (MapAPI.MapManager = {}));
        })(MapAPI = Maps.MapAPI || (Maps.MapAPI = {}));
    })(Maps = OutSystems.Maps || (OutSystems.Maps = {}));
})(OutSystems || (OutSystems = {}));
var MapAPI;
(function (MapAPI) {
    var MapManager;
    (function (MapManager) {
        var Events;
        (function (Events) {
            function CheckPendingEvents(map) {
                OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MapManager.Events.CheckPendingEvents()'`);
                OutSystems.Maps.MapAPI.MapManager.Events.CheckPendingEvents(map);
            }
            Events.CheckPendingEvents = CheckPendingEvents;
            function GetMapByEventUniqueId(eventUniqueId, lookUpDOM = true) {
                OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MapManager.Events.GetMapByEventUniqueId()'`);
                return OutSystems.Maps.MapAPI.MapManager.Events.GetMapByEventUniqueId(eventUniqueId, lookUpDOM);
            }
            Events.GetMapByEventUniqueId = GetMapByEventUniqueId;
            function Subscribe(mapId, eventName, callback) {
                OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MapManager.Events.Subscribe()'`);
                OutSystems.Maps.MapAPI.MapManager.Events.Subscribe(mapId, eventName, callback);
            }
            Events.Subscribe = Subscribe;
            function SubscribeByUniqueId(uniqueId, eventName, callback) {
                OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MapManager.Events.SubscribeByUniqueId()'`);
                OutSystems.Maps.MapAPI.MapManager.Events.SubscribeByUniqueId(uniqueId, eventName, callback);
            }
            Events.SubscribeByUniqueId = SubscribeByUniqueId;
            function Unsubscribe(eventUniqueId, eventName, callback) {
                OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MapManager.Events.Unsubscribe()'`);
                OutSystems.Maps.MapAPI.MapManager.Events.Unsubscribe(eventUniqueId, eventName, callback);
            }
            Events.Unsubscribe = Unsubscribe;
        })(Events = MapManager.Events || (MapManager.Events = {}));
    })(MapManager = MapAPI.MapManager || (MapAPI.MapManager = {}));
})(MapAPI || (MapAPI = {}));
var OutSystems;
(function (OutSystems) {
    var Maps;
    (function (Maps) {
        var MapAPI;
        (function (MapAPI) {
            var MapManager;
            (function (MapManager) {
                const maps = new Map();
                let activeMap = undefined;
                function ChangeProperty(mapId, propertyName, propertyValue) {
                    const map = GetMapById(mapId);
                    map.changeProperty(propertyName, propertyValue);
                }
                MapManager.ChangeProperty = ChangeProperty;
                function CreateMap(mapId, provider, providerType, configs) {
                    const _map = OSFramework.Maps.OSMap.MapFactory.MakeMap(provider, providerType, mapId, JSON.parse(configs));
                    if (maps.has(mapId)) {
                        throw new Error(`There is already a Map registered under id:${mapId}`);
                    }
                    maps.set(mapId, _map);
                    activeMap = _map;
                    MapManager.Events.CheckPendingEvents(_map);
                    return _map;
                }
                MapManager.CreateMap = CreateMap;
                function GetActiveMap() {
                    return activeMap;
                }
                MapManager.GetActiveMap = GetActiveMap;
                function GetAllMarkers(mapId) {
                    const map = GetMapById(mapId);
                    return map.markers;
                }
                MapManager.GetAllMarkers = GetAllMarkers;
                function GetMapById(mapId, raiseError = true) {
                    let map;
                    if (maps.has(mapId)) {
                        map = maps.get(mapId);
                    }
                    else {
                        const mapFiltered = Array.from(maps.values()).filter((p) => p.equalsToID(mapId));
                        if (mapFiltered.length > 0) {
                            map = mapFiltered[mapFiltered.length - 1];
                        }
                    }
                    if (map === undefined && raiseError) {
                        throw new Error(`Map id:${mapId} not found`);
                    }
                    return map;
                }
                MapManager.GetMapById = GetMapById;
                function GetMapCenter(mapId) {
                    const map = MapManager.GetMapById(mapId, true);
                    const getMapCenterResponse = map.features.center.getMapCenter();
                    return JSON.stringify(getMapCenterResponse);
                }
                MapManager.GetMapCenter = GetMapCenter;
                function GetMapsFromPage() {
                    return maps;
                }
                MapManager.GetMapsFromPage = GetMapsFromPage;
                function InitializeMap(mapId) {
                    const map = GetMapById(mapId);
                    map.build();
                    MapManager.Events.CheckPendingEvents(map);
                }
                MapManager.InitializeMap = InitializeMap;
                function RemoveMap(mapId) {
                    const map = GetMapById(mapId);
                    maps.delete(map.uniqueId);
                    if (activeMap.uniqueId === map.uniqueId) {
                        activeMap = Array.from(maps.values()).pop();
                    }
                    map.dispose();
                    MapAPI.MarkerManager.RemoveAllMarkersCreatedByAPI(mapId, false);
                }
                MapManager.RemoveMap = RemoveMap;
                function RemoveMarkers(mapId) {
                    const map = GetMapById(mapId);
                    map.removeAllMarkers();
                }
                MapManager.RemoveMarkers = RemoveMarkers;
                function RemoveFileLayers(mapId) {
                    const map = GetMapById(mapId);
                    map.removeAllFileLayers();
                }
                MapManager.RemoveFileLayers = RemoveFileLayers;
                function SetHeight(mapId, height) {
                    const map = GetMapById(mapId);
                    let widgetId = map.widgetId;
                    if (widgetId === undefined) {
                        widgetId = OSFramework.Maps.Helper.GetElementByUniqueId(mapId).closest(map.mapTag).id;
                    }
                    const widget = OSFramework.Maps.Helper.GetElementByWidgetId(widgetId);
                    if (widget) {
                        if (height === '') {
                            let parentHeight = 0;
                            let currParent = widget.parentNode;
                            do {
                                parentHeight = currParent.offsetHeight;
                                currParent = currParent.parentNode;
                            } while (parentHeight <= 200 && currParent !== document.body);
                            height = parentHeight + 'px';
                        }
                        else {
                            if (isNaN(Number(height)) === false) {
                                height = height + 'px';
                            }
                        }
                        widget.style.setProperty('--map-height', height);
                        map.updateHeight();
                    }
                    else {
                        throw new Error(`Map id:${mapId} not found`);
                    }
                }
                MapManager.SetHeight = SetHeight;
                function SetClusterRenderer(mapId, renderer) {
                    const map = GetMapById(mapId);
                    if (map.providerType === OSFramework.Maps.Enum.ProviderType.Google) {
                        map.setClusterRenderer(renderer);
                    }
                    else {
                        throw new Error(`Map id:${mapId} is not an instance of Google Map. This API is only available to for Google Maps.`);
                    }
                }
                MapManager.SetClusterRenderer = SetClusterRenderer;
            })(MapManager = MapAPI.MapManager || (MapAPI.MapManager = {}));
        })(MapAPI = Maps.MapAPI || (Maps.MapAPI = {}));
    })(Maps = OutSystems.Maps || (OutSystems.Maps = {}));
})(OutSystems || (OutSystems = {}));
var MapAPI;
(function (MapAPI) {
    var MapManager;
    (function (MapManager) {
        function ChangeProperty(mapId, propertyName, propertyValue) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MapManager.ChangeProperty()'`);
            OutSystems.Maps.MapAPI.MapManager.ChangeProperty(mapId, propertyName, propertyValue);
        }
        MapManager.ChangeProperty = ChangeProperty;
        function CreateMap(mapId, provider, providerType, configs) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MapManager.CreateMap()'`);
            return OutSystems.Maps.MapAPI.MapManager.CreateMap(mapId, provider, providerType, configs);
        }
        MapManager.CreateMap = CreateMap;
        function GetActiveMap() {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MapManager.GetActiveMap()'`);
            return OutSystems.Maps.MapAPI.MapManager.GetActiveMap();
        }
        MapManager.GetActiveMap = GetActiveMap;
        function GetAllMarkers(mapId) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MapManager.GetAllMarkers()'`);
            return OutSystems.Maps.MapAPI.MapManager.GetAllMarkers(mapId);
        }
        MapManager.GetAllMarkers = GetAllMarkers;
        function GetMapById(mapId, raiseError = true) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MapManager.GetMapById()'`);
            return OutSystems.Maps.MapAPI.MapManager.GetMapById(mapId, raiseError);
        }
        MapManager.GetMapById = GetMapById;
        function GetMapsFromPage() {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MapManager.GetMapsFromPage()'`);
            return OutSystems.Maps.MapAPI.MapManager.GetMapsFromPage();
        }
        MapManager.GetMapsFromPage = GetMapsFromPage;
        function InitializeMap(mapId) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MapManager.InitializeMap()'`);
            OutSystems.Maps.MapAPI.MapManager.InitializeMap(mapId);
        }
        MapManager.InitializeMap = InitializeMap;
        function RemoveMap(mapId) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MapManager.RemoveMap()'`);
            OutSystems.Maps.MapAPI.MapManager.RemoveMap(mapId);
        }
        MapManager.RemoveMap = RemoveMap;
        function RemoveMarkers(mapId) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MapManager.RemoveMarkers()'`);
            OutSystems.Maps.MapAPI.MapManager.RemoveMarkers(mapId);
        }
        MapManager.RemoveMarkers = RemoveMarkers;
        function RemoveFileLayers(mapId) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MapManager.RemoveFileLayers()'`);
            OutSystems.Maps.MapAPI.MapManager.RemoveFileLayers(mapId);
        }
        MapManager.RemoveFileLayers = RemoveFileLayers;
        function SetHeight(mapId, height) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MapManager.SetHeight()'`);
            OutSystems.Maps.MapAPI.MapManager.SetHeight(mapId, height);
        }
        MapManager.SetHeight = SetHeight;
    })(MapManager = MapAPI.MapManager || (MapAPI.MapManager = {}));
})(MapAPI || (MapAPI = {}));
var OutSystems;
(function (OutSystems) {
    var Maps;
    (function (Maps) {
        var MapAPI;
        (function (MapAPI) {
            var MarkerManager;
            (function (MarkerManager) {
                var Events;
                (function (Events) {
                    const _pendingEvents = new Map();
                    const _eventsToMarkerId = new Map();
                    function CheckPendingEvents(marker) {
                        for (const key of _pendingEvents.keys()) {
                            if (marker.equalsToID(key)) {
                                _pendingEvents.get(key).forEach((obj) => {
                                    marker.markerEvents.addHandler(obj.event, obj.cb, obj.uniqueId);
                                });
                                _pendingEvents.delete(key);
                            }
                        }
                    }
                    Events.CheckPendingEvents = CheckPendingEvents;
                    function GetMarkerIdByEventUniqueId(eventUniqueId, lookUpDOM = true) {
                        if (lookUpDOM && !_eventsToMarkerId.has(eventUniqueId)) {
                            const eventElement = OSFramework.Maps.Helper.GetElementByUniqueId(eventUniqueId);
                            const markerId = OSFramework.Maps.Helper.GetClosestMarkerId(eventElement);
                            _eventsToMarkerId.set(eventUniqueId, markerId);
                        }
                        return _eventsToMarkerId.get(eventUniqueId);
                    }
                    Events.GetMarkerIdByEventUniqueId = GetMarkerIdByEventUniqueId;
                    function Subscribe(markerId, eventName, callback) {
                        const responseObj = {
                            isSuccess: true,
                            message: 'Success',
                            code: '200',
                        };
                        try {
                            const marker = MarkerManager.GetMarkerById(markerId);
                            marker.markerEvents.addHandler(eventName, callback, markerId);
                            marker.refreshProviderEvents();
                        }
                        catch (error) {
                            responseObj.isSuccess = false;
                            responseObj.message = error.message;
                            responseObj.code = OSFramework.Maps.Enum.ErrorCodes.API_FailedSubscribeMarkerEvent;
                        }
                        return JSON.stringify(responseObj);
                    }
                    Events.Subscribe = Subscribe;
                    function SubscribeByUniqueId(eventUniqueId, eventName, callback) {
                        const markerId = GetMarkerIdByEventUniqueId(eventUniqueId);
                        const marker = MarkerManager.GetMarkerById(markerId, false);
                        if (marker === undefined) {
                            if (_pendingEvents.has(markerId)) {
                                _pendingEvents.get(markerId).push({
                                    event: eventName,
                                    cb: callback,
                                    uniqueId: eventUniqueId,
                                });
                            }
                            else {
                                _pendingEvents.set(markerId, [
                                    {
                                        event: eventName,
                                        cb: callback,
                                        uniqueId: eventUniqueId,
                                    },
                                ]);
                            }
                        }
                        else {
                            marker.markerEvents.addHandler(eventName, callback, eventUniqueId);
                        }
                    }
                    Events.SubscribeByUniqueId = SubscribeByUniqueId;
                    function SubscribeAll(mapId, eventName, callback) {
                        const map = MapAPI.MapManager.GetMapById(mapId);
                        map.markers.forEach((marker) => {
                            marker.markerEvents.addHandler(eventName, callback, mapId);
                        });
                    }
                    Events.SubscribeAll = SubscribeAll;
                    function Unsubscribe(eventUniqueId, eventName, callback) {
                        const markerId = GetMarkerIdByEventUniqueId(eventUniqueId);
                        const marker = MarkerManager.GetMarkerById(markerId, false);
                        if (marker !== undefined) {
                            marker.markerEvents.removeHandler(eventName, callback);
                            marker.refreshProviderEvents();
                        }
                        else {
                            if (_pendingEvents.has(eventUniqueId)) {
                                const index = _pendingEvents.get(eventUniqueId).findIndex((element) => {
                                    return element.event === eventName && element.cb === callback;
                                });
                                if (index !== -1) {
                                    _pendingEvents.get(eventUniqueId).splice(index, 1);
                                }
                            }
                        }
                    }
                    Events.Unsubscribe = Unsubscribe;
                    function UnsubscribeByMarkerId(markerId, eventName, callback) {
                        const responseObj = {
                            isSuccess: true,
                            message: 'Success',
                            code: '200',
                        };
                        try {
                            const marker = MarkerManager.GetMarkerById(markerId);
                            if (marker !== undefined) {
                                marker.markerEvents.removeHandler(eventName, callback);
                                marker.refreshProviderEvents();
                            }
                        }
                        catch (error) {
                            responseObj.isSuccess = false;
                            responseObj.message = error.message;
                            responseObj.code = OSFramework.Maps.Enum.ErrorCodes.API_FailedUnsubscribeMarkerEvent;
                        }
                        return JSON.stringify(responseObj);
                    }
                    Events.UnsubscribeByMarkerId = UnsubscribeByMarkerId;
                })(Events = MarkerManager.Events || (MarkerManager.Events = {}));
            })(MarkerManager = MapAPI.MarkerManager || (MapAPI.MarkerManager = {}));
        })(MapAPI = Maps.MapAPI || (Maps.MapAPI = {}));
    })(Maps = OutSystems.Maps || (OutSystems.Maps = {}));
})(OutSystems || (OutSystems = {}));
var MapAPI;
(function (MapAPI) {
    var MarkerManager;
    (function (MarkerManager) {
        var Events;
        (function (Events) {
            function CheckPendingEvents(marker) {
                OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MarkerManager.Events.CheckPendingEvents()'`);
                OutSystems.Maps.MapAPI.MarkerManager.Events.CheckPendingEvents(marker);
            }
            Events.CheckPendingEvents = CheckPendingEvents;
            function GetMarkerIdByEventUniqueId(eventUniqueId, lookUpDOM = true) {
                OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MarkerManager.Events.GetMarkerIdByEventUniqueId()'`);
                return OutSystems.Maps.MapAPI.MarkerManager.Events.GetMarkerIdByEventUniqueId(eventUniqueId, lookUpDOM);
            }
            Events.GetMarkerIdByEventUniqueId = GetMarkerIdByEventUniqueId;
            function Subscribe(markerId, eventName, callback) {
                OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MarkerManager.Events.Subscribe()'`);
                OutSystems.Maps.MapAPI.MarkerManager.Events.Subscribe(markerId, eventName, callback);
            }
            Events.Subscribe = Subscribe;
            function SubscribeByUniqueId(eventUniqueId, eventName, callback) {
                OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MarkerManager.Events.SubscribeByUniqueId()'`);
                OutSystems.Maps.MapAPI.MarkerManager.Events.SubscribeByUniqueId(eventUniqueId, eventName, callback);
            }
            Events.SubscribeByUniqueId = SubscribeByUniqueId;
            function SubscribeAll(mapId, eventName, callback) {
                OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MarkerManager.Events.SubscribeAll()'`);
                OutSystems.Maps.MapAPI.MarkerManager.Events.SubscribeAll(mapId, eventName, callback);
            }
            Events.SubscribeAll = SubscribeAll;
            function Unsubscribe(eventUniqueId, eventName, callback) {
                OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MarkerManager.Events.Unsubscribe()'`);
                OutSystems.Maps.MapAPI.MarkerManager.Events.Unsubscribe(eventUniqueId, eventName, callback);
            }
            Events.Unsubscribe = Unsubscribe;
        })(Events = MarkerManager.Events || (MarkerManager.Events = {}));
    })(MarkerManager = MapAPI.MarkerManager || (MapAPI.MarkerManager = {}));
})(MapAPI || (MapAPI = {}));
var OutSystems;
(function (OutSystems) {
    var Maps;
    (function (Maps) {
        var MapAPI;
        (function (MapAPI) {
            var MarkerManager;
            (function (MarkerManager) {
                const markerMap = new Map();
                const markerArr = new Array();
                function GetMapByMarkerId(markerId) {
                    let map;
                    if (markerMap.has(markerId)) {
                        map = MapAPI.MapManager.GetMapById(markerMap.get(markerId), false);
                    }
                    else {
                        const elem = OSFramework.Maps.Helper.GetElementByUniqueId(markerId, false);
                        if (elem !== undefined) {
                            const mapId = OSFramework.Maps.Helper.GetClosestMapId(elem);
                            map = MapAPI.MapManager.GetMapById(mapId);
                        }
                    }
                    return map;
                }
                function CleanMarkerArrays(markerId) {
                    markerMap.has(markerId) && markerMap.delete(markerId);
                    markerArr.splice(markerArr.findIndex((marker) => {
                        return marker === null || marker === void 0 ? void 0 : marker.equalsToID(markerId);
                    }), 1);
                }
                function AddMarker(mapId, configs) {
                    const responseObj = {
                        isSuccess: true,
                        message: 'Success',
                        code: '200',
                    };
                    try {
                        const map = MapAPI.MapManager.GetMapById(mapId, true);
                        const markerId = OSFramework.Maps.Helper.GenerateUniqueId();
                        const marker = OSFramework.Maps.Marker.MarkerFactory.MakeMarker(map, markerId, OSFramework.Maps.Enum.MarkerType.Marker, JSON.parse(configs));
                        markerArr.push(marker);
                        markerMap.set(markerId, map.uniqueId);
                        map.addMarker(marker);
                        responseObj.message = markerId;
                    }
                    catch (error) {
                        responseObj.isSuccess = false;
                        responseObj.message = error.message;
                        responseObj.code = OSFramework.Maps.Enum.ErrorCodes.API_FailedCreateMarker;
                    }
                    return JSON.stringify(responseObj);
                }
                MarkerManager.AddMarker = AddMarker;
                function ChangeProperty(markerId, propertyName, propertyValue) {
                    const marker = GetMarkerById(markerId);
                    const map = marker.map;
                    if (map !== undefined) {
                        map.changeMarkerProperty(markerId, propertyName, propertyValue);
                    }
                }
                MarkerManager.ChangeProperty = ChangeProperty;
                function ClosePopup(markerId) {
                    const marker = GetMarkerById(markerId);
                    if (marker.hasPopup)
                        marker.closePopup();
                }
                MarkerManager.ClosePopup = ClosePopup;
                function RefreshPopup(markerId) {
                    const marker = GetMarkerById(markerId);
                    if (marker.hasPopup)
                        marker.refreshPopupContent();
                }
                MarkerManager.RefreshPopup = RefreshPopup;
                function RemoveMarkerFromCluster(mapId, markerPosition) {
                    const responseObj = {
                        isSuccess: true,
                        message: 'Success',
                        code: '200',
                    };
                    try {
                        const map = MapAPI.MapManager.GetMapById(mapId, true);
                        if (map.providerType === OSFramework.Maps.Enum.ProviderType.Google) {
                            if (map.hasMarkerClusterer()) {
                                const marker = map.markers.find((marker) => {
                                    return marker.config.location === markerPosition;
                                });
                                if (marker !== undefined) {
                                    map.features.markerClusterer.removeMarker(marker);
                                    marker.provider.setMap(map.provider);
                                }
                                else {
                                    responseObj.isSuccess = false;
                                    responseObj.message = `There are not a marker with position:'${markerPosition}' to be removed.`;
                                    responseObj.code = OSFramework.Maps.Enum.ErrorCodes.API_FailedRemoveMarkerFromCluster;
                                }
                            }
                            else {
                                responseObj.isSuccess = false;
                                responseObj.message = `Map with Id:'${mapId}' does not contain Marker Clustering.`;
                                responseObj.code = OSFramework.Maps.Enum.ErrorCodes.API_FailedRemoveMarkerFromCluster;
                            }
                        }
                        else {
                            responseObj.isSuccess = false;
                            responseObj.message = `Marker Clustering not available for '${map.providerType}' provider type.`;
                            responseObj.code = OSFramework.Maps.Enum.ErrorCodes.API_FailedRemoveMarkerFromCluster;
                        }
                    }
                    catch (error) {
                        responseObj.isSuccess = false;
                        responseObj.message = error.message;
                        responseObj.code = OSFramework.Maps.Enum.ErrorCodes.API_FailedRemoveMarkerFromCluster;
                    }
                    return JSON.stringify(responseObj);
                }
                MarkerManager.RemoveMarkerFromCluster = RemoveMarkerFromCluster;
                function CreateMarker(mapId, markerId, configs) {
                    const map = MapAPI.MapManager.GetMapById(mapId, true);
                    if (map.providerType === OSFramework.Maps.Enum.ProviderType.Google) {
                        if (!map.hasMarker(markerId)) {
                            const _marker = Provider.Maps.Google.Marker.MarkerFactory.MakeMarker(map, markerId, OSFramework.Maps.Enum.MarkerType.Marker, JSON.parse(configs));
                            markerArr.push(_marker);
                            markerMap.set(markerId, map.uniqueId);
                            map.addMarker(_marker);
                            return _marker;
                        }
                        else {
                            throw new Error(`There is already a Marker registered on the specified Map under id:${markerId}`);
                        }
                    }
                    else {
                        throw new Error(`The provider type '${map.providerType}' does not support this operation.`);
                    }
                }
                MarkerManager.CreateMarker = CreateMarker;
                function CreateMarkerByUniqueID(markerId, markerType, configs) {
                    const map = GetMapByMarkerId(markerId);
                    if (!map.hasMarker(markerId)) {
                        const _marker = OSFramework.Maps.Marker.MarkerFactory.MakeMarker(map, markerId, markerType, JSON.parse(configs));
                        markerArr.push(_marker);
                        markerMap.set(markerId, map.uniqueId);
                        map.addMarker(_marker);
                        MarkerManager.Events.CheckPendingEvents(_marker);
                        return _marker;
                    }
                    else {
                        throw new Error(`There is already a Marker registered on the specified Map under id:${markerId}`);
                    }
                }
                MarkerManager.CreateMarkerByUniqueID = CreateMarkerByUniqueID;
                function GetMarkerById(markerId, raiseError = true) {
                    let marker = markerArr.find((p) => p && p.equalsToID(markerId));
                    if (marker === undefined) {
                        const allMaps = [...MapAPI.MapManager.GetMapsFromPage().values()];
                        allMaps.find((map) => {
                            if (map.drawingTools) {
                                marker = map.drawingTools.createdElements.find((marker) => marker && marker.equalsToID(markerId));
                            }
                            return marker;
                        });
                        if (marker === undefined && raiseError) {
                            throw new Error(`Marker id:${markerId} not found`);
                        }
                    }
                    return marker;
                }
                MarkerManager.GetMarkerById = GetMarkerById;
                function OpenPopup(markerId) {
                    const marker = GetMarkerById(markerId);
                    if (marker.hasPopup)
                        marker.openPopup();
                }
                MarkerManager.OpenPopup = OpenPopup;
                function RemoveMarker(markerId) {
                    var _a;
                    const responseObj = {
                        isSuccess: true,
                        message: 'Success',
                        code: '200',
                    };
                    try {
                        const marker = GetMarkerById(markerId);
                        (_a = marker.map) === null || _a === void 0 ? void 0 : _a.removeMarker(markerId);
                        CleanMarkerArrays(markerId);
                    }
                    catch (error) {
                        responseObj.isSuccess = false;
                        responseObj.message = error.message;
                        responseObj.code = OSFramework.Maps.Enum.ErrorCodes.API_FailedRemoveMarker;
                    }
                    return JSON.stringify(responseObj);
                }
                MarkerManager.RemoveMarker = RemoveMarker;
                function RemoveAllMarkersCreatedByAPI(mapId, removeFromMap = true) {
                    const responseObj = {
                        isSuccess: true,
                        message: 'Success',
                        code: '200',
                    };
                    try {
                        if (removeFromMap) {
                            MapAPI.MapManager.RemoveMarkers(mapId);
                        }
                        for (const [storedMarkerId, storedMapId] of markerMap) {
                            if (storedMapId === mapId) {
                                const marker = GetMarkerById(storedMarkerId, false);
                                if (marker && marker.widgetId === undefined) {
                                    CleanMarkerArrays(storedMarkerId);
                                }
                            }
                        }
                    }
                    catch (error) {
                        responseObj.isSuccess = false;
                        responseObj.message = error.message;
                        responseObj.code = OSFramework.Maps.Enum.ErrorCodes.API_FailedRemoveMarker;
                    }
                    return JSON.stringify(responseObj);
                }
                MarkerManager.RemoveAllMarkersCreatedByAPI = RemoveAllMarkersCreatedByAPI;
                function RemoveAllMarkers(mapId, removeFromMap = true) {
                    const responseObj = {
                        isSuccess: true,
                        message: 'Success',
                        code: '200',
                    };
                    try {
                        if (removeFromMap) {
                            MapAPI.MapManager.RemoveMarkers(mapId);
                        }
                        markerMap.forEach((storedMapId, storedMarkerId) => {
                            if (mapId === storedMapId) {
                                CleanMarkerArrays(storedMarkerId);
                            }
                        });
                    }
                    catch (error) {
                        responseObj.isSuccess = false;
                        responseObj.message = error.message;
                        responseObj.code = OSFramework.Maps.Enum.ErrorCodes.API_FailedRemoveMarkers;
                    }
                    return JSON.stringify(responseObj);
                }
                MarkerManager.RemoveAllMarkers = RemoveAllMarkers;
            })(MarkerManager = MapAPI.MarkerManager || (MapAPI.MarkerManager = {}));
        })(MapAPI = Maps.MapAPI || (Maps.MapAPI = {}));
    })(Maps = OutSystems.Maps || (OutSystems.Maps = {}));
})(OutSystems || (OutSystems = {}));
var MapAPI;
(function (MapAPI) {
    var MarkerManager;
    (function (MarkerManager) {
        function ChangeProperty(markerId, propertyName, propertyValue) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MarkerManager.ChangeProperty()'`);
            OutSystems.Maps.MapAPI.MarkerManager.ChangeProperty(markerId, propertyName, propertyValue);
        }
        MarkerManager.ChangeProperty = ChangeProperty;
        function ClosePopup(markerId) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MarkerManager.ClosePopup()'`);
            OutSystems.Maps.MapAPI.MarkerManager.ClosePopup(markerId);
        }
        MarkerManager.ClosePopup = ClosePopup;
        function RefreshPopup(markerId) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MarkerManager.RefreshPopup()'`);
            OutSystems.Maps.MapAPI.MarkerManager.RefreshPopup(markerId);
        }
        MarkerManager.RefreshPopup = RefreshPopup;
        function CreateMarker(mapId, markerId, configs) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MarkerManager.CreateMarker()'`);
            return OutSystems.Maps.MapAPI.MarkerManager.CreateMarker(mapId, markerId, configs);
        }
        MarkerManager.CreateMarker = CreateMarker;
        function CreateMarkerByUniqueID(markerId, markerType, configs) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MarkerManager.CreateMarkerByUniqueID()'`);
            return OutSystems.Maps.MapAPI.MarkerManager.CreateMarkerByUniqueID(markerId, markerType, configs);
        }
        MarkerManager.CreateMarkerByUniqueID = CreateMarkerByUniqueID;
        function GetMarkerById(markerId, raiseError = true) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MarkerManager.GetMarkerById()'`);
            return OutSystems.Maps.MapAPI.MarkerManager.GetMarkerById(markerId, raiseError);
        }
        MarkerManager.GetMarkerById = GetMarkerById;
        function OpenPopup(markerId) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MarkerManager.OpenPopup()'`);
            return OutSystems.Maps.MapAPI.MarkerManager.OpenPopup(markerId);
        }
        MarkerManager.OpenPopup = OpenPopup;
        function RemoveMarker(markerId) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.MarkerManager.RemoveMarker()'`);
            OutSystems.Maps.MapAPI.MarkerManager.RemoveMarker(markerId);
        }
        MarkerManager.RemoveMarker = RemoveMarker;
    })(MarkerManager = MapAPI.MarkerManager || (MapAPI.MarkerManager = {}));
})(MapAPI || (MapAPI = {}));
var OutSystems;
(function (OutSystems) {
    var Maps;
    (function (Maps) {
        var MapAPI;
        (function (MapAPI) {
            var ShapeManager;
            (function (ShapeManager) {
                var Events;
                (function (Events) {
                    const _pendingEvents = new Map();
                    const _eventsToShapeId = new Map();
                    function CheckPendingEvents(shape) {
                        for (const key of _pendingEvents.keys()) {
                            if (shape.equalsToID(key)) {
                                _pendingEvents.get(key).forEach((obj) => {
                                    shape.shapeEvents.addHandler(obj.event, obj.cb, obj.uniqueId);
                                });
                                _pendingEvents.delete(key);
                            }
                        }
                    }
                    Events.CheckPendingEvents = CheckPendingEvents;
                    function GetShapeIdByEventUniqueId(eventUniqueId, lookUpDOM = true) {
                        if (lookUpDOM && !_eventsToShapeId.has(eventUniqueId)) {
                            const eventElement = OSFramework.Maps.Helper.GetElementByUniqueId(eventUniqueId);
                            const shapeId = OSFramework.Maps.Helper.GetClosestShapeId(eventElement);
                            _eventsToShapeId.set(eventUniqueId, shapeId);
                        }
                        return _eventsToShapeId.get(eventUniqueId);
                    }
                    Events.GetShapeIdByEventUniqueId = GetShapeIdByEventUniqueId;
                    function Subscribe(shapeId, eventName, callback) {
                        const shape = ShapeManager.GetShapeById(shapeId);
                        shape.shapeEvents.addHandler(eventName, callback, shapeId);
                    }
                    Events.Subscribe = Subscribe;
                    function SubscribeByEventUniqueId(eventUniqueId, eventName, callback) {
                        const shapeId = GetShapeIdByEventUniqueId(eventUniqueId);
                        const shape = ShapeManager.GetShapeById(shapeId, false);
                        if (shape === undefined) {
                            if (_pendingEvents.has(shapeId)) {
                                _pendingEvents.get(shapeId).push({
                                    event: eventName,
                                    cb: callback,
                                    uniqueId: eventUniqueId,
                                });
                            }
                            else {
                                _pendingEvents.set(shapeId, [
                                    {
                                        event: eventName,
                                        cb: callback,
                                        uniqueId: eventUniqueId,
                                    },
                                ]);
                            }
                        }
                        else {
                            shape.shapeEvents.addHandler(eventName, callback, eventUniqueId);
                            shape.refreshProviderEvents();
                        }
                    }
                    Events.SubscribeByEventUniqueId = SubscribeByEventUniqueId;
                    function Unsubscribe(eventUniqueId, eventName, callback) {
                        const shapeId = GetShapeIdByEventUniqueId(eventUniqueId);
                        const shape = ShapeManager.GetShapeById(shapeId);
                        if (shape !== undefined) {
                            shape.shapeEvents.removeHandler(eventName, callback);
                            shape.refreshProviderEvents();
                        }
                        else {
                            if (_pendingEvents.has(eventUniqueId)) {
                                const index = _pendingEvents.get(eventUniqueId).findIndex((element) => {
                                    return element.event === eventName && element.cb === callback;
                                });
                                if (index !== -1) {
                                    _pendingEvents.get(eventUniqueId).splice(index, 1);
                                }
                            }
                        }
                    }
                    Events.Unsubscribe = Unsubscribe;
                })(Events = ShapeManager.Events || (ShapeManager.Events = {}));
            })(ShapeManager = MapAPI.ShapeManager || (MapAPI.ShapeManager = {}));
        })(MapAPI = Maps.MapAPI || (Maps.MapAPI = {}));
    })(Maps = OutSystems.Maps || (OutSystems.Maps = {}));
})(OutSystems || (OutSystems = {}));
var MapAPI;
(function (MapAPI) {
    var ShapeManager;
    (function (ShapeManager) {
        var Events;
        (function (Events) {
            function CheckPendingEvents(shape) {
                OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.Auxiliary.OutSystems.Maps.MapAPI.ShapeManager.Events.CheckPendingEvents()'`);
                OutSystems.Maps.MapAPI.ShapeManager.Events.CheckPendingEvents(shape);
            }
            Events.CheckPendingEvents = CheckPendingEvents;
            function GetShapeIdByEventUniqueId(eventUniqueId, lookUpDOM = true) {
                OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.ShapeManager.Events.GetShapeIdByEventUniqueId()'`);
                return OutSystems.Maps.MapAPI.ShapeManager.Events.GetShapeIdByEventUniqueId(eventUniqueId, lookUpDOM);
            }
            Events.GetShapeIdByEventUniqueId = GetShapeIdByEventUniqueId;
            function Subscribe(shapeId, eventName, callback) {
                OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.ShapeManager.Events.Subscribe()'`);
                OutSystems.Maps.MapAPI.ShapeManager.Events.Subscribe(shapeId, eventName, callback);
            }
            Events.Subscribe = Subscribe;
            function SubscribeByEventUniqueId(eventUniqueId, eventName, callback) {
                OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.ShapeManager.Events.SubscribeByEventUniqueId()'`);
                OutSystems.Maps.MapAPI.ShapeManager.Events.SubscribeByEventUniqueId(eventUniqueId, eventName, callback);
            }
            Events.SubscribeByEventUniqueId = SubscribeByEventUniqueId;
            function Unsubscribe(eventUniqueId, eventName, callback) {
                OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.ShapeManager.Events.Unsubscribe()'`);
                OutSystems.Maps.MapAPI.ShapeManager.Events.Unsubscribe(eventUniqueId, eventName, callback);
            }
            Events.Unsubscribe = Unsubscribe;
        })(Events = ShapeManager.Events || (ShapeManager.Events = {}));
    })(ShapeManager = MapAPI.ShapeManager || (MapAPI.ShapeManager = {}));
})(MapAPI || (MapAPI = {}));
var OutSystems;
(function (OutSystems) {
    var Maps;
    (function (Maps) {
        var MapAPI;
        (function (MapAPI) {
            var ShapeManager;
            (function (ShapeManager) {
                const shapeMap = new Map();
                const shapeArr = new Array();
                function ChangeProperty(shapeId, propertyName, propertyValue) {
                    const shape = GetShapeById(shapeId);
                    const map = shape.map;
                    if (map !== undefined) {
                        map.changeShapeProperty(shapeId, propertyName, propertyValue);
                    }
                }
                ShapeManager.ChangeProperty = ChangeProperty;
                function CreateShape(shapeId, shapeType, configs) {
                    const map = GetMapByShapeId(shapeId);
                    if (!map.hasShape(shapeId)) {
                        const _shape = OSFramework.Maps.Shape.ShapeFactory.MakeShape(map, shapeId, shapeType, JSON.parse(configs));
                        shapeArr.push(_shape);
                        shapeMap.set(shapeId, map.uniqueId);
                        map.addShape(_shape);
                        ShapeManager.Events.CheckPendingEvents(_shape);
                        return _shape;
                    }
                    else {
                        throw new Error(`There is already a Shape registered on the specified Map under id:${shapeId}`);
                    }
                }
                ShapeManager.CreateShape = CreateShape;
                function GetCircle(shapeId) {
                    const shape = GetShapeById(shapeId);
                    const properties = new OSFramework.Maps.OSStructures.API.CircleProperties();
                    if (shape.type === OSFramework.Maps.Enum.ShapeType.Circle) {
                        properties.Center = {
                            Lat: shape.providerCenter.lat,
                            Lng: shape.providerCenter.lng,
                        };
                        properties.Radius = shape.providerRadius;
                    }
                    else {
                        OSFramework.Maps.Helper.ThrowError(shape.map, OSFramework.Maps.Enum.ErrorCodes.API_FailedGettingCircleShape);
                    }
                    return JSON.stringify(properties || '');
                }
                ShapeManager.GetCircle = GetCircle;
                function GetMapByShapeId(shapeId) {
                    let map;
                    if (shapeMap.has(shapeId)) {
                        map = MapAPI.MapManager.GetMapById(shapeMap.get(shapeId), false);
                    }
                    else {
                        const elem = OSFramework.Maps.Helper.GetElementByUniqueId(shapeId, false);
                        if (elem !== undefined) {
                            const mapId = OSFramework.Maps.Helper.GetClosestMapId(elem);
                            map = MapAPI.MapManager.GetMapById(mapId);
                        }
                    }
                    return map;
                }
                function GetShapeById(shapeId, raiseError = true) {
                    let shape = shapeArr.find((p) => p && p.equalsToID(shapeId));
                    if (shape === undefined) {
                        const allMaps = [...MapAPI.MapManager.GetMapsFromPage().values()];
                        allMaps.find((map) => {
                            return (shape =
                                map.drawingTools &&
                                    map.drawingTools.createdElements.find((shape) => shape.equalsToID(shapeId)));
                        });
                        if (shape === undefined && raiseError) {
                            throw new Error(`Shape id:${shapeId} not found`);
                        }
                    }
                    return shape;
                }
                ShapeManager.GetShapeById = GetShapeById;
                function GetShapePath(shapeId) {
                    const shape = GetShapeById(shapeId);
                    const providerPath = shape.providerPath;
                    let shapePath = [];
                    if (providerPath !== undefined) {
                        shapePath = providerPath.map((coords) => {
                            return { Lat: coords.lat, Lng: coords.lng };
                        });
                    }
                    else {
                        OSFramework.Maps.Helper.ThrowError(shape.map, OSFramework.Maps.Enum.ErrorCodes.API_FailedGettingShapePath);
                    }
                    return JSON.stringify(shapePath);
                }
                ShapeManager.GetShapePath = GetShapePath;
                function RemoveShape(shapeId) {
                    const shape = GetShapeById(shapeId);
                    const map = shape.map;
                    map && map.removeShape(shapeId);
                    shapeMap.delete(shapeId);
                    shapeArr.splice(shapeArr.findIndex((p) => {
                        return p && p.equalsToID(shapeId);
                    }), 1);
                }
                ShapeManager.RemoveShape = RemoveShape;
                function ContainsLocation(mapId, shapeId, pointCoordinates, coordinatesList) {
                    const map = MapAPI.MapManager.GetMapById(mapId, true);
                    const containsLocationResponse = map.features.shape.containsLocation(mapId, shapeId, pointCoordinates, coordinatesList);
                    return JSON.stringify(containsLocationResponse);
                }
                ShapeManager.ContainsLocation = ContainsLocation;
            })(ShapeManager = MapAPI.ShapeManager || (MapAPI.ShapeManager = {}));
        })(MapAPI = Maps.MapAPI || (Maps.MapAPI = {}));
    })(Maps = OutSystems.Maps || (OutSystems.Maps = {}));
})(OutSystems || (OutSystems = {}));
var MapAPI;
(function (MapAPI) {
    var ShapeManager;
    (function (ShapeManager) {
        function ChangeProperty(shapeId, propertyName, propertyValue) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.ShapeManager.ChangeProperty()'`);
            OutSystems.Maps.MapAPI.ShapeManager.ChangeProperty(shapeId, propertyName, propertyValue);
        }
        ShapeManager.ChangeProperty = ChangeProperty;
        function CreateShape(shapeId, shapeType, configs) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.ShapeManager.CreateShape()'`);
            return OutSystems.Maps.MapAPI.ShapeManager.CreateShape(shapeId, shapeType, configs);
        }
        ShapeManager.CreateShape = CreateShape;
        function GetCircle(shapeId) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.ShapeManager.GetCircle()'`);
            return OutSystems.Maps.MapAPI.ShapeManager.GetCircle(shapeId);
        }
        ShapeManager.GetCircle = GetCircle;
        function GetShapeById(shapeId, raiseError = true) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.ShapeManager.GetShapeById()'`);
            return OutSystems.Maps.MapAPI.ShapeManager.GetShapeById(shapeId, raiseError);
        }
        ShapeManager.GetShapeById = GetShapeById;
        function GetShapePath(shapeId) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.ShapeManager.GetShapePath()'`);
            return OutSystems.Maps.MapAPI.ShapeManager.GetShapePath(shapeId);
        }
        ShapeManager.GetShapePath = GetShapePath;
        function RemoveShape(shapeId) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.MapAPI.ShapeManager.RemoveShape()'`);
            OutSystems.Maps.MapAPI.ShapeManager.RemoveShape(shapeId);
        }
        ShapeManager.RemoveShape = RemoveShape;
    })(ShapeManager = MapAPI.ShapeManager || (MapAPI.ShapeManager = {}));
})(MapAPI || (MapAPI = {}));
var OutSystems;
(function (OutSystems) {
    var Maps;
    (function (Maps) {
        var PlacesAPI;
        (function (PlacesAPI) {
            var SearchPlacesManager;
            (function (SearchPlacesManager) {
                var Events;
                (function (Events) {
                    const _pendingEvents = new Map();
                    const _eventsToSearchPlacesId = new Map();
                    function CheckPendingEvents(searchPlaces) {
                        for (const key of _pendingEvents.keys()) {
                            if (searchPlaces.equalsToID(key)) {
                                _pendingEvents.get(key).forEach((obj) => {
                                    searchPlaces.searchPlacesEvents.addHandler(obj.event, obj.cb, obj.uniqueId);
                                });
                                _pendingEvents.delete(key);
                            }
                        }
                    }
                    Events.CheckPendingEvents = CheckPendingEvents;
                    function GetSearchPlacesByEventUniqueId(eventUniqueId, lookUpDOM = true) {
                        if (lookUpDOM && !_eventsToSearchPlacesId.has(eventUniqueId)) {
                            const eventElement = OSFramework.Maps.Helper.GetElementByUniqueId(eventUniqueId);
                            const searchPlacesId = OSFramework.Maps.Helper.GetClosestSearchPlacesId(eventElement);
                            const searchPlaces = SearchPlacesManager.GetSearchPlacesById(searchPlacesId);
                            if (searchPlaces) {
                                _eventsToSearchPlacesId.set(eventUniqueId, searchPlacesId);
                            }
                        }
                        return _eventsToSearchPlacesId.get(eventUniqueId);
                    }
                    Events.GetSearchPlacesByEventUniqueId = GetSearchPlacesByEventUniqueId;
                    function Subscribe(searchPlacesId, eventName, callback) {
                        const searchPlaces = SearchPlacesManager.GetSearchPlacesById(searchPlacesId, false);
                        if (searchPlaces === undefined) {
                            if (_pendingEvents.has(searchPlacesId)) {
                                _pendingEvents.get(searchPlacesId).push({
                                    event: eventName,
                                    cb: callback,
                                    uniqueId: searchPlacesId,
                                });
                            }
                            else {
                                _pendingEvents.set(searchPlacesId, [
                                    {
                                        event: eventName,
                                        cb: callback,
                                        uniqueId: searchPlacesId,
                                    },
                                ]);
                            }
                        }
                        else {
                            searchPlaces.searchPlacesEvents.addHandler(eventName, callback, searchPlacesId);
                        }
                    }
                    Events.Subscribe = Subscribe;
                    function Unsubscribe(eventUniqueId, eventName, callback) {
                        const searchPlacesId = GetSearchPlacesByEventUniqueId(eventUniqueId);
                        const searchPlaces = SearchPlacesManager.GetSearchPlacesById(searchPlacesId, false);
                        if (searchPlaces !== undefined) {
                            searchPlaces.searchPlacesEvents.removeHandler(eventName, callback);
                        }
                        else {
                            if (_pendingEvents.has(searchPlacesId)) {
                                const index = _pendingEvents.get(searchPlacesId).findIndex((element) => {
                                    return element.event === eventName && element.cb === callback;
                                });
                                if (index !== -1) {
                                    _pendingEvents.get(searchPlacesId).splice(index, 1);
                                }
                            }
                        }
                    }
                    Events.Unsubscribe = Unsubscribe;
                })(Events = SearchPlacesManager.Events || (SearchPlacesManager.Events = {}));
            })(SearchPlacesManager = PlacesAPI.SearchPlacesManager || (PlacesAPI.SearchPlacesManager = {}));
        })(PlacesAPI = Maps.PlacesAPI || (Maps.PlacesAPI = {}));
    })(Maps = OutSystems.Maps || (OutSystems.Maps = {}));
})(OutSystems || (OutSystems = {}));
var PlacesAPI;
(function (PlacesAPI) {
    var SearchPlacesManager;
    (function (SearchPlacesManager) {
        var Events;
        (function (Events) {
            function CheckPendingEvents(searchPlaces) {
                OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.PlacesAPI.SearchPlacesManager.Events.CheckPendingEvents()'`);
                OutSystems.Maps.PlacesAPI.SearchPlacesManager.Events.CheckPendingEvents(searchPlaces);
            }
            Events.CheckPendingEvents = CheckPendingEvents;
            function GetSearchPlacesByEventUniqueId(eventUniqueId, lookUpDOM = true) {
                OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.PlacesAPI.SearchPlacesManager.Events.GetSearchPlacesByEventUniqueId()'`);
                return OutSystems.Maps.PlacesAPI.SearchPlacesManager.Events.GetSearchPlacesByEventUniqueId(eventUniqueId, lookUpDOM);
            }
            Events.GetSearchPlacesByEventUniqueId = GetSearchPlacesByEventUniqueId;
            function Subscribe(searchPlacesId, eventName, callback) {
                OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.PlacesAPI.SearchPlacesManager.Events.Subscribe()'`);
                OutSystems.Maps.PlacesAPI.SearchPlacesManager.Events.Subscribe(searchPlacesId, eventName, callback);
            }
            Events.Subscribe = Subscribe;
            function Unsubscribe(eventUniqueId, eventName, callback) {
                OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.PlacesAPI.SearchPlacesManager.Events.Unsubscribe()'`);
                OutSystems.Maps.PlacesAPI.SearchPlacesManager.Events.Unsubscribe(eventUniqueId, eventName, callback);
            }
            Events.Unsubscribe = Unsubscribe;
        })(Events = SearchPlacesManager.Events || (SearchPlacesManager.Events = {}));
    })(SearchPlacesManager = PlacesAPI.SearchPlacesManager || (PlacesAPI.SearchPlacesManager = {}));
})(PlacesAPI || (PlacesAPI = {}));
var OutSystems;
(function (OutSystems) {
    var Maps;
    (function (Maps) {
        var PlacesAPI;
        (function (PlacesAPI) {
            var SearchPlacesManager;
            (function (SearchPlacesManager) {
                const searchPlacesMap = new Map();
                let activeSearchPlaces = undefined;
                function ChangeProperty(searchPlacesId, propertyName, propertyValue) {
                    const searchPlaces = GetSearchPlacesById(searchPlacesId);
                    searchPlaces.changeProperty(propertyName, propertyValue);
                }
                SearchPlacesManager.ChangeProperty = ChangeProperty;
                function CreateSearchPlaces(searchPlacesId, configs, apiversion) {
                    const _searchPlaces = Provider.Maps.Google.SearchPlaces.SearchPlacesFactory.MakeSearchPlaces(searchPlacesId, JSON.parse(configs), apiversion);
                    if (searchPlacesMap.has(searchPlacesId)) {
                        throw new Error(`There is already a SearchPlaces registered under id:${searchPlacesId}`);
                    }
                    searchPlacesMap.set(searchPlacesId, _searchPlaces);
                    activeSearchPlaces = _searchPlaces;
                    SearchPlacesManager.Events.CheckPendingEvents(_searchPlaces);
                    return _searchPlaces;
                }
                SearchPlacesManager.CreateSearchPlaces = CreateSearchPlaces;
                function GetActiveSearchPlaces() {
                    return activeSearchPlaces;
                }
                SearchPlacesManager.GetActiveSearchPlaces = GetActiveSearchPlaces;
                function GetSearchPlacesById(searchPlacesId, raiseError = true) {
                    let _searchPlaces;
                    if (searchPlacesMap.has(searchPlacesId)) {
                        _searchPlaces = searchPlacesMap.get(searchPlacesId);
                    }
                    else {
                        for (const p of searchPlacesMap.values()) {
                            if (p.equalsToID(searchPlacesId)) {
                                _searchPlaces = p;
                                break;
                            }
                        }
                    }
                    if (_searchPlaces === undefined && raiseError) {
                        throw new Error(`SearchPlaces id:${searchPlacesId} not found`);
                    }
                    return _searchPlaces;
                }
                SearchPlacesManager.GetSearchPlacesById = GetSearchPlacesById;
                function GetSearchPlacessFromPage() {
                    return searchPlacesMap;
                }
                SearchPlacesManager.GetSearchPlacessFromPage = GetSearchPlacessFromPage;
                function InitializeSearchPlaces(searchPlacesId) {
                    const searchPlaces = GetSearchPlacesById(searchPlacesId);
                    searchPlaces.build();
                    SearchPlacesManager.Events.CheckPendingEvents(searchPlaces);
                }
                SearchPlacesManager.InitializeSearchPlaces = InitializeSearchPlaces;
                function RemoveSearchPlaces(searchPlacesId) {
                    const _searchPlaces = GetSearchPlacesById(searchPlacesId);
                    searchPlacesMap.delete(_searchPlaces.uniqueId);
                    if (activeSearchPlaces.uniqueId === _searchPlaces.uniqueId) {
                        activeSearchPlaces = Array.from(searchPlacesMap.values()).pop();
                    }
                    _searchPlaces.dispose();
                }
                SearchPlacesManager.RemoveSearchPlaces = RemoveSearchPlaces;
            })(SearchPlacesManager = PlacesAPI.SearchPlacesManager || (PlacesAPI.SearchPlacesManager = {}));
        })(PlacesAPI = Maps.PlacesAPI || (Maps.PlacesAPI = {}));
    })(Maps = OutSystems.Maps || (OutSystems.Maps = {}));
})(OutSystems || (OutSystems = {}));
var PlacesAPI;
(function (PlacesAPI) {
    var SearchPlacesManager;
    (function (SearchPlacesManager) {
        function ChangeProperty(searchPlacesId, propertyName, propertyValue) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.PlacesAPI.SearchPlacesManager.ChangeProperty()'`);
            OutSystems.Maps.PlacesAPI.SearchPlacesManager.ChangeProperty(searchPlacesId, propertyName, propertyValue);
        }
        SearchPlacesManager.ChangeProperty = ChangeProperty;
        function CreateSearchPlaces(searchPlacesId, configs, apiversion) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage}  'OutSystems.Maps.PlacesAPI.SearchPlacesManager.CreateSearchPlaces()'`);
            return OutSystems.Maps.PlacesAPI.SearchPlacesManager.CreateSearchPlaces(searchPlacesId, configs, apiversion);
        }
        SearchPlacesManager.CreateSearchPlaces = CreateSearchPlaces;
        function GetActiveSearchPlaces() {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.PlacesAPI.SearchPlacesManager.GetActiveSearchPlaces()'`);
            return OutSystems.Maps.PlacesAPI.SearchPlacesManager.GetActiveSearchPlaces();
        }
        SearchPlacesManager.GetActiveSearchPlaces = GetActiveSearchPlaces;
        function GetSearchPlacesById(searchPlacesId, raiseError = true) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.PlacesAPI.SearchPlacesManager.GetSearchPlacesById()'`);
            return OutSystems.Maps.PlacesAPI.SearchPlacesManager.GetSearchPlacesById(searchPlacesId, raiseError);
        }
        SearchPlacesManager.GetSearchPlacesById = GetSearchPlacesById;
        function GetSearchPlacessFromPage() {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.PlacesAPI.SearchPlacesManager.GetSearchPlacessFromPage()'`);
            return OutSystems.Maps.PlacesAPI.SearchPlacesManager.GetSearchPlacessFromPage();
        }
        SearchPlacesManager.GetSearchPlacessFromPage = GetSearchPlacessFromPage;
        function InitializeSearchPlaces(searchPlacesId) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.PlacesAPI.SearchPlacesManager.InitializeSearchPlaces()'`);
            OutSystems.Maps.PlacesAPI.SearchPlacesManager.InitializeSearchPlaces(searchPlacesId);
        }
        SearchPlacesManager.InitializeSearchPlaces = InitializeSearchPlaces;
        function RemoveSearchPlaces(searchPlacesId) {
            OSFramework.Maps.Helper.LogWarningMessage(`${OSFramework.Maps.Helper.warningMessage} 'OutSystems.Maps.PlacesAPI.SearchPlacesManager.RemoveSearchPlaces()'`);
            OutSystems.Maps.PlacesAPI.SearchPlacesManager.RemoveSearchPlaces(searchPlacesId);
        }
        SearchPlacesManager.RemoveSearchPlaces = RemoveSearchPlaces;
    })(SearchPlacesManager = PlacesAPI.SearchPlacesManager || (PlacesAPI.SearchPlacesManager = {}));
})(PlacesAPI || (PlacesAPI = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            Google.ClustererStyle = [
                {
                    width: 30,
                    height: 30,
                    className: 'custom-clustericon-1',
                },
                {
                    width: 40,
                    height: 40,
                    className: 'custom-clustericon-2',
                },
                {
                    width: 50,
                    height: 50,
                    className: 'custom-clustericon-3',
                },
            ];
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            Google.Style = {
                Standard: {
                    id: 0,
                    label: 'Standard',
                    style: '',
                    urlStyle: '',
                },
                Silver: {
                    id: 1,
                    label: 'Silver',
                    style: "[{'elementType':'geometry','stylers':[{'color':'#f5f5f5'}]},{'elementType':'labels.icon','stylers':[{'visibility':'off'}]},{'elementType':'labels.text.fill','stylers':[{'color':'#616161'}]},{'elementType':'labels.text.stroke','stylers':[{'color':'#f5f5f5'}]},{'featureType':'administrative.land_parcel','elementType':'labels.text.fill','stylers':[{'color':'#bdbdbd'}]},{'featureType':'poi','elementType':'geometry','stylers':[{'color':'#eeeeee'}]},{'featureType':'poi','elementType':'labels.text.fill','stylers':[{'color':'#757575'}]},{'featureType':'poi.park','elementType':'geometry','stylers':[{'color':'#e5e5e5'}]},{'featureType':'poi.park','elementType':'labels.text.fill','stylers':[{'color':'#9e9e9e'}]},{'featureType':'road','elementType':'geometry','stylers':[{'color':'#ffffff'}]},{'featureType':'road.arterial','elementType':'labels.text.fill','stylers':[{'color':'#757575'}]},{'featureType':'road.highway','elementType':'geometry','stylers':[{'color':'#dadada'}]},{'featureType':'road.highway','elementType':'labels.text.fill','stylers':[{'color':'#616161'}]},{'featureType':'road.local','elementType':'labels.text.fill','stylers':[{'color':'#9e9e9e'}]},{'featureType':'transit.line','elementType':'geometry','stylers':[{'color':'#e5e5e5'}]},{'featureType':'transit.station','elementType':'geometry','stylers':[{'color':'#eeeeee'}]},{'featureType':'water','elementType':'geometry','stylers':[{'color':'#c9c9c9'}]},{'featureType':'water','elementType':'labels.text.fill','stylers':[{'color':'#9e9e9e'}]}]",
                    urlStyle: '&style=element:geometry%7Ccolor:0xf5f5f5&style=element:labels.icon%7Cvisibility:off&style=element:labels.text.fill%7Ccolor:0x616161&style=element:labels.text.stroke%7Ccolor:0xf5f5f5&style=feature:administrative.land_parcel%7Celement:labels.text.fill%7Ccolor:0xbdbdbd&style=feature:poi%7Celement:geometry%7Ccolor:0xeeeeee&style=feature:poi%7Celement:labels.text.fill%7Ccolor:0x757575&style=feature:poi.park%7Celement:geometry%7Ccolor:0xe5e5e5&style=feature:poi.park%7Celement:labels.text.fill%7Ccolor:0x9e9e9e&style=feature:road%7Celement:geometry%7Ccolor:0xffffff&style=feature:road.arterial%7Celement:labels.text.fill%7Ccolor:0x757575&style=feature:road.highway%7Celement:geometry%7Ccolor:0xdadada&style=feature:road.highway%7Celement:labels.text.fill%7Ccolor:0x616161&style=feature:road.local%7Celement:labels.text.fill%7Ccolor:0x9e9e9e&style=feature:transit.line%7Celement:geometry%7Ccolor:0xe5e5e5&style=feature:transit.station%7Celement:geometry%7Ccolor:0xeeeeee&style=feature:water%7Celement:geometry%7Ccolor:0xc9c9c9&style=feature:water%7Celement:labels.text.fill%7Ccolor:0x9e9e9e',
                },
                Retro: {
                    id: 2,
                    label: 'Retro',
                    style: "[{'elementType':'geometry','stylers':[{'color':'#ebe3cd'}]},{'elementType':'labels.text.fill','stylers':[{'color':'#523735'}]},{'elementType':'labels.text.stroke','stylers':[{'color':'#f5f1e6'}]},{'featureType':'administrative','elementType':'geometry.stroke','stylers':[{'color':'#c9b2a6'}]},{'featureType':'administrative.land_parcel','elementType':'geometry.stroke','stylers':[{'color':'#dcd2be'}]},{'featureType':'administrative.land_parcel','elementType':'labels.text.fill','stylers':[{'color':'#ae9e90'}]},{'featureType':'landscape.natural','elementType':'geometry','stylers':[{'color':'#dfd2ae'}]},{'featureType':'poi','elementType':'geometry','stylers':[{'color':'#dfd2ae'}]},{'featureType':'poi','elementType':'labels.text.fill','stylers':[{'color':'#93817c'}]},{'featureType':'poi.park','elementType':'geometry.fill','stylers':[{'color':'#a5b076'}]},{'featureType':'poi.park','elementType':'labels.text.fill','stylers':[{'color':'#447530'}]},{'featureType':'road','elementType':'geometry','stylers':[{'color':'#f5f1e6'}]},{'featureType':'road.arterial','elementType':'geometry','stylers':[{'color':'#fdfcf8'}]},{'featureType':'road.highway','elementType':'geometry','stylers':[{'color':'#f8c967'}]},{'featureType':'road.highway','elementType':'geometry.stroke','stylers':[{'color':'#e9bc62'}]},{'featureType':'road.highway.controlled_access','elementType':'geometry','stylers':[{'color':'#e98d58'}]},{'featureType':'road.highway.controlled_access','elementType':'geometry.stroke','stylers':[{'color':'#db8555'}]},{'featureType':'road.local','elementType':'labels.text.fill','stylers':[{'color':'#806b63'}]},{'featureType':'transit.line','elementType':'geometry','stylers':[{'color':'#dfd2ae'}]},{'featureType':'transit.line','elementType':'labels.text.fill','stylers':[{'color':'#8f7d77'}]},{'featureType':'transit.line','elementType':'labels.text.stroke','stylers':[{'color':'#ebe3cd'}]},{'featureType':'transit.station','elementType':'geometry','stylers':[{'color':'#dfd2ae'}]},{'featureType':'water','elementType':'geometry.fill','stylers':[{'color':'#b9d3c2'}]},{'featureType':'water','elementType':'labels.text.fill','stylers':[{'color':'#92998d'}]}]",
                    urlStyle: '&style=element:geometry%7Ccolor:0xebe3cd&style=element:labels.text.fill%7Ccolor:0x523735&style=element:labels.text.stroke%7Ccolor:0xf5f1e6&style=feature:administrative%7Celement:geometry.stroke%7Ccolor:0xc9b2a6&style=feature:administrative.land_parcel%7Celement:geometry.stroke%7Ccolor:0xdcd2be&style=feature:administrative.land_parcel%7Celement:labels.text.fill%7Ccolor:0xae9e90&style=feature:landscape.natural%7Celement:geometry%7Ccolor:0xdfd2ae&style=feature:poi%7Celement:geometry%7Ccolor:0xdfd2ae&style=feature:poi%7Celement:labels.text.fill%7Ccolor:0x93817c&style=feature:poi.park%7Celement:geometry.fill%7Ccolor:0xa5b076&style=feature:poi.park%7Celement:labels.text.fill%7Ccolor:0x447530&style=feature:road%7Celement:geometry%7Ccolor:0xf5f1e6&style=feature:road.arterial%7Celement:geometry%7Ccolor:0xfdfcf8&style=feature:road.highway%7Celement:geometry%7Ccolor:0xf8c967&style=feature:road.highway%7Celement:geometry.stroke%7Ccolor:0xe9bc62&style=feature:road.highway.controlled_access%7Celement:geometry%7Ccolor:0xe98d58&style=feature:road.highway.controlled_access%7Celement:geometry.stroke%7Ccolor:0xdb8555&style=feature:road.local%7Celement:labels.text.fill%7Ccolor:0x806b63&style=feature:transit.line%7Celement:geometry%7Ccolor:0xdfd2ae&style=feature:transit.line%7Celement:labels.text.fill%7Ccolor:0x8f7d77&style=feature:transit.line%7Celement:labels.text.stroke%7Ccolor:0xebe3cd&style=feature:transit.station%7Celement:geometry%7Ccolor:0xdfd2ae&style=feature:water%7Celement:geometry.fill%7Ccolor:0xb9d3c2&style=feature:water%7Celement:labels.text.fill%7Ccolor:0x92998d',
                },
                Dark: {
                    id: 3,
                    label: 'Dark',
                    style: "[{'elementType':'geometry','stylers':[{'color':'#212121'}]},{'elementType':'labels.icon','stylers':[{'visibility':'off'}]},{'elementType':'labels.text.fill','stylers':[{'color':'#757575'}]},{'elementType':'labels.text.stroke','stylers':[{'color':'#212121'}]},{'featureType':'administrative','elementType':'geometry','stylers':[{'color':'#757575'}]},{'featureType':'administrative.country','elementType':'labels.text.fill','stylers':[{'color':'#9e9e9e'}]},{'featureType':'administrative.land_parcel','stylers':[{'visibility':'off'}]},{'featureType':'administrative.locality','elementType':'labels.text.fill','stylers':[{'color':'#bdbdbd'}]},{'featureType':'poi','elementType':'labels.text.fill','stylers':[{'color':'#757575'}]},{'featureType':'poi.park','elementType':'geometry','stylers':[{'color':'#181818'}]},{'featureType':'poi.park','elementType':'labels.text.fill','stylers':[{'color':'#616161'}]},{'featureType':'poi.park','elementType':'labels.text.stroke','stylers':[{'color':'#1b1b1b'}]},{'featureType':'road','elementType':'geometry.fill','stylers':[{'color':'#2c2c2c'}]},{'featureType':'road','elementType':'labels.text.fill','stylers':[{'color':'#8a8a8a'}]},{'featureType':'road.arterial','elementType':'geometry','stylers':[{'color':'#373737'}]},{'featureType':'road.highway','elementType':'geometry','stylers':[{'color':'#3c3c3c'}]},{'featureType':'road.highway.controlled_access','elementType':'geometry','stylers':[{'color':'#4e4e4e'}]},{'featureType':'road.local','elementType':'labels.text.fill','stylers':[{'color':'#616161'}]},{'featureType':'transit','elementType':'labels.text.fill','stylers':[{'color':'#757575'}]},{'featureType':'water','elementType':'geometry','stylers':[{'color':'#000000'}]},{'featureType':'water','elementType':'labels.text.fill','stylers':[{'color':'#3d3d3d'}]}]",
                    urlStyle: '&style=element:geometry%7Ccolor:0x212121&style=element:labels.icon%7Cvisibility:off&style=element:labels.text.fill%7Ccolor:0x757575&style=element:labels.text.stroke%7Ccolor:0x212121&style=feature:administrative%7Celement:geometry%7Ccolor:0x757575&style=feature:administrative.country%7Celement:labels.text.fill%7Ccolor:0x9e9e9e&style=feature:administrative.land_parcel%7Cvisibility:off&style=feature:administrative.locality%7Celement:labels.text.fill%7Ccolor:0xbdbdbd&style=feature:poi%7Celement:labels.text.fill%7Ccolor:0x757575&style=feature:poi.park%7Celement:geometry%7Ccolor:0x181818&style=feature:poi.park%7Celement:labels.text.fill%7Ccolor:0x616161&style=feature:poi.park%7Celement:labels.text.stroke%7Ccolor:0x1b1b1b&style=feature:road%7Celement:geometry.fill%7Ccolor:0x2c2c2c&style=feature:road%7Celement:labels.text.fill%7Ccolor:0x8a8a8a&style=feature:road.arterial%7Celement:geometry%7Ccolor:0x373737&style=feature:road.highway%7Celement:geometry%7Ccolor:0x3c3c3c&style=feature:road.highway.controlled_access%7Celement:geometry%7Ccolor:0x4e4e4e&style=feature:road.local%7Celement:labels.text.fill%7Ccolor:0x616161&style=feature:transit%7Celement:labels.text.fill%7Ccolor:0x757575&style=feature:water%7Celement:geometry%7Ccolor:0x000000&style=feature:water%7Celement:labels.text.fill%7Ccolor:0x3d3d3d',
                },
                Night: {
                    id: 4,
                    label: 'Night',
                    style: "[{'elementType':'geometry','stylers':[{'color':'#242f3e'}]},{'elementType':'labels.text.fill','stylers':[{'color':'#746855'}]},{'elementType':'labels.text.stroke','stylers':[{'color':'#242f3e'}]},{'featureType':'administrative.locality','elementType':'labels.text.fill','stylers':[{'color':'#d59563'}]},{'featureType':'poi','elementType':'labels.text.fill','stylers':[{'color':'#d59563'}]},{'featureType':'poi.park','elementType':'geometry','stylers':[{'color':'#263c3f'}]},{'featureType':'poi.park','elementType':'labels.text.fill','stylers':[{'color':'#6b9a76'}]},{'featureType':'road','elementType':'geometry','stylers':[{'color':'#38414e'}]},{'featureType':'road','elementType':'geometry.stroke','stylers':[{'color':'#212a37'}]},{'featureType':'road','elementType':'labels.text.fill','stylers':[{'color':'#9ca5b3'}]},{'featureType':'road.highway','elementType':'geometry','stylers':[{'color':'#746855'}]},{'featureType':'road.highway','elementType':'geometry.stroke','stylers':[{'color':'#1f2835'}]},{'featureType':'road.highway','elementType':'labels.text.fill','stylers':[{'color':'#f3d19c'}]},{'featureType':'transit','elementType':'geometry','stylers':[{'color':'#2f3948'}]},{'featureType':'transit.station','elementType':'labels.text.fill','stylers':[{'color':'#d59563'}]},{'featureType':'water','elementType':'geometry','stylers':[{'color':'#17263c'}]},{'featureType':'water','elementType':'labels.text.fill','stylers':[{'color':'#515c6d'}]},{'featureType':'water','elementType':'labels.text.stroke','stylers':[{'color':'#17263c'}]}]",
                    urlStyle: '&style=element:geometry%7Ccolor:0x242f3e&style=element:labels.text.fill%7Ccolor:0x746855&style=element:labels.text.stroke%7Ccolor:0x242f3e&style=feature:administrative.locality%7Celement:labels.text.fill%7Ccolor:0xd59563&style=feature:poi%7Celement:labels.text.fill%7Ccolor:0xd59563&style=feature:poi.park%7Celement:geometry%7Ccolor:0x263c3f&style=feature:poi.park%7Celement:labels.text.fill%7Ccolor:0x6b9a76&style=feature:road%7Celement:geometry%7Ccolor:0x38414e&style=feature:road%7Celement:geometry.stroke%7Ccolor:0x212a37&style=feature:road%7Celement:labels.text.fill%7Ccolor:0x9ca5b3&style=feature:road.highway%7Celement:geometry%7Ccolor:0x746855&style=feature:road.highway%7Celement:geometry.stroke%7Ccolor:0x1f2835&style=feature:road.highway%7Celement:labels.text.fill%7Ccolor:0xf3d19c&style=feature:transit%7Celement:geometry%7Ccolor:0x2f3948&style=feature:transit.station%7Celement:labels.text.fill%7Ccolor:0xd59563&style=feature:water%7Celement:geometry%7Ccolor:0x17263c&style=feature:water%7Celement:labels.text.fill%7Ccolor:0x515c6d&style=feature:water%7Celement:labels.text.stroke%7Ccolor:0x17263c',
                },
                Aubergine: {
                    id: 5,
                    label: 'Aubergine',
                    style: "[{'elementType':'geometry','stylers':[{'color':'#1d2c4d'}]},{'elementType':'labels.text.fill','stylers':[{'color':'#8ec3b9'}]},{'elementType':'labels.text.stroke','stylers':[{'color':'#1a3646'}]},{'featureType':'administrative.country','elementType':'geometry.stroke','stylers':[{'color':'#4b6878'}]},{'featureType':'administrative.land_parcel','elementType':'labels.text.fill','stylers':[{'color':'#64779e'}]},{'featureType':'administrative.province','elementType':'geometry.stroke','stylers':[{'color':'#4b6878'}]},{'featureType':'landscape.man_made','elementType':'geometry.stroke','stylers':[{'color':'#334e87'}]},{'featureType':'landscape.natural','elementType':'geometry','stylers':[{'color':'#023e58'}]},{'featureType':'poi','elementType':'geometry','stylers':[{'color':'#283d6a'}]},{'featureType':'poi','elementType':'labels.text.fill','stylers':[{'color':'#6f9ba5'}]},{'featureType':'poi','elementType':'labels.text.stroke','stylers':[{'color':'#1d2c4d'}]},{'featureType':'poi.park','elementType':'geometry.fill','stylers':[{'color':'#023e58'}]},{'featureType':'poi.park','elementType':'labels.text.fill','stylers':[{'color':'#3C7680'}]},{'featureType':'road','elementType':'geometry','stylers':[{'color':'#304a7d'}]},{'featureType':'road','elementType':'labels.text.fill','stylers':[{'color':'#98a5be'}]},{'featureType':'road','elementType':'labels.text.stroke','stylers':[{'color':'#1d2c4d'}]},{'featureType':'road.highway','elementType':'geometry','stylers':[{'color':'#2c6675'}]},{'featureType':'road.highway','elementType':'geometry.stroke','stylers':[{'color':'#255763'}]},{'featureType':'road.highway','elementType':'labels.text.fill','stylers':[{'color':'#b0d5ce'}]},{'featureType':'road.highway','elementType':'labels.text.stroke','stylers':[{'color':'#023e58'}]},{'featureType':'transit','elementType':'labels.text.fill','stylers':[{'color':'#98a5be'}]},{'featureType':'transit','elementType':'labels.text.stroke','stylers':[{'color':'#1d2c4d'}]},{'featureType':'transit.line','elementType':'geometry.fill','stylers':[{'color':'#283d6a'}]},{'featureType':'transit.station','elementType':'geometry','stylers':[{'color':'#3a4762'}]},{'featureType':'water','elementType':'geometry','stylers':[{'color':'#0e1626'}]},{'featureType':'water','elementType':'labels.text.fill','stylers':[{'color':'#4e6d70'}]}]",
                    urlStyle: '&style=element:geometry%7Ccolor:0x1d2c4d&style=element:labels.text.fill%7Ccolor:0x8ec3b9&style=element:labels.text.stroke%7Ccolor:0x1a3646&style=feature:administrative.country%7Celement:geometry.stroke%7Ccolor:0x4b6878&style=feature:administrative.land_parcel%7Celement:labels.text.fill%7Ccolor:0x64779e&style=feature:administrative.province%7Celement:geometry.stroke%7Ccolor:0x4b6878&style=feature:landscape.man_made%7Celement:geometry.stroke%7Ccolor:0x334e87&style=feature:landscape.natural%7Celement:geometry%7Ccolor:0x023e58&style=feature:poi%7Celement:geometry%7Ccolor:0x283d6a&style=feature:poi%7Celement:labels.text.fill%7Ccolor:0x6f9ba5&style=feature:poi%7Celement:labels.text.stroke%7Ccolor:0x1d2c4d&style=feature:poi.park%7Celement:geometry.fill%7Ccolor:0x023e58&style=feature:poi.park%7Celement:labels.text.fill%7Ccolor:0x3C7680&style=feature:road%7Celement:geometry%7Ccolor:0x304a7d&style=feature:road%7Celement:labels.text.fill%7Ccolor:0x98a5be&style=feature:road%7Celement:labels.text.stroke%7Ccolor:0x1d2c4d&style=feature:road.highway%7Celement:geometry%7Ccolor:0x2c6675&style=feature:road.highway%7Celement:geometry.stroke%7Ccolor:0x255763&style=feature:road.highway%7Celement:labels.text.fill%7Ccolor:0xb0d5ce&style=feature:road.highway%7Celement:labels.text.stroke%7Ccolor:0x023e58&style=feature:transit%7Celement:labels.text.fill%7Ccolor:0x98a5be&style=feature:transit%7Celement:labels.text.stroke%7Ccolor:0x1d2c4d&style=feature:transit.line%7Celement:geometry.fill%7Ccolor:0x283d6a&style=feature:transit.station%7Celement:geometry%7Ccolor:0x3a4762&style=feature:water%7Celement:geometry%7Ccolor:0x0e1626&style=feature:water%7Celement:labels.text.fill%7Ccolor:0x4e6d70',
                },
            };
            function GetStyleByStyleId(id) {
                const style = Google.Style[OSFramework.Maps.Enum.OSMap.Style[id - 1]].style.replace(/'/g, '"');
                return style !== '' ? JSON.parse(style) : '';
            }
            Google.GetStyleByStyleId = GetStyleByStyleId;
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Configuration;
            (function (Configuration) {
                var DrawingTools;
                (function (DrawingTools) {
                    class DrawConfig extends OSFramework.Maps.Configuration.AbstractConfiguration {
                        getProviderConfig() {
                            let provider = {
                                clickable: true,
                                draggable: this.allowDrag,
                            };
                            Object.keys(provider).forEach((key) => {
                                if (provider[key] === undefined)
                                    delete provider[key];
                            });
                            return provider;
                        }
                    }
                    DrawingTools.DrawConfig = DrawConfig;
                })(DrawingTools = Configuration.DrawingTools || (Configuration.DrawingTools = {}));
            })(Configuration = Google.Configuration || (Google.Configuration = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Configuration;
            (function (Configuration) {
                var DrawingTools;
                (function (DrawingTools) {
                    class DrawBasicShapeConfig extends DrawingTools.DrawConfig {
                        getProviderConfig() {
                            const configs = super.getProviderConfig();
                            let provider = Object.assign(Object.assign({}, configs), { editable: this.allowEdit, strokeColor: this.strokeColor, strokeOpacity: this.strokeOpacity, strokeWeight: this.strokeWeight });
                            Object.keys(provider).forEach((key) => {
                                if (provider[key] === undefined)
                                    delete provider[key];
                            });
                            return provider;
                        }
                    }
                    DrawingTools.DrawBasicShapeConfig = DrawBasicShapeConfig;
                })(DrawingTools = Configuration.DrawingTools || (Configuration.DrawingTools = {}));
            })(Configuration = Google.Configuration || (Google.Configuration = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Configuration;
            (function (Configuration) {
                var DrawingTools;
                (function (DrawingTools) {
                    class DrawFilledShapeConfig extends DrawingTools.DrawBasicShapeConfig {
                        getProviderConfig() {
                            const configs = super.getProviderConfig();
                            let provider = Object.assign(Object.assign({}, configs), { fillColor: this.fillColor, fillOpacity: this.fillOpacity });
                            Object.keys(provider).forEach((key) => {
                                if (provider[key] === undefined)
                                    delete provider[key];
                            });
                            return provider;
                        }
                    }
                    DrawingTools.DrawFilledShapeConfig = DrawFilledShapeConfig;
                })(DrawingTools = Configuration.DrawingTools || (Configuration.DrawingTools = {}));
            })(Configuration = Google.Configuration || (Google.Configuration = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Configuration;
            (function (Configuration) {
                var DrawingTools;
                (function (DrawingTools) {
                    class DrawMarkerConfig extends DrawingTools.DrawConfig {
                        getProviderConfig() {
                            const provider = super.getProviderConfig();
                            provider.icon = this.iconUrl;
                            provider.iconUrl = this.iconUrl;
                            Object.keys(provider).forEach((key) => {
                                if (provider[key] === undefined)
                                    delete provider[key];
                            });
                            return provider;
                        }
                    }
                    DrawingTools.DrawMarkerConfig = DrawMarkerConfig;
                })(DrawingTools = Configuration.DrawingTools || (Configuration.DrawingTools = {}));
            })(Configuration = Google.Configuration || (Google.Configuration = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Configuration;
            (function (Configuration) {
                var DrawingTools;
                (function (DrawingTools) {
                    class DrawingToolsConfig extends OSFramework.Maps.Configuration.AbstractConfiguration {
                        getProviderConfig() {
                            return {
                                position: this.position,
                            };
                        }
                    }
                    DrawingTools.DrawingToolsConfig = DrawingToolsConfig;
                })(DrawingTools = Configuration.DrawingTools || (Configuration.DrawingTools = {}));
            })(Configuration = Google.Configuration || (Google.Configuration = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Configuration;
            (function (Configuration) {
                var FileLayer;
                (function (FileLayer) {
                    class FileLayerConfig extends OSFramework.Maps.Configuration.AbstractConfiguration {
                        getProviderConfig() {
                            let provider = {
                                clickable: true,
                                url: this.layerUrl,
                                preserveViewport: this.preserveViewport,
                                suppressInfoWindows: this.suppressPopups,
                            };
                            Object.keys(provider).forEach((key) => {
                                if (provider[key] === undefined) {
                                    delete provider[key];
                                }
                            });
                            return provider;
                        }
                    }
                    FileLayer.FileLayerConfig = FileLayerConfig;
                })(FileLayer = Configuration.FileLayer || (Configuration.FileLayer = {}));
            })(Configuration = Google.Configuration || (Google.Configuration = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Configuration;
            (function (Configuration) {
                var HeatmapLayer;
                (function (HeatmapLayer) {
                    class HeatmapLayerConfig extends OSFramework.Maps.Configuration.AbstractConfiguration {
                        getProviderConfig() {
                            let provider = {
                                points: this.points,
                                dissipate: this.dissipateOnZoom,
                                gradient: this.gradient,
                                maxIntensity: this.maxIntensity,
                                opacity: this.opacity,
                                radius: this.radius,
                            };
                            Object.keys(provider).forEach((key) => {
                                if (provider[key] === undefined) {
                                    delete provider[key];
                                }
                            });
                            return provider;
                        }
                    }
                    HeatmapLayer.HeatmapLayerConfig = HeatmapLayerConfig;
                })(HeatmapLayer = Configuration.HeatmapLayer || (Configuration.HeatmapLayer = {}));
            })(Configuration = Google.Configuration || (Google.Configuration = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Configuration;
            (function (Configuration) {
                var Marker;
                (function (Marker) {
                    class DeprecatedGoogleMarkerConfig extends OSFramework.Maps.Configuration.AbstractConfiguration {
                        getProviderConfig() {
                            const provider = {
                                draggable: this.allowDrag,
                                icon: this.iconUrl,
                                label: this.label,
                                location: this.location,
                                title: this.title,
                            };
                            Object.keys(provider).forEach((key) => {
                                if (provider[key] === undefined)
                                    delete provider[key];
                            });
                            return provider;
                        }
                    }
                    Marker.DeprecatedGoogleMarkerConfig = DeprecatedGoogleMarkerConfig;
                })(Marker = Configuration.Marker || (Configuration.Marker = {}));
            })(Configuration = Google.Configuration || (Google.Configuration = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Configuration;
            (function (Configuration) {
                var Marker;
                (function (Marker) {
                    class GoogleMarkerConfig extends OSFramework.Maps.Configuration.AbstractConfiguration {
                        getProviderConfig() {
                            const provider = {
                                gmpDraggable: this.allowDrag,
                                title: this.title,
                            };
                            Object.keys(provider).forEach((key) => {
                                if (provider[key] === undefined)
                                    delete provider[key];
                            });
                            return provider;
                        }
                    }
                    Marker.GoogleMarkerConfig = GoogleMarkerConfig;
                })(Marker = Configuration.Marker || (Configuration.Marker = {}));
            })(Configuration = Google.Configuration || (Google.Configuration = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Configuration;
            (function (Configuration) {
                var MarkerClusterer;
                (function (MarkerClusterer) {
                    class MarkerClustererConfig extends OSFramework.Maps.Configuration.AbstractConfiguration {
                        getProviderConfig() {
                            return {};
                        }
                    }
                    MarkerClusterer.MarkerClustererConfig = MarkerClustererConfig;
                })(MarkerClusterer = Configuration.MarkerClusterer || (Configuration.MarkerClusterer = {}));
            })(Configuration = Google.Configuration || (Google.Configuration = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Configuration;
            (function (Configuration) {
                var OSMap;
                (function (OSMap) {
                    class GoogleMapConfig extends OSFramework.Maps.Configuration.AbstractConfiguration {
                        getProviderConfig() {
                            let mapStyleId = this.mapStyleId;
                            let style = this.style;
                            if (this.useAdvancedMarkers === false) {
                                mapStyleId = undefined;
                            }
                            else {
                                const styleId = this.style - 1;
                                if (styleId === OSFramework.Maps.Enum.OSMap.Style.Standard) {
                                    style = undefined;
                                }
                            }
                            const provider = {
                                center: this.center,
                                mapId: mapStyleId,
                                mapTypeId: this.type,
                                styles: style,
                                zoom: this.zoom,
                            };
                            Object.keys(provider).forEach((key) => {
                                if (provider[key] === undefined) {
                                    delete provider[key];
                                }
                            });
                            return provider;
                        }
                    }
                    OSMap.GoogleMapConfig = GoogleMapConfig;
                })(OSMap = Configuration.OSMap || (Configuration.OSMap = {}));
            })(Configuration = Google.Configuration || (Google.Configuration = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Configuration;
            (function (Configuration) {
                var OSMap;
                (function (OSMap) {
                    class GoogleStaticMapConfig extends OSFramework.Maps.Configuration.AbstractConfiguration {
                        getProviderConfig() {
                            const provider = {
                                center: this.center,
                                zoom: this.zoom,
                                mapTypeId: this.type,
                            };
                            Object.keys(provider).forEach((key) => {
                                if (provider[key] === undefined) {
                                    delete provider[key];
                                }
                            });
                            return provider;
                        }
                    }
                    OSMap.GoogleStaticMapConfig = GoogleStaticMapConfig;
                })(OSMap = Configuration.OSMap || (Configuration.OSMap = {}));
            })(Configuration = Google.Configuration || (Google.Configuration = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Configuration;
            (function (Configuration) {
                var SearchPlaces;
                (function (SearchPlaces) {
                    class AbstractSearchPlacesConfig extends OSFramework.Maps.Configuration.AbstractConfiguration {
                    }
                    SearchPlaces.AbstractSearchPlacesConfig = AbstractSearchPlacesConfig;
                })(SearchPlaces = Configuration.SearchPlaces || (Configuration.SearchPlaces = {}));
            })(Configuration = Google.Configuration || (Google.Configuration = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Configuration;
            (function (Configuration) {
                var SearchPlaces;
                (function (SearchPlaces) {
                    class SearchPlacesConfig extends SearchPlaces.AbstractSearchPlacesConfig {
                        getProviderConfig() {
                            var _a;
                            let provider = {
                                locationBias: this.searchArea
                                    ? {
                                        east: Number(this.searchArea.east),
                                        north: Number(this.searchArea.north),
                                        south: Number(this.searchArea.south),
                                        west: Number(this.searchArea.west),
                                    }
                                    : undefined,
                                includedRegionCodes: (_a = this.countries) !== null && _a !== void 0 ? _a : undefined,
                                includedPrimaryTypes: this.searchType
                                    ?
                                        [Google.SearchPlaces.SearchTypes[this.searchType]]
                                    : undefined,
                            };
                            Object.keys(provider).forEach((key) => {
                                if (provider[key] === undefined) {
                                    delete provider[key];
                                }
                            });
                            return provider;
                        }
                    }
                    SearchPlaces.SearchPlacesConfig = SearchPlacesConfig;
                })(SearchPlaces = Configuration.SearchPlaces || (Configuration.SearchPlaces = {}));
            })(Configuration = Google.Configuration || (Google.Configuration = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Configuration;
            (function (Configuration) {
                var SearchPlaces;
                (function (SearchPlaces) {
                    class SearchPlacesLegacyConfig extends SearchPlaces.AbstractSearchPlacesConfig {
                        getProviderConfig() {
                            let provider = {
                                bounds: this.searchArea,
                                strictBounds: !!this.searchArea,
                                componentRestrictions: this.countries ? { country: this.countries } : undefined,
                                types: this.searchType
                                    ?
                                        [Google.SearchPlaces.SearchTypes[this.searchType]]
                                    : undefined,
                            };
                            Object.keys(provider).forEach((key) => {
                                if (provider[key] === undefined) {
                                    delete provider[key];
                                }
                            });
                            return provider;
                        }
                    }
                    SearchPlaces.SearchPlacesLegacyConfig = SearchPlacesLegacyConfig;
                })(SearchPlaces = Configuration.SearchPlaces || (Configuration.SearchPlaces = {}));
            })(Configuration = Google.Configuration || (Google.Configuration = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Configuration;
            (function (Configuration) {
                var Shape;
                (function (Shape) {
                    class BasicShapeConfig extends OSFramework.Maps.Configuration.AbstractConfiguration {
                        getProviderConfig() {
                            let provider = {
                                clickable: true,
                                draggable: this.allowDrag,
                                editable: this.allowEdit,
                                strokeColor: this.strokeColor,
                                strokeOpacity: this.strokeOpacity,
                                strokeWeight: this.strokeWeight,
                            };
                            Object.keys(provider).forEach((key) => {
                                if (provider[key] === undefined)
                                    delete provider[key];
                            });
                            return provider;
                        }
                    }
                    Shape.BasicShapeConfig = BasicShapeConfig;
                })(Shape = Configuration.Shape || (Configuration.Shape = {}));
            })(Configuration = Google.Configuration || (Google.Configuration = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Configuration;
            (function (Configuration) {
                var Shape;
                (function (Shape) {
                    class FilledShapeConfig extends Shape.BasicShapeConfig {
                        getProviderConfig() {
                            const provider_configs = super.getProviderConfig();
                            provider_configs.fillColor = this.fillColor;
                            provider_configs.fillOpacity = this.fillOpacity;
                            return provider_configs;
                        }
                    }
                    Shape.FilledShapeConfig = FilledShapeConfig;
                })(Shape = Configuration.Shape || (Configuration.Shape = {}));
            })(Configuration = Google.Configuration || (Google.Configuration = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Configuration;
            (function (Configuration) {
                var Shape;
                (function (Shape) {
                    class CircleShapeConfig extends Shape.FilledShapeConfig {
                        getProviderConfig() {
                            const provider = super.getProviderConfig();
                            provider.radius = this.radius;
                            delete provider.locations;
                            return provider;
                        }
                    }
                    Shape.CircleShapeConfig = CircleShapeConfig;
                })(Shape = Configuration.Shape || (Configuration.Shape = {}));
            })(Configuration = Google.Configuration || (Google.Configuration = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Configuration;
            (function (Configuration) {
                var Shape;
                (function (Shape) {
                    class RectangleShapeConfig extends Shape.FilledShapeConfig {
                        getProviderConfig() {
                            const provider = super.getProviderConfig();
                            delete provider.locations;
                            return provider;
                        }
                    }
                    Shape.RectangleShapeConfig = RectangleShapeConfig;
                })(Shape = Configuration.Shape || (Configuration.Shape = {}));
            })(Configuration = Google.Configuration || (Google.Configuration = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Constants;
            (function (Constants) {
                Constants.coordinateValidator = /^-?\d+(?:\.\d+)? ?, ?-?\d+(?:\.\d+)?$/;
                Constants.googleMapsLocalStorageVersionKey = 'gmVersion';
                Constants.googleMapsAuthFailure = 'gm_authFailure';
                Constants.googleMapsScript = 'google-maps-script';
                Constants.gradientHeatmapColors = [
                    'rgba(102, 255, 0, 0)',
                    'rgba(102, 255, 0, 1)',
                    'rgba(147, 255, 0, 1)',
                    'rgba(193, 255, 0, 1)',
                    'rgba(238, 255, 0, 1)',
                    'rgba(244, 227, 0, 1)',
                    'rgba(249, 198, 0, 1)',
                    'rgba(255, 170, 0, 1)',
                    'rgba(255, 113, 0, 1)',
                    'rgba(255, 57, 0, 1)',
                    'rgba(255, 0, 0, 1)',
                ];
                Constants.googleMapsApiURL = 'https://maps.googleapis.com/maps/api';
                Constants.googleMapsRoutesApiURL = 'https://routes.googleapis.com/directions/v2:computeRoutes';
                Constants.googleMapsApiMap = `${Constants.googleMapsApiURL}/js`;
                Constants.googleMapsApiStaticMap = `${Constants.googleMapsApiURL}/staticmap`;
                Constants.GoogleMapsRouteOptions = 'routes.duration,routes.distanceMeters,routes.polyline.encodedPolyline';
                Constants.GoogleMapsLibraries = 'drawing,visualization,places,marker,geometry';
                Constants.checkGoogleMapsLibrariesMaxAttempts = 25;
                Constants.googleMapsVersion = '3.61';
            })(Constants = Google.Constants || (Google.Constants = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Constants;
            (function (Constants) {
                var DrawingTools;
                (function (DrawingTools) {
                    DrawingTools.Events = [
                        'circlecomplete',
                        'markercomplete',
                        'polylinecomplete',
                        'polygoncomplete',
                        'rectanglecomplete',
                    ];
                })(DrawingTools = Constants.DrawingTools || (Constants.DrawingTools = {}));
            })(Constants = Google.Constants || (Google.Constants = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Constants;
            (function (Constants) {
                var Marker;
                (function (Marker) {
                    let DeprecatedProviderEventNames;
                    (function (DeprecatedProviderEventNames) {
                        DeprecatedProviderEventNames["changed"] = "animation_changed";
                        DeprecatedProviderEventNames["click"] = "click";
                        DeprecatedProviderEventNames["clickable_changed"] = "clickable_changed";
                        DeprecatedProviderEventNames["contextmenu"] = "contextmenu";
                        DeprecatedProviderEventNames["cursor_changed"] = "cursor_changed";
                        DeprecatedProviderEventNames["dblclick"] = "dblclick";
                        DeprecatedProviderEventNames["drag"] = "drag";
                        DeprecatedProviderEventNames["dragend"] = "dragend";
                        DeprecatedProviderEventNames["draggable_changed"] = "draggable_changed";
                        DeprecatedProviderEventNames["dragstart"] = "dragstart";
                        DeprecatedProviderEventNames["flat_changed"] = "flat_changed";
                        DeprecatedProviderEventNames["icon_changed"] = "icon_changed";
                        DeprecatedProviderEventNames["mousedown"] = "mousedown";
                        DeprecatedProviderEventNames["mouseout"] = "mouseout";
                        DeprecatedProviderEventNames["mouseover"] = "mouseover";
                        DeprecatedProviderEventNames["mouseup"] = "mouseup";
                        DeprecatedProviderEventNames["position_changed"] = "position_changed";
                        DeprecatedProviderEventNames["rightclick"] = "rightclick";
                        DeprecatedProviderEventNames["shape_changed"] = "shape_changed";
                        DeprecatedProviderEventNames["title_changed"] = "title_changed";
                        DeprecatedProviderEventNames["visible_changed"] = "visible_changed";
                        DeprecatedProviderEventNames["zindex_changed"] = "zindex_changed";
                    })(DeprecatedProviderEventNames = Marker.DeprecatedProviderEventNames || (Marker.DeprecatedProviderEventNames = {}));
                })(Marker = Constants.Marker || (Constants.Marker = {}));
            })(Constants = Google.Constants || (Google.Constants = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Constants;
            (function (Constants) {
                var Marker;
                (function (Marker) {
                    let ProviderEventNames;
                    (function (ProviderEventNames) {
                        ProviderEventNames["click"] = "click";
                        ProviderEventNames["drag"] = "drag";
                        ProviderEventNames["dragend"] = "dragend";
                        ProviderEventNames["dragstart"] = "dragstart";
                    })(ProviderEventNames = Marker.ProviderEventNames || (Marker.ProviderEventNames = {}));
                    let ProviderEventNamesHtml;
                    (function (ProviderEventNamesHtml) {
                        ProviderEventNamesHtml["auxclick"] = "auxclick";
                        ProviderEventNamesHtml["contextmenu"] = "auxclick";
                        ProviderEventNamesHtml["dblclick"] = "dblclick";
                        ProviderEventNamesHtml["mousedown"] = "mousedown";
                        ProviderEventNamesHtml["mouseout"] = "mouseout";
                        ProviderEventNamesHtml["mouseover"] = "mouseover";
                        ProviderEventNamesHtml["mouseup"] = "mouseup";
                        ProviderEventNamesHtml["rightclick"] = "auxclick";
                    })(ProviderEventNamesHtml = Marker.ProviderEventNamesHtml || (Marker.ProviderEventNamesHtml = {}));
                })(Marker = Constants.Marker || (Constants.Marker = {}));
            })(Constants = Google.Constants || (Google.Constants = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Constants;
            (function (Constants) {
                var OSMap;
                (function (OSMap) {
                    let ProviderEventNames;
                    (function (ProviderEventNames) {
                        ProviderEventNames["bounds_changed"] = "bounds_changed";
                        ProviderEventNames["center_changed"] = "center_changed";
                        ProviderEventNames["click"] = "click";
                        ProviderEventNames["contextmenu"] = "contextmenu";
                        ProviderEventNames["dblclick"] = "dblclick";
                        ProviderEventNames["drag"] = "drag";
                        ProviderEventNames["dragend"] = "dragend";
                        ProviderEventNames["dragstart"] = "dragstart";
                        ProviderEventNames["heading_changed"] = "heading_changed";
                        ProviderEventNames["idle"] = "idle";
                        ProviderEventNames["maptypeid_changed"] = "maptypeid_changed";
                        ProviderEventNames["mousemove"] = "mousemove";
                        ProviderEventNames["mouseout"] = "mouseout";
                        ProviderEventNames["mouseover"] = "mouseover";
                        ProviderEventNames["projection_changed"] = "projection_changed";
                        ProviderEventNames["resize"] = "resize";
                        ProviderEventNames["rightclick"] = "rightclick";
                        ProviderEventNames["tilesloaded"] = "tilesloaded";
                        ProviderEventNames["tilt_changed"] = "tilt_changed";
                        ProviderEventNames["zoom_changed"] = "zoom_changed";
                    })(ProviderEventNames = OSMap.ProviderEventNames || (OSMap.ProviderEventNames = {}));
                })(OSMap = Constants.OSMap || (Constants.OSMap = {}));
            })(Constants = Google.Constants || (Google.Constants = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Constants;
            (function (Constants) {
                var SearchPlaces;
                (function (SearchPlaces) {
                    let EventsLegacy;
                    (function (EventsLegacy) {
                        EventsLegacy["OnPlaceSelect"] = "place_changed";
                    })(EventsLegacy = SearchPlaces.EventsLegacy || (SearchPlaces.EventsLegacy = {}));
                    let Events;
                    (function (Events) {
                        Events["OnPlaceSelect"] = "gmp-select";
                    })(Events = SearchPlaces.Events || (SearchPlaces.Events = {}));
                })(SearchPlaces = Constants.SearchPlaces || (Constants.SearchPlaces = {}));
            })(Constants = Google.Constants || (Google.Constants = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Constants;
            (function (Constants) {
                var Shape;
                (function (Shape) {
                    Shape.Events = [
                        'click',
                        'contextmenu',
                        'dblclick',
                        'drag',
                        'dragend',
                        'dragstart',
                        'mousedown',
                        'mouseout',
                        'mouseover',
                        'mouseup',
                        'position_changed',
                        'rightclick',
                        'insert_at',
                        'remove_at',
                        'set_at',
                        'radius_changed',
                        'center_changed',
                        'shape_changed',
                    ];
                    Shape.ProviderPolyshapeEvents = ['insert_at', 'remove_at', 'set_at'];
                    Shape.ProviderCircleEvents = ['radius_changed', 'center_changed'];
                    Shape.ProviderRectangleEvents = ['bounds_changed'];
                    Shape.ProviderSpecialEvents = [
                        'shape_changed',
                        ...Shape.ProviderPolyshapeEvents,
                        ...Shape.ProviderCircleEvents,
                        ...Shape.ProviderRectangleEvents,
                    ];
                })(Shape = Constants.Shape || (Constants.Shape = {}));
            })(Constants = Google.Constants || (Google.Constants = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var DrawingTools;
            (function (DrawingTools) {
                class AbstractProviderTool extends OSFramework.Maps.DrawingTools.AbstractTool {
                    _addCompletedEventHandler(element) {
                        const uniqueId = OSFramework.Maps.Helper.GenerateUniqueId();
                        this.newElm = this.createElement(uniqueId, element, this.config);
                        this.drawingTools.createdElements.push(this.newElm);
                        const coordinates = this.getCoordinates();
                        const location = this.getLocation();
                        this.triggerOnDrawingChangeEvent(uniqueId, true, coordinates, location);
                        element.setMap(null);
                    }
                    triggerOnDrawingChangeEvent(uniqueId, isNewElement, coordinates, location) {
                        this.drawingTools.drawingToolsEvents.trigger(OSFramework.Maps.Event.DrawingTools.DrawingToolsEventType.ProviderEvent, this.completedToolEventName, { uniqueId, isNewElement, coordinates, location });
                    }
                    addCompletedEvent() {
                        this.drawingTools.provider.addListener(this.completedToolEventName, this._addCompletedEventHandler.bind(this));
                    }
                    build() {
                        super.build();
                        this.options = this.getProviderConfig();
                        this.finishBuild();
                    }
                    changeProperty(propertyName, value) {
                        const propValue = OSFramework.Maps.Enum.OS_Config_Shape[propertyName];
                        super.changeProperty(propertyName, value);
                        if (this.drawingTools.isReady) {
                            if (propValue === OSFramework.Maps.Enum.OS_Config_Shape.allowDrag) {
                                this.options = { draggable: value };
                            }
                        }
                    }
                    dispose() {
                        super.dispose();
                    }
                }
                DrawingTools.AbstractProviderTool = AbstractProviderTool;
            })(DrawingTools = Google.DrawingTools || (Google.DrawingTools = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var DrawingTools;
            (function (DrawingTools) {
                class AbstractDrawShape extends DrawingTools.AbstractProviderTool {
                    constructor(map, drawingTools, drawingToolsId, type, configs) {
                        super(map, drawingTools, drawingToolsId, type, configs);
                    }
                    _setOnChangeEvent(_shape) {
                        _shape.shapeEvents.addHandler(OSFramework.Maps.Helper.Constants.shapeChangedEvent, (mapId, shapeId, eventName, shapeCoordinates) => {
                            const dtParams = {
                                uniqueId: _shape.uniqueId,
                                isNewElement: false,
                                location: JSON.stringify(shapeCoordinates.location),
                                coordinates: JSON.stringify(shapeCoordinates.coordinates),
                            };
                            this.drawingTools.drawingToolsEvents.trigger(OSFramework.Maps.Event.DrawingTools.DrawingToolsEventType.ProviderEvent, this.completedToolEventName, dtParams);
                        });
                    }
                    createShapeElement(uniqueId, type, configs) {
                        const _shape = Google.Shape.ShapeFactory.MakeShape(this.map, uniqueId, type, configs);
                        this._setOnChangeEvent(_shape);
                        this.map.addShape(_shape);
                        return _shape;
                    }
                    build() {
                        super.build();
                    }
                    changeProperty(propertyName, value) {
                        const propValue = OSFramework.Maps.Enum.OS_Config_Shape[propertyName];
                        super.changeProperty(propertyName, value);
                        if (this.drawingTools.isReady) {
                            switch (propValue) {
                                case OSFramework.Maps.Enum.OS_Config_Shape.allowEdit:
                                    this.options = { editable: value };
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Shape.strokeOpacity:
                                    this.options = { strokeOpacity: value };
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Shape.strokeColor:
                                    this.options = { strokeColor: value };
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Shape.strokeWeight:
                                    this.options = { strokeWeight: value };
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Shape.fillOpacity:
                                    this.options = { fillOpacity: value };
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Shape.fillColor:
                                    this.options = { fillColor: value };
                                    return;
                            }
                        }
                    }
                }
                DrawingTools.AbstractDrawShape = AbstractDrawShape;
            })(DrawingTools = Google.DrawingTools || (Google.DrawingTools = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var DrawingTools;
            (function (DrawingTools) {
                class AbstractDrawPolyshape extends DrawingTools.AbstractDrawShape {
                    constructor(map, drawingTools, drawingToolsId, type, configs) {
                        super(map, drawingTools, drawingToolsId, type, configs);
                    }
                    createConfigsElement(shape, configs) {
                        this._locations = shape
                            .getPath()
                            .getArray()
                            .map((elm) => `${elm.lat()},${elm.lng()}`);
                        const finalConfigs = Object.assign(Object.assign({}, configs), { locations: JSON.stringify(this._locations) });
                        return finalConfigs;
                    }
                    getCoordinates() {
                        const locations = JSON.parse(this.newElm.config.locations);
                        const locationsArray = [];
                        for (const coord of locations) {
                            locationsArray.push(coord.toString().split(','));
                        }
                        const finalLocations = locationsArray.map((coords) => {
                            return { Lat: coords[0], Lng: coords[1] };
                        });
                        return JSON.stringify(finalLocations);
                    }
                    getLocation() {
                        return JSON.stringify(this._locations);
                    }
                }
                DrawingTools.AbstractDrawPolyshape = AbstractDrawPolyshape;
            })(DrawingTools = Google.DrawingTools || (Google.DrawingTools = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var DrawingTools;
            (function (DrawingTools) {
                class DrawCircle extends DrawingTools.AbstractDrawShape {
                    constructor(map, drawingTools, drawingToolsId, type, configs) {
                        super(map, drawingTools, drawingToolsId, type, new Google.Configuration.DrawingTools.DrawFilledShapeConfig(configs));
                    }
                    _createConfigsElement(shape, configs) {
                        const providerCenter = shape.getCenter();
                        const center = `${providerCenter.lat()},${providerCenter.lng()}`;
                        const radius = shape.getRadius();
                        const finalConfigs = Object.assign(Object.assign({}, configs), { center,
                            radius });
                        return finalConfigs;
                    }
                    get completedToolEventName() {
                        return OSFramework.Maps.Helper.Constants.drawingCircleCompleted;
                    }
                    get options() {
                        return this.drawingTools.provider.get('circleOptions');
                    }
                    set options(options) {
                        const allOptions = Object.assign(Object.assign({}, this.options), options);
                        this.drawingTools.provider.setOptions({
                            circleOptions: allOptions,
                        });
                    }
                    createElement(uniqueId, shape, configs) {
                        const finalConfigs = this._createConfigsElement(shape, configs);
                        return super.createShapeElement(uniqueId, OSFramework.Maps.Enum.ShapeType.Circle, finalConfigs);
                    }
                    getCoordinates() {
                        const locations = this.newElm.config.center;
                        let coordinatesArray = [];
                        coordinatesArray = locations.split(',');
                        const coordinates = {
                            Lat: coordinatesArray[0],
                            Lng: coordinatesArray[1],
                        };
                        return JSON.stringify(coordinates);
                    }
                    getLocation() {
                        const location = this.newElm.config.center;
                        const radius = this.newElm.config.radius;
                        const locationConfig = { location: location, radius: radius };
                        return JSON.stringify(locationConfig);
                    }
                }
                DrawingTools.DrawCircle = DrawCircle;
            })(DrawingTools = Google.DrawingTools || (Google.DrawingTools = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var DrawingTools;
            (function (DrawingTools) {
                class DrawMarker extends DrawingTools.AbstractProviderTool {
                    constructor(map, drawingTools, drawingToolsId, type, configs) {
                        super(map, drawingTools, drawingToolsId, type, new Google.Configuration.DrawingTools.DrawMarkerConfig(configs));
                        this._latLng = {
                            lat: undefined,
                            lng: undefined,
                        };
                    }
                    _setOnChangeEvent(_marker) {
                        _marker.markerEvents.addHandler('dragend', () => {
                            const _latitude = Google.Helper.Conversions.GetCoordinateValue(_marker.getPosition().lat);
                            const _longitude = Google.Helper.Conversions.GetCoordinateValue(_marker.getPosition().lng);
                            this.triggerOnDrawingChangeEvent(_marker.uniqueId, false, JSON.stringify({
                                Lat: _latitude,
                                Lng: _longitude,
                            }), `${_latitude}, ${_longitude}`);
                        });
                    }
                    get completedToolEventName() {
                        return OSFramework.Maps.Helper.Constants.drawingMarkerCompleted;
                    }
                    get options() {
                        return this.drawingTools.provider.get('markerOptions');
                    }
                    set options(options) {
                        const allOptions = Object.assign(Object.assign({}, this.options), options);
                        this.drawingTools.provider.setOptions({
                            markerOptions: allOptions,
                        });
                    }
                    createElement(uniqueId, marker, configs) {
                        let position = undefined;
                        if (Google.Helper.TypeChecker.IsAdvancedMarker(marker)) {
                            position = marker.position;
                        }
                        else {
                            position = marker.getPosition();
                        }
                        const _latitude = Google.Helper.Conversions.GetCoordinateValue(position.lat);
                        const _longitude = Google.Helper.Conversions.GetCoordinateValue(position.lng);
                        const location = `${_latitude},${_longitude}`;
                        this._latLng.lat = _latitude;
                        this._latLng.lng = _longitude;
                        const finalConfigs = Object.assign(Object.assign({}, configs), { location });
                        const _marker = Google.Marker.MarkerFactory.MakeMarker(this.map, uniqueId, OSFramework.Maps.Enum.MarkerType.Marker, finalConfigs);
                        this._setOnChangeEvent(_marker);
                        this.map.addMarker(_marker);
                        return _marker;
                    }
                    getCoordinates() {
                        const locations = this.newElm.config.location;
                        let coordinatesArray = [];
                        coordinatesArray = locations.split(',');
                        const coordinates = {
                            Lat: coordinatesArray[0],
                            Lng: coordinatesArray[1],
                        };
                        return JSON.stringify(coordinates);
                    }
                    getLocation() {
                        return this.newElm.config.location;
                    }
                    build() {
                        super.build();
                    }
                    changeProperty(propertyName, value) {
                        const propValue = OSFramework.Maps.Enum.OS_Config_Marker[propertyName];
                        super.changeProperty(propertyName, value);
                        if (this.drawingTools.isReady) {
                            if (propValue === OSFramework.Maps.Enum.OS_Config_Marker.iconUrl) {
                                this.options = { icon: value };
                            }
                        }
                    }
                }
                DrawingTools.DrawMarker = DrawMarker;
            })(DrawingTools = Google.DrawingTools || (Google.DrawingTools = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var DrawingTools;
            (function (DrawingTools) {
                class DrawPolygon extends DrawingTools.AbstractDrawPolyshape {
                    constructor(map, drawingTools, drawingToolsId, type, configs) {
                        super(map, drawingTools, drawingToolsId, type, new Google.Configuration.DrawingTools.DrawFilledShapeConfig(configs));
                    }
                    get completedToolEventName() {
                        return OSFramework.Maps.Helper.Constants.drawingPolygonCompleted;
                    }
                    get options() {
                        return this.drawingTools.provider.get('polygonOptions');
                    }
                    set options(options) {
                        const allOptions = Object.assign(Object.assign({}, this.options), options);
                        this.drawingTools.provider.setOptions({
                            polygonOptions: allOptions,
                        });
                    }
                    createElement(uniqueId, shape, configs) {
                        const finalConfigs = super.createConfigsElement(shape, configs);
                        return super.createShapeElement(uniqueId, OSFramework.Maps.Enum.ShapeType.Polygon, finalConfigs);
                    }
                }
                DrawingTools.DrawPolygon = DrawPolygon;
            })(DrawingTools = Google.DrawingTools || (Google.DrawingTools = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var DrawingTools;
            (function (DrawingTools) {
                class DrawPolyline extends DrawingTools.AbstractDrawPolyshape {
                    constructor(map, drawingTools, drawingToolsId, type, configs) {
                        super(map, drawingTools, drawingToolsId, type, new Google.Configuration.DrawingTools.DrawBasicShapeConfig(configs));
                    }
                    get completedToolEventName() {
                        return OSFramework.Maps.Helper.Constants.drawingPolylineCompleted;
                    }
                    get options() {
                        return this.drawingTools.provider.get('polylineOptions');
                    }
                    set options(options) {
                        const allOptions = Object.assign(Object.assign({}, this.options), options);
                        this.drawingTools.provider.setOptions({
                            polylineOptions: allOptions,
                        });
                    }
                    createElement(uniqueId, shape, configs) {
                        const finalConfigs = super.createConfigsElement(shape, configs);
                        return super.createShapeElement(uniqueId, OSFramework.Maps.Enum.ShapeType.Polyline, finalConfigs);
                    }
                }
                DrawingTools.DrawPolyline = DrawPolyline;
            })(DrawingTools = Google.DrawingTools || (Google.DrawingTools = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var DrawingTools;
            (function (DrawingTools) {
                class DrawRectangle extends DrawingTools.AbstractDrawShape {
                    constructor(map, drawingTools, drawingToolsId, type, configs) {
                        super(map, drawingTools, drawingToolsId, type, new Google.Configuration.DrawingTools.DrawFilledShapeConfig(configs));
                    }
                    _createConfigsElement(shape, configs) {
                        const providerBounds = shape.getBounds();
                        const bounds = {
                            north: providerBounds.getNorthEast().lat().toString(),
                            south: providerBounds.getSouthWest().lat().toString(),
                            west: providerBounds.getSouthWest().lng().toString(),
                            east: providerBounds.getNorthEast().lng().toString(),
                        };
                        const finalConfigs = Object.assign(Object.assign({}, configs), { bounds: JSON.stringify(bounds) });
                        return finalConfigs;
                    }
                    get completedToolEventName() {
                        return OSFramework.Maps.Helper.Constants.drawingRectangleCompleted;
                    }
                    get options() {
                        return this.drawingTools.provider.get('rectangleOptions');
                    }
                    set options(options) {
                        const allOptions = Object.assign(Object.assign({}, this.options), options);
                        this.drawingTools.provider.setOptions({
                            rectangleOptions: allOptions,
                        });
                    }
                    createElement(uniqueId, shape, configs) {
                        const finalConfigs = this._createConfigsElement(shape, configs);
                        return super.createShapeElement(uniqueId, OSFramework.Maps.Enum.ShapeType.Rectangle, finalConfigs);
                    }
                    getCoordinates() {
                        const coordinates = JSON.parse(this.newElm.config.bounds);
                        return JSON.stringify(coordinates);
                    }
                    getLocation() {
                        return this.newElm.config.bounds;
                    }
                }
                DrawingTools.DrawRectangle = DrawRectangle;
            })(DrawingTools = Google.DrawingTools || (Google.DrawingTools = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var DrawingTools;
            (function (DrawingTools_1) {
                class DrawingTools extends OSFramework.Maps.DrawingTools.AbstractDrawingTools {
                    constructor(map, drawingToolsId, configs) {
                        super(map, drawingToolsId, new Google.Configuration.DrawingTools.DrawingToolsConfig(configs));
                    }
                    _refreshDrawingModes() {
                        const drawingControlOptions = this.provider.get('drawingControlOptions');
                        this.provider.setOptions({
                            drawingMode: null,
                            drawingControlOptions: Object.assign(Object.assign({}, drawingControlOptions), { drawingModes: this.tools.map((tool) => tool.type) }),
                        });
                    }
                    _refreshDrawingTools() {
                        this._setDrawingToolsEvents();
                        this._refreshDrawingModes();
                    }
                    _setDrawingToolsEvents() {
                        google.maps.event.clearInstanceListeners(this.provider);
                        this.tools.forEach((tool) => tool.addCompletedEvent());
                    }
                    get controlOptions() {
                        return this._provider.get('drawingControlOptions');
                    }
                    set controlOptions(options) {
                        const allOptions = Object.assign(Object.assign({}, this.controlOptions), options);
                        this._provider.setOptions({
                            drawingControlOptions: allOptions,
                        });
                    }
                    get providerEvents() {
                        return Google.Constants.DrawingTools.Events;
                    }
                    addTool(tool) {
                        super.addTool(tool);
                        if (this.isReady) {
                            tool.build();
                            this._refreshDrawingTools();
                        }
                        return tool;
                    }
                    build() {
                        super.build();
                        const configs = this.getProviderConfig();
                        this._provider = new google.maps.drawing.DrawingManager({
                            drawingMode: null,
                            drawingControl: true,
                            drawingControlOptions: {
                                position: parseInt(google.maps.ControlPosition[configs.position]),
                                drawingModes: this.tools.map((tool) => OSFramework.Maps.Enum.DrawingToolsTypes[tool.type]),
                            },
                            polylineOptions: {},
                            markerOptions: {},
                        });
                        this._provider.setMap(this.map.provider);
                        this.tools.forEach((tool) => tool.build());
                        this._refreshDrawingTools();
                        this.finishBuild();
                    }
                    changeProperty(propertyName, value) {
                        const propValue = OSFramework.Maps.Enum.OS_Config_DrawingTools[propertyName];
                        super.changeProperty(propertyName, value);
                        if (this.isReady) {
                            if (propValue === OSFramework.Maps.Enum.OS_Config_DrawingTools.position) {
                                this.controlOptions = {
                                    position: parseInt(google.maps.ControlPosition[value]),
                                };
                            }
                        }
                    }
                    dispose() {
                        if (this.isReady) {
                            this.provider.set('map', null);
                        }
                        this._provider = undefined;
                        super.dispose();
                    }
                    refreshProviderEvents() {
                        if (this.isReady)
                            this._setDrawingToolsEvents();
                    }
                    removeTool(toolId) {
                        super.removeTool(toolId);
                        this._refreshDrawingTools();
                    }
                }
                DrawingTools_1.DrawingTools = DrawingTools;
            })(DrawingTools = Google.DrawingTools || (Google.DrawingTools = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var DrawingTools;
            (function (DrawingTools) {
                let DrawingToolsFactory;
                (function (DrawingToolsFactory) {
                    function MakeDrawingTools(map, drawingToolsId, configs) {
                        return new DrawingTools.DrawingTools(map, drawingToolsId, configs);
                    }
                    DrawingToolsFactory.MakeDrawingTools = MakeDrawingTools;
                    function MakeTool(map, drawingTools, toolId, type, configs) {
                        switch (type) {
                            case OSFramework.Maps.Enum.DrawingToolsTypes.Marker:
                                return new DrawingTools.DrawMarker(map, drawingTools, toolId, type, configs);
                            case OSFramework.Maps.Enum.DrawingToolsTypes.Polyline:
                                return new DrawingTools.DrawPolyline(map, drawingTools, toolId, type, configs);
                            case OSFramework.Maps.Enum.DrawingToolsTypes.Polygon:
                                return new DrawingTools.DrawPolygon(map, drawingTools, toolId, type, configs);
                            case OSFramework.Maps.Enum.DrawingToolsTypes.Circle:
                                return new DrawingTools.DrawCircle(map, drawingTools, toolId, type, configs);
                            case OSFramework.Maps.Enum.DrawingToolsTypes.Rectangle:
                                return new DrawingTools.DrawRectangle(map, drawingTools, toolId, type, configs);
                            default:
                                throw new Error(`There is no factory for this type of DrawingTool (${type})`);
                        }
                    }
                    DrawingToolsFactory.MakeTool = MakeTool;
                })(DrawingToolsFactory = DrawingTools.DrawingToolsFactory || (DrawingTools.DrawingToolsFactory = {}));
            })(DrawingTools = Google.DrawingTools || (Google.DrawingTools = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Feature;
            (function (Feature) {
                class Center {
                    constructor(map, center) {
                        this._map = map;
                        this._initialCenter = center;
                    }
                    build() { }
                    getCenter() {
                        return this._initialCenter;
                    }
                    getCurrentCenter() {
                        return this._currentCenter;
                    }
                    getMapCenter() {
                        const responseObj = {
                            isSuccess: true,
                            message: OSFramework.Maps.Enum.Success.message,
                            code: OSFramework.Maps.Enum.Success.code,
                        };
                        try {
                            const messageInfo = {
                                message: OSFramework.Maps.Enum.Success.message,
                                lat: this._map.provider.getCenter().lat(),
                                lng: this._map.provider.getCenter().lng(),
                            };
                            responseObj.message = JSON.stringify(messageInfo);
                        }
                        catch (error) {
                            responseObj.isSuccess = false;
                            responseObj.message = error.message;
                            responseObj.code = OSFramework.Maps.Enum.ErrorCodes.API_FailedGettingCenterCoordinates;
                        }
                        return responseObj;
                    }
                    refreshCenter(value) {
                        const coordinates = new google.maps.LatLng(value.lat, value.lng);
                        this._map.provider.setCenter(coordinates);
                        this._currentCenter = coordinates.toJSON();
                    }
                    setCurrentCenter(value) {
                        this._currentCenter = value;
                    }
                    updateCenter(location) {
                        Google.Helper.Conversions.ConvertToCoordinates(location)
                            .then((response) => {
                            this._map.config.center = response;
                            this._initialCenter = response;
                            this._map.refresh(true);
                        })
                            .catch((error) => {
                            this._map.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.OnError, this._map, OSFramework.Maps.Enum.ErrorCodes.LIB_FailedGeocodingMap, `${error}`);
                        });
                    }
                }
                Feature.Center = Center;
            })(Feature = Google.Feature || (Google.Feature = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Feature;
            (function (Feature) {
                class DirectionsRenderer {
                    constructor(map) {
                        this._map = map;
                        this._isRouteRendered = false;
                        this._routeMarkers = [];
                    }
                    _buildMarker(position, label) {
                        const pin = new google.maps.marker.PinElement({
                            background: '#EA4335',
                            borderColor: '#D6352D',
                            glyphColor: '#FFFFFF',
                            scale: 1,
                        });
                        const marker = new google.maps.marker.AdvancedMarkerElement({
                            position: {
                                lat: Google.Helper.Conversions.GetCoordinateValue(position.lat),
                                lng: Google.Helper.Conversions.GetCoordinateValue(position.lng),
                            },
                            map: this._map.provider,
                            content: pin.element,
                        });
                        pin.glyph = label;
                        return marker;
                    }
                    dispose() {
                        this.removeRoute();
                        this._map = undefined;
                    }
                    removeRoute() {
                        if (this._pathPolyline) {
                            this._pathPolyline.setMap(null);
                            this._pathPolyline = undefined;
                        }
                        this._routeMarkers.forEach((marker) => {
                            marker.map = undefined;
                        });
                        this._routeMarkers = [];
                        this._isRouteRendered = false;
                    }
                    renderRoute(encodedPolyline, _waypoints) {
                        this._isRouteRendered && this.removeRoute();
                        if (encodedPolyline) {
                            const bounds = new google.maps.LatLngBounds();
                            const routePath = google.maps.geometry.encoding.decodePath(encodedPolyline);
                            this._pathPolyline = new google.maps.Polyline({
                                path: routePath,
                                strokeColor: '#4285F470',
                                strokeWeight: 6,
                                map: this._map.provider,
                            });
                            let pointCharacter = 65;
                            const buildMarkerWithLabel = (point) => {
                                const label = String.fromCharCode(pointCharacter++);
                                const marker = this._buildMarker(point, label);
                                this._routeMarkers.push(marker);
                                bounds.extend(point);
                            };
                            buildMarkerWithLabel(routePath[0]);
                            _waypoints.forEach((waypoint) => {
                                buildMarkerWithLabel(Google.Helper.Conversions.GetCoordinatesFromString(waypoint));
                            });
                            buildMarkerWithLabel(routePath[routePath.length - 1]);
                            this._map.provider.fitBounds(bounds);
                            this._isRouteRendered = true;
                            return {
                                isSuccess: true,
                            };
                        }
                        else {
                            return {
                                code: OSFramework.Maps.Enum.ErrorCodes.LIB_FailedSetDirections,
                                message: 'Encoded polyline is empty or undefined.',
                            };
                        }
                    }
                }
                Feature.DirectionsRenderer = DirectionsRenderer;
            })(Feature = Google.Feature || (Google.Feature = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Feature;
            (function (Feature) {
                class Directions {
                    constructor(map) {
                        this._map = map;
                        this._isEnabled = false;
                        this._currRouteDistance = 0;
                        this._currRouteTime = 0;
                        this._currRouteLegs = [];
                        this._retriveLegsFromRoute = false;
                        this._directionsRenderer = new Feature.DirectionsRenderer(map);
                    }
                    get _fieldMask() {
                        return `${Google.Constants.GoogleMapsRouteOptions}${this._retriveLegsFromRoute ? ',routes.legs.steps' : ''}`;
                    }
                    _convertTravelMode(travelModeInput) {
                        let travelMode = "DRIVE";
                        switch (travelModeInput) {
                            case 'DRIVING':
                                travelMode = "DRIVE";
                                break;
                            case 'BICYCLING':
                                travelMode = "BICYCLE";
                                break;
                            case 'WALKING':
                                travelMode = "WALK";
                                break;
                            default:
                                OSFramework.Maps.Helper.LogWarningMessage(`The Google Maps API for Routes does not support ${travelModeInput} directions. Using DRIVING mode instead.`);
                                break;
                        }
                        return travelMode;
                    }
                    _createWaypoint(coordinates) {
                        const isCoordinates = Google.Helper.TypeChecker.IsValidCoordinates(coordinates);
                        const local = isCoordinates
                            ? { latLng: this._transformCoordinatesToLocationPoint(coordinates) }
                            : undefined;
                        const address = isCoordinates ? undefined : coordinates;
                        return {
                            location: local,
                            address: address,
                            via: true,
                        };
                    }
                    _getRoutesRequestBody(directionOptions) {
                        const isOriginCoordinate = Google.Helper.TypeChecker.IsValidCoordinates(directionOptions.originRoute);
                        const isDestinationCoordinate = Google.Helper.TypeChecker.IsValidCoordinates(directionOptions.destinationRoute);
                        this._waypoints = directionOptions.waypoints;
                        const requestBody = {
                            origin: {
                                location: isOriginCoordinate
                                    ? {
                                        latLng: this._transformCoordinatesToLocationPoint(directionOptions.originRoute),
                                    }
                                    : undefined,
                                address: isOriginCoordinate ? undefined : directionOptions.originRoute,
                            },
                            destination: {
                                location: isDestinationCoordinate
                                    ? {
                                        latLng: this._transformCoordinatesToLocationPoint(directionOptions.destinationRoute),
                                    }
                                    : undefined,
                                address: isDestinationCoordinate ? undefined : directionOptions.destinationRoute,
                            },
                            intermediates: this._waypointsCleanup(directionOptions.waypoints),
                            travelMode: this._convertTravelMode(directionOptions.travelMode),
                            routingPreference: directionOptions.travelMode === 'DRIVING' ? 'TRAFFIC_UNAWARE' : undefined,
                            routeModifiers: {
                                avoidTolls: directionOptions.exclude.avoidTolls,
                                avoidHighways: directionOptions.exclude.avoidHighways,
                                avoidFerries: directionOptions.exclude.avoidFerries,
                            },
                            languageCode: this._map.config.localization.language,
                            units: 'METRIC',
                        };
                        return requestBody;
                    }
                    _setRouteInMap(response) {
                        var _a;
                        if (((_a = response === null || response === void 0 ? void 0 : response.routes) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                            const firstRoute = response.routes[0];
                            this._currRouteTime = parseInt(firstRoute.duration);
                            this._currRouteDistance = firstRoute.distanceMeters;
                            this._currRouteLegs = this._retriveLegsFromRoute ? firstRoute.legs[0].steps : undefined;
                            const result = this._directionsRenderer.renderRoute(firstRoute.polyline.encodedPolyline, this._waypoints);
                            return result;
                        }
                        else {
                            this._currRouteTime = 0;
                            this._currRouteDistance = 0;
                            return {
                                code: OSFramework.Maps.Enum.ErrorCodes.LIB_FailedSetDirections,
                                message: 'No routes found for the provided origin, destination and waypoints.',
                            };
                        }
                    }
                    _transformCoordinatesToLocationPoint(coordinates) {
                        const structuredCoordenate = Google.Helper.Conversions.GetCoordinatesFromString(coordinates);
                        return {
                            latitude: structuredCoordenate.lat,
                            longitude: structuredCoordenate.lng,
                        };
                    }
                    _waypointsCleanup(waypoints) {
                        return waypoints.reduce((acc, curr) => {
                            const waypoint = this._createWaypoint(curr);
                            acc.push(waypoint);
                            return acc;
                        }, []);
                    }
                    set retrieveLegsFromRoute(value) {
                        if (value) {
                            OSFramework.Maps.Helper.LogWarningMessage('By requesting the legs from the route, you will be retrieving a lot of data. This may cause higher costs of usage in the Google Maps API. Use it wisely.');
                        }
                        this._retriveLegsFromRoute = value;
                    }
                    get isEnabled() {
                        return this._isEnabled;
                    }
                    build() {
                        this.setState(this._isEnabled);
                    }
                    dispose() {
                        this.setState(false);
                        this._map = undefined;
                        this._directionsRenderer.dispose();
                        this._directionsRenderer = undefined;
                    }
                    getLegsFromDirection() {
                        if (this._isEnabled === false)
                            return [];
                        if (!this._currRouteLegs || this._currRouteLegs.length === 0)
                            return [];
                        const legs = this._currRouteLegs.reduce((acc, curr) => {
                            acc.push({
                                origin: JSON.parse(JSON.stringify(curr.startLocation.latLng)),
                                destination: JSON.parse(JSON.stringify(curr.endLocation.latLng)),
                                distance: curr.distanceMeters,
                                duration: parseInt(curr.staticDuration) || 0,
                            });
                            return acc;
                        }, []);
                        return legs;
                    }
                    getTotalDistanceFromDirection() {
                        return new Promise((resolve) => {
                            if (this._isEnabled === false)
                                resolve(0);
                            resolve(this._currRouteDistance);
                        });
                    }
                    getTotalDurationFromDirection() {
                        return new Promise((resolve) => {
                            if (this._isEnabled === false)
                                resolve(0);
                            resolve(this._currRouteTime);
                        });
                    }
                    removeRoute() {
                        this.setState(false);
                        this._waypoints.length = 0;
                        return {
                            isSuccess: true,
                        };
                    }
                    setPlugin(providerName, apiKey) {
                        OSFramework.Maps.Helper.ThrowError(this._map, OSFramework.Maps.Enum.ErrorCodes.GEN_NoPluginDirectionsNeeded);
                        return;
                    }
                    setRoute(directionOptions) {
                        const routeSetPromise = new Promise((resolve, reject) => {
                            fetch(Google.Constants.googleMapsRoutesApiURL, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-Goog-Api-Key': this._map.config.apiKey,
                                    'X-Goog-FieldMask': this._fieldMask,
                                },
                                body: JSON.stringify(this._getRoutesRequestBody(directionOptions)),
                            })
                                .then((response) => {
                                if (response.status === 200) {
                                    response
                                        .json()
                                        .then((responseJSON) => {
                                        const result = this._setRouteInMap(responseJSON);
                                        if (result.isSuccess) {
                                            this.setState(true);
                                            resolve(result);
                                        }
                                        else {
                                            this.setState(false);
                                            reject(result);
                                        }
                                    })
                                        .catch((reason) => {
                                        this.setState(false);
                                        reject({
                                            code: OSFramework.Maps.Enum.ErrorCodes.LIB_FailedSetDirections,
                                            message: `${reason}`,
                                        });
                                    });
                                }
                                else {
                                    reject({
                                        code: OSFramework.Maps.Enum.ErrorCodes.LIB_FailedSetDirections,
                                        message: response.statusText,
                                    });
                                }
                            })
                                .catch((reason) => {
                                this.setState(false);
                                reject({
                                    code: OSFramework.Maps.Enum.ErrorCodes.LIB_FailedSetDirections,
                                    message: `${reason}`,
                                });
                            });
                        });
                        return routeSetPromise;
                    }
                    setState(value) {
                        if (!value) {
                            this._directionsRenderer.removeRoute();
                            this._currRouteLegs = [];
                            this._currRouteDistance = 0;
                            this._currRouteTime = 0;
                        }
                        this._isEnabled = value;
                    }
                }
                Feature.Directions = Directions;
            })(Feature = Google.Feature || (Google.Feature = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Feature;
            (function (Feature) {
                class AbstractFactoryBuilder {
                    constructor(map) {
                        this._map = map;
                        this._featureList = [];
                        this._features = new OSFramework.Maps.Feature.ExposedFeatures();
                    }
                    _instanceOfIDisposable(object) {
                        return 'dispose' in object;
                    }
                    _makeItem(c, ...args) {
                        const o = new c(this._map, ...args);
                        this._featureList.push(o);
                        return o;
                    }
                    get features() {
                        return this._features;
                    }
                    build() {
                        this._featureList.forEach((p) => p.build());
                    }
                    dispose() {
                        this._featureList.forEach((p) => {
                            this._instanceOfIDisposable(p) && p.dispose();
                            p = undefined;
                        });
                    }
                }
                Feature.AbstractFactoryBuilder = AbstractFactoryBuilder;
                class FeatureBuilder extends AbstractFactoryBuilder {
                    _makeCenter(center) {
                        this._features.center = this._makeItem(Feature.Center, center);
                        return this;
                    }
                    _makeDirections() {
                        this._features.directions = this._makeItem(Feature.Directions);
                        return this;
                    }
                    _makeInfoWindow() {
                        this._features.infoWindow = this._makeItem(Feature.InfoWindow);
                        return this;
                    }
                    _makeMarkerClusterer(markerClusterer) {
                        this._features.markerClusterer = this._makeItem(Feature.GoogleMarkerClusterer, markerClusterer);
                        return this;
                    }
                    _makeOffset(offset) {
                        this._features.offset = this._makeItem(Feature.Offset, offset);
                        return this;
                    }
                    _makeShape() {
                        this._features.shape = this._makeItem(Feature.Shape);
                        return this;
                    }
                    _makeTrafficLayer(enable) {
                        this._features.trafficLayer = this._makeItem(Feature.TrafficLayer, enable);
                        return this;
                    }
                    _makeZoom(level) {
                        this._features.zoom = this._makeItem(Feature.Zoom, level);
                        return this;
                    }
                    build() {
                        const config = this._map.config;
                        this._makeShape();
                        this._makeTrafficLayer(config.showTraffic)
                            ._makeZoom(config.zoom)
                            ._makeCenter(config.center)
                            ._makeDirections()
                            ._makeOffset(config.offset)
                            ._makeMarkerClusterer(config.markerClusterer)
                            ._makeInfoWindow();
                        super.build();
                    }
                }
                Feature.FeatureBuilder = FeatureBuilder;
            })(Feature = Google.Feature || (Google.Feature = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Feature;
            (function (Feature) {
                class GoogleMarkerClusterer {
                    constructor(map, markerClustererConfigs) {
                        this._map = map;
                        this._config = new Google.Configuration.MarkerClusterer.MarkerClustererConfig(markerClustererConfigs);
                    }
                    get markerClusterer() {
                        return this._markerClusterer;
                    }
                    get isEnabled() {
                        return this._config.markerClustererActive && this._markerClusterer !== undefined;
                    }
                    _makeAlgorithm() {
                        this._algorithm = new window.markerClusterer.SuperClusterAlgorithm({
                            maxZoom: this._config.markerClustererMaxZoom,
                            minPoints: this._config.markerClustererMinClusterSize,
                        });
                    }
                    _makeConfigs() {
                        const pConfigs = this._config.getProviderConfig();
                        if (this._config.markerClustererActive) {
                            pConfigs.algorithm = this._algorithm;
                            pConfigs.algorithmOptions = undefined;
                            pConfigs.map = this._map.provider;
                            pConfigs.markers = this._map.markersReady;
                            pConfigs.onClusterClick = this._zoomClickHandler.bind(this);
                            pConfigs.renderer = this._makeRenderer();
                        }
                        return pConfigs;
                    }
                    _makeRenderer() {
                        if (this._renderer === undefined) {
                            this._renderer = new window.markerClusterer.DefaultRenderer();
                        }
                        return this._renderer;
                    }
                    _rebuildClusters() {
                        this._markerClusterer.clearMarkers();
                        this._markerClusterer = undefined;
                        this._markerClusterer = new window.markerClusterer.MarkerClusterer(this._makeConfigs());
                    }
                    _setState() {
                        if (this._config.markerClustererActive) {
                            this._rebuildClusters();
                        }
                        else {
                            this._markerClusterer.clearMarkers();
                            this._map.markers.forEach((marker) => {
                                const provider = marker.provider;
                                if (Google.Helper.TypeChecker.IsAdvancedMarker(provider)) {
                                    provider.map = this._map.provider;
                                }
                                else {
                                    provider.setMap(this._map.provider);
                                }
                            });
                        }
                    }
                    _zoomClickHandler(event, cluster, map) {
                        if (this._config.markerClustererZoomOnClick) {
                            map.fitBounds(cluster.bounds);
                        }
                    }
                    addMarker(marker) {
                        if (this.isEnabled && marker.isReady) {
                            this._markerClusterer.addMarker(marker.provider, false);
                        }
                    }
                    build() {
                        this._makeRenderer();
                        this._makeAlgorithm();
                        this._markerClusterer = new window.markerClusterer.MarkerClusterer(this._makeConfigs());
                        this._repaintOnTilesLoaded = google.maps.event.addListenerOnce(this._map.provider, 'tilesloaded', this.repaint.bind(this));
                    }
                    changeProperty(propertyName, propertyValue) {
                        const propValue = OSFramework.Maps.Enum.OS_Config_MarkerClusterer[propertyName];
                        if (this._config.hasOwnProperty(propertyName)) {
                            this._config[propertyName] = propertyValue;
                        }
                        else {
                            this._map.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.OnError, this._map, OSFramework.Maps.Enum.ErrorCodes.GEN_InvalidChangePropertyMarkerClusterer, `${propertyName}`);
                        }
                        if (this.markerClusterer !== undefined) {
                            switch (propValue) {
                                case OSFramework.Maps.Enum.OS_Config_MarkerClusterer.markerClustererActive:
                                    this._setState();
                                    break;
                                case OSFramework.Maps.Enum.OS_Config_MarkerClusterer.markerClustererMinClusterSize:
                                case OSFramework.Maps.Enum.OS_Config_MarkerClusterer.markerClustererMaxZoom:
                                    this._makeAlgorithm();
                                    this._rebuildClusters();
                                    break;
                                case OSFramework.Maps.Enum.OS_Config_MarkerClusterer.markerClustererZoomOnClick:
                                    return;
                            }
                            this.repaint();
                        }
                    }
                    dispose() {
                        this._markerClusterer = undefined;
                        google.maps.event.removeListener(this._repaintOnTilesLoaded);
                    }
                    removeMarker(marker) {
                        var _a;
                        if (this.isEnabled && marker.isReady) {
                            (_a = this._markerClusterer) === null || _a === void 0 ? void 0 : _a.removeMarker(marker.provider, false);
                        }
                    }
                    repaint() {
                        this._markerClusterer.render();
                    }
                    setClusterRenderer(renderer) {
                        this._renderer = renderer;
                        if (this.isEnabled) {
                            this._rebuildClusters();
                        }
                    }
                }
                Feature.GoogleMarkerClusterer = GoogleMarkerClusterer;
            })(Feature = Google.Feature || (Google.Feature = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Feature;
            (function (Feature) {
                class InfoWindow {
                    constructor(map) {
                        this._map = map;
                    }
                    build() {
                        this._infoWindow = new google.maps.InfoWindow({
                            content: '',
                        });
                        this._popupIsOpened = false;
                        this._infoWindow.addListener('closeclick', this.closePopup.bind(this));
                    }
                    closePopup() {
                        if (this._popupIsOpened) {
                            this._infoWindow.close();
                            this._popupIsOpened = false;
                        }
                    }
                    openPopup(marker) {
                        if (this._popupIsOpened === true) {
                            this.closePopup();
                        }
                        this._infoWindow.open(this._map.provider, marker.provider);
                        this._popupIsOpened = true;
                    }
                    setPopupContent(content) {
                        this._infoWindow.setContent(content);
                    }
                }
                Feature.InfoWindow = InfoWindow;
            })(Feature = Google.Feature || (Google.Feature = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Feature;
            (function (Feature) {
                class Offset {
                    constructor(map, offset) {
                        this._map = map;
                        this._offset = offset || { offsetX: 0, offsetY: 0 };
                    }
                    get getOffset() {
                        return this._offset;
                    }
                    build() { }
                    setOffset(value) {
                        this._offset = {
                            offsetX: value.offsetX || 0,
                            offsetY: value.offsetY || 0,
                        };
                        this._map.provider.panTo(this._map.features.center.getCurrentCenter());
                        this._map.provider.panBy(this._offset.offsetX, this._offset.offsetY);
                    }
                }
                Feature.Offset = Offset;
            })(Feature = Google.Feature || (Google.Feature = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Feature;
            (function (Feature) {
                class Shape {
                    _checkCircleContainsMarker() {
                        const circleRadius = this._shape.provider.getRadius();
                        const circleCenter = this._shape.provider.getCenter();
                        const distanceBetweenPoints = google.maps.geometry.spherical.computeDistanceBetween(this._markerCoordinates, circleCenter);
                        this._isInsideShape = distanceBetweenPoints <= circleRadius;
                        this._updateReturnMessage();
                    }
                    _checkContainsMarker() {
                        this._isInsideShape = google.maps.geometry.poly.containsLocation(this._markerCoordinates, this._map.getShape(this._shape.widgetId).provider);
                        this._updateReturnMessage();
                    }
                    _checkRectangleContainsMarker() {
                        this._isInsideShape = this._map
                            .getShape(this._shape.widgetId)
                            .provider.getBounds()
                            .contains(this._markerCoordinates);
                        this._updateReturnMessage();
                    }
                    _updateReturnMessage() {
                        this._returnObjSuccess = true;
                        this._returnObjCode = OSFramework.Maps.Enum.Success.code;
                        this._returnObjMessage = this._isInsideShape.toString();
                    }
                    build() {
                    }
                    containsLocation(mapId, shapeId, pointCoordinates, coordinatesList) {
                        this._map = OutSystems.Maps.MapAPI.MapManager.GetMapById(mapId);
                        this._returnObjSuccess = false;
                        this._returnObjCode = OSFramework.Maps.Enum.ErrorCodes.CFG_InvalidMapId;
                        if (this._map) {
                            this._isInsideShape = false;
                            this._markerCoordinates = JSON.parse(pointCoordinates);
                            this._markerCoordinates = new google.maps.LatLng(this._markerCoordinates.Lat, this._markerCoordinates.Lng);
                            if (shapeId) {
                                this._shape = OutSystems.Maps.MapAPI.ShapeManager.GetShapeById(shapeId);
                                switch (this._shape.type) {
                                    case OSFramework.Maps.Enum.ShapeType.Polyline:
                                        this._returnObjCode = OSFramework.Maps.Enum.Unsupported.code;
                                        this._returnObjMessage = OSFramework.Maps.Enum.Unsupported.message;
                                        break;
                                    case OSFramework.Maps.Enum.ShapeType.Rectangle:
                                        this._checkRectangleContainsMarker();
                                        break;
                                    case OSFramework.Maps.Enum.ShapeType.Circle:
                                        this._checkCircleContainsMarker();
                                        break;
                                    default: {
                                        this._checkContainsMarker();
                                    }
                                }
                            }
                            else {
                                const shapeCoordinatesList = JSON.parse(coordinatesList.toLowerCase());
                                if (shapeCoordinatesList.length >= 3) {
                                    const newShape = new google.maps.Polygon({
                                        paths: shapeCoordinatesList,
                                    });
                                    newShape.setMap(null);
                                    this._isInsideShape = google.maps.geometry.poly.containsLocation(this._markerCoordinates, newShape);
                                    this._updateReturnMessage();
                                }
                            }
                        }
                        return {
                            isSuccess: this._returnObjSuccess,
                            code: this._returnObjCode,
                            message: this._returnObjMessage,
                        };
                    }
                }
                Feature.Shape = Shape;
            })(Feature = Google.Feature || (Google.Feature = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Feature;
            (function (Feature) {
                class TrafficLayer {
                    constructor(map, enabled) {
                        this._map = map;
                        this._enabled = enabled;
                    }
                    get isEnabled() {
                        return this._enabled;
                    }
                    build() {
                        this._trafficLayer = new google.maps.TrafficLayer();
                        this.setState(this._enabled);
                    }
                    dispose() {
                        this._trafficLayer = undefined;
                    }
                    setState(value) {
                        this._trafficLayer.setMap(value === true ? this._map.provider : null);
                        this._enabled = value;
                    }
                }
                Feature.TrafficLayer = TrafficLayer;
            })(Feature = Google.Feature || (Google.Feature = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Feature;
            (function (Feature) {
                class Zoom {
                    constructor(map, level) {
                        this._map = map;
                        this._level = level;
                    }
                    _setAutofit(value) {
                        this._autofitEnabled = value;
                    }
                    _setBounds(useShapes) {
                        const bounds = new google.maps.LatLngBounds();
                        this._map.markers.forEach(function (item) {
                            if (item.provider === undefined)
                                return;
                            if (Google.Helper.TypeChecker.IsAdvancedMarker(item.provider)) {
                                bounds.extend(item.provider.position.toJSON());
                            }
                            else {
                                bounds.extend(item.provider.getPosition().toJSON());
                            }
                        });
                        if (useShapes) {
                            this._map.shapes.forEach(function (item) {
                                if (item.provider === undefined)
                                    return;
                                bounds.union(item.providerBounds);
                            });
                        }
                        this._map.provider.fitBounds(bounds);
                        this._map.provider.panToBounds(bounds);
                        this._map.features.center.setCurrentCenter(this._map.provider.getCenter());
                    }
                    build() {
                        this._setAutofit(this._level === OSFramework.Maps.Enum.OSMap.Zoom.Auto);
                    }
                    get isAutofit() {
                        return this._autofitEnabled;
                    }
                    get level() {
                        return this._level;
                    }
                    refreshZoom() {
                        if (this._map.features.zoom.isAutofit) {
                            if (this._map.markers.length > 1 ||
                                (this._map.shapes.length > 0 && this._map.config.autoZoomOnShapes === true)) {
                                this._setBounds(this._map.config.autoZoomOnShapes);
                            }
                            else {
                                this._map.provider.setZoom(OSFramework.Maps.Helper.Constants.zoomAutofit);
                            }
                        }
                        else {
                            this._map.provider.setZoom(this._map.features.zoom.level);
                        }
                    }
                    setLevel(value) {
                        this._level = value;
                        this._setAutofit(value === OSFramework.Maps.Enum.OSMap.Zoom.Auto);
                        this._map.refresh();
                    }
                }
                Feature.Zoom = Zoom;
            })(Feature = Google.Feature || (Google.Feature = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var FileLayer;
            (function (FileLayer) {
                let FileLayerFactory;
                (function (FileLayerFactory) {
                    function MakeFileLayer(map, fileLayerId, configs) {
                        return new FileLayer.FileLayer(map, fileLayerId, configs);
                    }
                    FileLayerFactory.MakeFileLayer = MakeFileLayer;
                })(FileLayerFactory = FileLayer.FileLayerFactory || (FileLayer.FileLayerFactory = {}));
            })(FileLayer = Google.FileLayer || (Google.FileLayer = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var FileLayer;
            (function (FileLayer_1) {
                class FileLayer extends OSFramework.Maps.FileLayer.AbstractFileLayer {
                    constructor(map, FileLayerId, configs) {
                        super(map, FileLayerId, new Google.Configuration.FileLayer.FileLayerConfig(configs));
                    }
                    _setFileLayerEvents() {
                        google.maps.event.clearInstanceListeners(this.provider);
                        if (this.fileLayerEvents.hasHandlers(OSFramework.Maps.Event.FileLayer.FileLayersEventType.OnClick) &&
                            this.provider.get('clickable')) {
                            this.provider.addListener('click', (event) => {
                                const flParams = {
                                    coordinates: JSON.stringify({
                                        Lat: event.latLng.lat(),
                                        Lng: event.latLng.lng(),
                                    }),
                                    featureData: JSON.stringify(event.featureData),
                                };
                                this.fileLayerEvents.trigger(OSFramework.Maps.Event.FileLayer.FileLayersEventType.OnClick, undefined, flParams);
                            });
                        }
                    }
                    build() {
                        super.build();
                        this._provider = new google.maps.KmlLayer(Object.assign(Object.assign({}, this.getProviderConfig()), { map: this.map.provider }));
                        this._setFileLayerEvents();
                        this.finishBuild();
                    }
                    changeProperty(propertyName, value) {
                        const propValue = OSFramework.Maps.Enum.OS_Config_FileLayer[propertyName];
                        super.changeProperty(propertyName, value);
                        if (this.isReady) {
                            switch (propValue) {
                                case OSFramework.Maps.Enum.OS_Config_FileLayer.layerUrl:
                                    return this.provider.setOptions({
                                        url: value,
                                    });
                                case OSFramework.Maps.Enum.OS_Config_FileLayer.preserveViewport:
                                    return this.provider.setOptions({
                                        preserveViewport: value,
                                    });
                                case OSFramework.Maps.Enum.OS_Config_FileLayer.suppressPopups:
                                    return this.provider.setOptions({
                                        suppressInfoWindows: value,
                                    });
                            }
                        }
                    }
                    dispose() {
                        if (this.isReady) {
                            this.provider.set('map', null);
                        }
                        this._provider = undefined;
                        super.dispose();
                    }
                    refreshProviderEvents() {
                        if (this.isReady)
                            this._setFileLayerEvents();
                    }
                }
                FileLayer_1.FileLayer = FileLayer;
            })(FileLayer = Google.FileLayer || (Google.FileLayer = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var HeatmapLayer;
            (function (HeatmapLayer) {
                let HeatmapLayerFactory;
                (function (HeatmapLayerFactory) {
                    function MakeHeatmapLayer(map, heatmapLayerId, configs) {
                        return new HeatmapLayer.HeatmapLayer(map, heatmapLayerId, configs);
                    }
                    HeatmapLayerFactory.MakeHeatmapLayer = MakeHeatmapLayer;
                })(HeatmapLayerFactory = HeatmapLayer.HeatmapLayerFactory || (HeatmapLayer.HeatmapLayerFactory = {}));
            })(HeatmapLayer = Google.HeatmapLayer || (Google.HeatmapLayer = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var HeatmapLayer;
            (function (HeatmapLayer_1) {
                class HeatmapLayer extends OSFramework.Maps.HeatmapLayer.AbstractHeatmapLayer {
                    constructor(map, HeatmapLayerId, configs) {
                        super(map, HeatmapLayerId, new Google.Configuration.HeatmapLayer.HeatmapLayerConfig(configs));
                    }
                    _gradientColors(gradient) {
                        if (gradient.length === 0) {
                            return Google.Constants.gradientHeatmapColors;
                        }
                        return gradient;
                    }
                    _pointsToData(points) {
                        const data = points.map((point) => {
                            if (point.Weight === undefined) {
                                return new google.maps.LatLng(point.Lat, point.Lng);
                            }
                            return {
                                location: new google.maps.LatLng(point.Lat, point.Lng),
                                weight: point.Weight,
                            };
                        });
                        return data;
                    }
                    build() {
                        super.build();
                        const configs = this.getProviderConfig();
                        this._provider = new google.maps.visualization.HeatmapLayer(Object.assign(Object.assign({}, configs), { data: this._pointsToData(configs.points), gradient: this._gradientColors(configs.gradient), map: this.map.provider }));
                        this.finishBuild();
                    }
                    changeProperty(propertyName, value) {
                        const propValue = OSFramework.Maps.Enum.OS_Config_HeatmapLayer[propertyName];
                        super.changeProperty(propertyName, value);
                        if (this.isReady) {
                            switch (propValue) {
                                case OSFramework.Maps.Enum.OS_Config_HeatmapLayer.points:
                                    return this.provider.setData(this._pointsToData(JSON.parse(value)));
                                case OSFramework.Maps.Enum.OS_Config_HeatmapLayer.dissipateOnZoom:
                                    return this.provider.setOptions({
                                        dissipating: value,
                                    });
                                case OSFramework.Maps.Enum.OS_Config_HeatmapLayer.gradient:
                                    return this.provider.setOptions({
                                        gradient: this._gradientColors(JSON.parse(value)),
                                    });
                                case OSFramework.Maps.Enum.OS_Config_HeatmapLayer.maxIntensity:
                                    return this.provider.setOptions({
                                        maxIntensity: value,
                                    });
                                case OSFramework.Maps.Enum.OS_Config_HeatmapLayer.opacity:
                                    return this.provider.setOptions({
                                        opacity: value,
                                    });
                                case OSFramework.Maps.Enum.OS_Config_HeatmapLayer.radius:
                                    return this.provider.setOptions({
                                        radius: value,
                                    });
                            }
                        }
                    }
                    dispose() {
                        if (this.isReady) {
                            this.provider.set('map', null);
                        }
                        this._provider = undefined;
                        super.dispose();
                    }
                }
                HeatmapLayer_1.HeatmapLayer = HeatmapLayer;
            })(HeatmapLayer = Google.HeatmapLayer || (Google.HeatmapLayer = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Helper;
            (function (Helper) {
                var Conversions;
                (function (Conversions) {
                    const googleMapsApiGeocode = function (location) {
                        const geo = new google.maps.Geocoder();
                        return new Promise((resolve, reject) => {
                            geo.geocode({ address: location }, (results, status) => {
                                if (status === google.maps.GeocoderStatus.OK) {
                                    const loc = results[0].geometry.location;
                                    resolve({ lat: loc.lat(), lng: loc.lng() });
                                }
                                else if (status === google.maps.GeocoderStatus.ZERO_RESULTS) {
                                    console.warn(`No results have been found for address "${location}".`);
                                    reject('No results have been found.');
                                }
                                else if (status === google.maps.GeocoderStatus.OVER_QUERY_LIMIT) {
                                    reject('Google Maps API call limit exceeded. Please wait a few moments and try again');
                                }
                                else {
                                    reject(status);
                                }
                            });
                        });
                    };
                    function ConvertToCoordinates(location) {
                        if (location === undefined || location.trim().length === 0) {
                            console.warn('Invalid location. Using the default location -> 55 Thomson Pl 2nd floor, Boston, MA 02210, United States');
                            return Promise.resolve(OSFramework.Maps.Helper.Constants.defaultMapCenter);
                        }
                        if (Helper.TypeChecker.IsValidCoordinates(location)) {
                            if (location.indexOf(',') > -1) {
                                return Promise.resolve(GetCoordinatesFromString(location));
                            }
                            else {
                                return googleMapsApiGeocode(location);
                            }
                        }
                        else {
                            return googleMapsApiGeocode(location);
                        }
                    }
                    Conversions.ConvertToCoordinates = ConvertToCoordinates;
                    function GetCoordinatesFromString(coordinates) {
                        let latitude;
                        let longitude;
                        if (coordinates.indexOf(',') > -1) {
                            latitude = parseFloat(coordinates.split(',')[0].replace(' ', ''));
                            longitude = parseFloat(coordinates.split(',')[1].replace(' ', ''));
                            return { lat: latitude, lng: longitude };
                        }
                        else {
                            return { lat: 0, lng: 0 };
                        }
                    }
                    Conversions.GetCoordinatesFromString = GetCoordinatesFromString;
                    function GetCoordinateValue(coordinate) {
                        return typeof coordinate === 'function' ? coordinate() : coordinate;
                    }
                    Conversions.GetCoordinateValue = GetCoordinateValue;
                })(Conversions = Helper.Conversions || (Helper.Conversions = {}));
            })(Helper = Google.Helper || (Google.Helper = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Helper;
            (function (Helper) {
                var TypeChecker;
                (function (TypeChecker) {
                    function IsAdvancedMarker(marker) {
                        return marker instanceof google.maps.marker.AdvancedMarkerElement;
                    }
                    TypeChecker.IsAdvancedMarker = IsAdvancedMarker;
                    function IsValidCoordinates(coordinates) {
                        return Google.Constants.coordinateValidator.test(coordinates);
                    }
                    TypeChecker.IsValidCoordinates = IsValidCoordinates;
                })(TypeChecker = Helper.TypeChecker || (Helper.TypeChecker = {}));
            })(Helper = Google.Helper || (Google.Helper = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Marker;
            (function (Marker) {
                class DeprecatedMarker extends OSFramework.Maps.Marker.AbstractMarker {
                    constructor(map, markerId, type, configs) {
                        super(map, markerId, type, new Google.Configuration.Marker.DeprecatedGoogleMarkerConfig(configs));
                        this._addedEvents = [];
                    }
                    _setIcon(url) {
                        if (url === '') {
                            this.provider.setIcon(null);
                        }
                        else {
                            try {
                                let anchorCalc;
                                let scaledSize;
                                const height = Number(this.config.iconHeight);
                                const width = Number(this.config.iconWidth);
                                if (OSFramework.Maps.Helper.IsValidNumber(height) &&
                                    OSFramework.Maps.Helper.IsValidNumber(width) &&
                                    height > 0 &&
                                    width > 0) {
                                    anchorCalc = new google.maps.Point(width / 2, height);
                                    scaledSize = new google.maps.Size(width, height);
                                }
                                const icon = {
                                    url: url,
                                    scaledSize: scaledSize,
                                    anchor: anchorCalc,
                                    origin: new google.maps.Point(0, 0),
                                };
                                this.provider.setIcon(icon);
                            }
                            catch (e) {
                                console.error(e);
                            }
                        }
                    }
                    _setIconSize() {
                        this._setIcon(this.config.iconUrl);
                    }
                    _buildMarkerPosition() {
                        const markerOptions = {};
                        if (typeof this.config.location === 'undefined') {
                            this.map.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.OnError, this.map, OSFramework.Maps.Enum.ErrorCodes.LIB_FailedGeocodingMarker, `Location of the Marker can't be empty.`);
                        }
                        else {
                            return new Promise((resolve, reject) => {
                                Google.Helper.Conversions.ConvertToCoordinates(this.config.location)
                                    .then((response) => {
                                    markerOptions.position = {
                                        lat: response.lat,
                                        lng: response.lng,
                                    };
                                    resolve(markerOptions);
                                })
                                    .catch((e) => reject(e));
                            });
                        }
                    }
                    _setMarkerEvents() {
                        this._addedEvents.forEach((eventListener, index) => {
                            google.maps.event.clearListeners(this.provider, eventListener);
                            this._addedEvents.splice(index, 1);
                        });
                        if (this.markerEvents.hasHandlers(OSFramework.Maps.Event.Marker.MarkerEventType.OnClick)) {
                            this._addedEvents.push('click');
                            this._provider.addListener('click', (e) => {
                                const coordinates = new OSFramework.Maps.OSStructures.OSMap.OSCoordinates(e.latLng.lat(), e.latLng.lng());
                                this.markerEvents.trigger(OSFramework.Maps.Event.Marker.MarkerEventType.OnClick, OSFramework.Maps.Event.Marker.MarkerEventType.OnClick, JSON.stringify(coordinates));
                            });
                        }
                        this.markerEvents.handlers.forEach((handler, eventName) => {
                            if (handler instanceof OSFramework.Maps.Event.Marker.MarkerProviderEvent) {
                                this._addedEvents.push(eventName);
                                this._provider.addListener(Google.Constants.Marker.DeprecatedProviderEventNames[eventName], (e) => {
                                    this.markerEvents.trigger(OSFramework.Maps.Event.Marker.MarkerEventType.ProviderEvent, eventName, e !== undefined
                                        ? JSON.stringify({
                                            Lat: e.latLng.lat(),
                                            Lng: e.latLng.lng(),
                                        })
                                        : undefined);
                                });
                            }
                        });
                    }
                    get hasEvents() {
                        return this.markerEvents !== undefined;
                    }
                    get markerTag() {
                        return OSFramework.Maps.Helper.Constants.markerTag;
                    }
                    build() {
                        super.build();
                        const markerPosition = this._buildMarkerPosition();
                        if (markerPosition !== undefined) {
                            this.map.cancelScheduledResfresh();
                            markerPosition
                                .then((markerOptions) => {
                                if (this._destroyed)
                                    return;
                                this._provider = new google.maps.Marker(Object.assign(Object.assign(Object.assign({}, this.getProviderConfig()), markerOptions), { map: this.map.provider }));
                                this._setIconSize();
                                this._setMarkerEvents();
                                this.finishBuild();
                                this.map.scheduleRefresh();
                            })
                                .catch((error) => {
                                this.map.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.OnError, this.map, OSFramework.Maps.Enum.ErrorCodes.LIB_FailedGeocodingMarker, `${error}`);
                            });
                        }
                    }
                    changeProperty(propertyName, propertyValue) {
                        const propValue = OSFramework.Maps.Enum.OS_Config_Marker[propertyName];
                        super.changeProperty(propertyName, propertyValue);
                        if (this.isReady) {
                            switch (propValue) {
                                case OSFramework.Maps.Enum.OS_Config_Marker.location:
                                    Google.Helper.Conversions.ConvertToCoordinates(propertyValue)
                                        .then((response) => {
                                        this._provider.setPosition({
                                            lat: response.lat,
                                            lng: response.lng,
                                        });
                                        this.map.refresh();
                                    })
                                        .catch((error) => {
                                        this.map.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.OnError, this.map, OSFramework.Maps.Enum.ErrorCodes.LIB_FailedGeocodingMarker, `${error}`);
                                    });
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Marker.allowDrag:
                                    return this._provider.setDraggable(propertyValue);
                                case OSFramework.Maps.Enum.OS_Config_Marker.iconHeight:
                                case OSFramework.Maps.Enum.OS_Config_Marker.iconWidth:
                                    this._setIconSize();
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Marker.iconUrl:
                                    this._setIcon(propertyValue);
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Marker.label:
                                    return this._provider.setLabel(propertyValue);
                                case OSFramework.Maps.Enum.OS_Config_Marker.title:
                                    return this._provider.setTitle(propertyValue);
                            }
                        }
                    }
                    dispose() {
                        if (this.isReady) {
                            this._provider.setMap(null);
                        }
                        this._provider = undefined;
                        super.dispose();
                    }
                    refreshProviderEvents() {
                        if (this.isReady)
                            this._setMarkerEvents();
                    }
                    validateProviderEvent(eventName) {
                        return Google.Constants.Marker.DeprecatedProviderEventNames[eventName] !== undefined;
                    }
                }
                Marker.DeprecatedMarker = DeprecatedMarker;
            })(Marker = Google.Marker || (Google.Marker = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Marker;
            (function (Marker) {
                class DeprecatedMarkerPopup extends Marker.DeprecatedMarker {
                    _setMarkerEvents() {
                        super._setMarkerEvents();
                        this._provider.addListener('click', () => {
                            this.refreshPopupContent();
                            this.openPopup();
                        });
                    }
                    get hasPopup() {
                        return true;
                    }
                    get markerTag() {
                        return OSFramework.Maps.Helper.Constants.markerPopupTag;
                    }
                    closePopup() {
                        this.map.features.infoWindow.closePopup();
                    }
                    openPopup() {
                        this.refreshPopupContent();
                        this.map.features.infoWindow.openPopup(this);
                    }
                    refreshPopupContent() {
                        this._contentString = OSFramework.Maps.Helper.GetElementByUniqueId(this.uniqueId).querySelector(OSFramework.Maps.Helper.Constants.markerPopup).innerHTML;
                        this.map.features.infoWindow.setPopupContent(this._contentString);
                    }
                }
                Marker.DeprecatedMarkerPopup = DeprecatedMarkerPopup;
            })(Marker = Google.Marker || (Google.Marker = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Marker;
            (function (Marker) {
                let MarkerFactory;
                (function (MarkerFactory) {
                    function MakeMarker(map, markerId, type, configs) {
                        const useAdvancedMarkers = map.useAdvancedMarkers;
                        let markerClass;
                        switch (type) {
                            case OSFramework.Maps.Enum.MarkerType.Marker:
                                markerClass = useAdvancedMarkers ? Marker.Marker : Marker.DeprecatedMarker;
                                break;
                            case OSFramework.Maps.Enum.MarkerType.MarkerPopup:
                                markerClass = useAdvancedMarkers ? Marker.MarkerPopup : Marker.DeprecatedMarkerPopup;
                                break;
                            default:
                                throw new Error(`There is no factory for this type of Marker (${type})`);
                        }
                        return new markerClass(map, markerId, type, configs);
                    }
                    MarkerFactory.MakeMarker = MakeMarker;
                })(MarkerFactory = Marker.MarkerFactory || (Marker.MarkerFactory = {}));
            })(Marker = Google.Marker || (Google.Marker = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Marker;
            (function (Marker_1) {
                class Marker extends OSFramework.Maps.Marker.AbstractMarker {
                    constructor(map, markerId, type, configs) {
                        super(map, markerId, type, new Google.Configuration.Marker.GoogleMarkerConfig(configs));
                        this._addedEvents = [];
                    }
                    _setIcon() {
                        if (this.config.label !== '' || this.config.iconUrl !== '') {
                            try {
                                const height = this.config.iconHeight;
                                const width = this.config.iconWidth;
                                const markerIconWrapper = document.createElement('div');
                                markerIconWrapper.className = 'os-marker-icon';
                                if (this.config.iconUrl !== '') {
                                    const markerIconImage = document.createElement('img');
                                    markerIconImage.src = this.config.iconUrl;
                                    if (height > 0 && width > 0) {
                                        markerIconImage.height = height;
                                        markerIconImage.width = width;
                                    }
                                    markerIconWrapper.append(markerIconImage);
                                    if (this.config.label !== '') {
                                        const labelWrapper = document.createElement('div');
                                        labelWrapper.className = 'os-marker-icon-label';
                                        labelWrapper.textContent = this.config.label;
                                        markerIconWrapper.appendChild(labelWrapper);
                                    }
                                    this._provider.content = markerIconWrapper;
                                }
                                else {
                                    markerIconWrapper.textContent = this.config.label;
                                    const markerIcon = new google.maps.marker.PinElement({ glyph: markerIconWrapper });
                                    this._provider.content = markerIcon.element;
                                }
                            }
                            catch (e) {
                                console.error(e);
                            }
                        }
                        else {
                            this._provider.content = undefined;
                        }
                    }
                    _triggerEvent(eventType, eventName, lat, lng) {
                        const coordinates = new OSFramework.Maps.OSStructures.OSMap.OSCoordinates(Google.Helper.Conversions.GetCoordinateValue(lat), Google.Helper.Conversions.GetCoordinateValue(lng));
                        this.markerEvents.trigger(eventType, eventName, JSON.stringify(coordinates));
                    }
                    _buildMarkerPosition() {
                        const markerOptions = {};
                        if (typeof this.config.location === 'undefined') {
                            this.map.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.OnError, this.map, OSFramework.Maps.Enum.ErrorCodes.LIB_FailedGeocodingMarker, `Location of the Marker can't be empty.`);
                        }
                        else {
                            return new Promise((resolve, reject) => {
                                Google.Helper.Conversions.ConvertToCoordinates(this.config.location)
                                    .then((response) => {
                                    markerOptions.position = {
                                        lat: response.lat,
                                        lng: response.lng,
                                    };
                                    resolve(markerOptions);
                                })
                                    .catch((e) => reject(e));
                            });
                        }
                    }
                    _setMarkerEvents() {
                        this._addedEvents.forEach((eventListener, index) => {
                            google.maps.event.clearListeners(this.provider, eventListener);
                            this._addedEvents.splice(index, 1);
                        });
                        if (this.markerEvents.hasHandlers(OSFramework.Maps.Event.Marker.MarkerEventType.OnClick)) {
                            this._addedEvents.push('click');
                            this._provider.addListener('click', (e) => {
                                this._triggerEvent(OSFramework.Maps.Event.Marker.MarkerEventType.OnClick, OSFramework.Maps.Event.Marker.MarkerEventType.OnClick, e.latLng.lat, e.latLng.lng);
                            });
                        }
                        this.markerEvents.handlers.forEach((handler, eventName) => {
                            if (handler instanceof OSFramework.Maps.Event.Marker.MarkerProviderEvent) {
                                const ProviderEventName = Google.Constants.Marker.ProviderEventNames[eventName];
                                if (ProviderEventName !== undefined) {
                                    this._addedEvents.push(eventName);
                                    this._provider.addListener(ProviderEventName, (e) => {
                                        this._triggerEvent(OSFramework.Maps.Event.Marker.MarkerEventType.ProviderEvent, eventName, e.latLng.lat, e.latLng.lng);
                                    });
                                }
                                else {
                                    const HtmlEventName = Google.Constants.Marker.ProviderEventNamesHtml[eventName];
                                    if (HtmlEventName !== undefined) {
                                        this._addedEvents.push(eventName);
                                        this._provider.element.addEventListener(HtmlEventName, () => {
                                            this._triggerEvent(OSFramework.Maps.Event.Marker.MarkerEventType.ProviderEvent, eventName, this._provider.position.lat, this.provider.position.lng);
                                        });
                                    }
                                    else {
                                        console.error(`Event ${eventName} is not a valid event for the Marker.`);
                                    }
                                }
                            }
                        });
                    }
                    get hasEvents() {
                        return this.markerEvents !== undefined;
                    }
                    get markerTag() {
                        return OSFramework.Maps.Helper.Constants.markerTag;
                    }
                    build() {
                        super.build();
                        const markerPosition = this._buildMarkerPosition();
                        if (markerPosition !== undefined) {
                            this.map.cancelScheduledResfresh();
                            markerPosition
                                .then((markerOptions) => {
                                if (this._destroyed)
                                    return;
                                this._provider = new google.maps.marker.AdvancedMarkerElement(Object.assign(Object.assign({}, this.getProviderConfig()), { position: markerOptions.position, map: this.map.provider }));
                                this._setIcon();
                                this._setMarkerEvents();
                                this.finishBuild();
                                this.map.scheduleRefresh();
                            })
                                .catch((error) => {
                                this.map.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.OnError, this.map, OSFramework.Maps.Enum.ErrorCodes.LIB_FailedGeocodingMarker, `${error}`);
                            });
                        }
                    }
                    changeProperty(propertyName, propertyValue) {
                        const propValue = OSFramework.Maps.Enum.OS_Config_Marker[propertyName];
                        super.changeProperty(propertyName, propertyValue);
                        if (this.isReady) {
                            switch (propValue) {
                                case OSFramework.Maps.Enum.OS_Config_Marker.location:
                                    Google.Helper.Conversions.ConvertToCoordinates(propertyValue)
                                        .then((response) => {
                                        this._provider.position = {
                                            lat: response.lat,
                                            lng: response.lng,
                                        };
                                        this.map.refresh();
                                    })
                                        .catch((error) => {
                                        this.map.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.OnError, this.map, OSFramework.Maps.Enum.ErrorCodes.LIB_FailedGeocodingMarker, `${error}`);
                                    });
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Marker.allowDrag:
                                    this._provider.gmpDraggable = propertyValue;
                                    break;
                                case OSFramework.Maps.Enum.OS_Config_Marker.iconHeight:
                                case OSFramework.Maps.Enum.OS_Config_Marker.iconWidth:
                                case OSFramework.Maps.Enum.OS_Config_Marker.iconUrl:
                                case OSFramework.Maps.Enum.OS_Config_Marker.label:
                                    this._setIcon();
                                    break;
                                case OSFramework.Maps.Enum.OS_Config_Marker.title:
                                    this._provider.title = propertyValue;
                                    break;
                            }
                        }
                    }
                    dispose() {
                        if (this.isReady) {
                            this._provider.map = undefined;
                        }
                        this._provider = undefined;
                        super.dispose();
                    }
                    refreshProviderEvents() {
                        if (this.isReady)
                            this._setMarkerEvents();
                    }
                    validateProviderEvent(eventName) {
                        return (Google.Constants.Marker.ProviderEventNames[eventName] !== undefined ||
                            Google.Constants.Marker.ProviderEventNamesHtml[eventName] !== undefined);
                    }
                }
                Marker_1.Marker = Marker;
            })(Marker = Google.Marker || (Google.Marker = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Marker;
            (function (Marker) {
                class MarkerPopup extends Marker.Marker {
                    _setMarkerEvents() {
                        super._setMarkerEvents();
                        this._provider.addListener('click', () => {
                            this.refreshPopupContent();
                            this.openPopup();
                        });
                    }
                    get hasPopup() {
                        return true;
                    }
                    get markerTag() {
                        return OSFramework.Maps.Helper.Constants.markerPopupTag;
                    }
                    closePopup() {
                        this.map.features.infoWindow.closePopup();
                    }
                    openPopup() {
                        this.refreshPopupContent();
                        this.map.features.infoWindow.openPopup(this);
                    }
                    refreshPopupContent() {
                        this._contentString = OSFramework.Maps.Helper.GetElementByUniqueId(this.uniqueId).querySelector(OSFramework.Maps.Helper.Constants.markerPopup).innerHTML;
                        this.map.features.infoWindow.setPopupContent(this._contentString);
                    }
                }
                Marker.MarkerPopup = MarkerPopup;
            })(Marker = Google.Marker || (Google.Marker = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var OSMap;
            (function (OSMap) {
                let MapFactory;
                (function (MapFactory) {
                    function MakeMap(type, mapdId, configs) {
                        switch (type) {
                            case OSFramework.Maps.Enum.MapType.Map:
                                return new OSMap.Map(mapdId, configs);
                            case OSFramework.Maps.Enum.MapType.StaticMap:
                                return new OSMap.StaticMap(mapdId, configs);
                            default:
                                throw new Error(`There is no factory for this type of Map (${type})`);
                        }
                    }
                    MapFactory.MakeMap = MakeMap;
                })(MapFactory = OSMap.MapFactory || (OSMap.MapFactory = {}));
            })(OSMap = Google.OSMap || (Google.OSMap = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var OSMap;
            (function (OSMap) {
                class Map extends OSFramework.Maps.OSMap.AbstractMap {
                    constructor(mapId, configs) {
                        super(mapId, OSFramework.Maps.Enum.ProviderType.Google, new Google.Configuration.OSMap.GoogleMapConfig(configs), OSFramework.Maps.Enum.MapType.Map);
                        this._addedEvents = [];
                        this._scriptCallback = this._createGoogleMap.bind(this);
                        this._gZoomChangeListener = undefined;
                    }
                    _addMapZoomHandler() {
                        setTimeout(() => {
                            if (this && this._provider && this._gZoomChangeListener === undefined) {
                                this._gZoomChangeListener = google.maps.event.addListener(this._provider, Google.Constants.OSMap.ProviderEventNames.zoom_changed, this._mapZoomChangeCallback);
                            }
                        }, 100);
                    }
                    _buildDrawingTools() {
                        this.drawingTools && this.drawingTools.build();
                    }
                    _buildFileLayers() {
                        this.fileLayers.forEach((fileLayer) => fileLayer.build());
                    }
                    _buildHeatmapLayers() {
                        this.heatmapLayers.forEach((heatmapLayer) => heatmapLayer.build());
                    }
                    _buildMarkers() {
                        this.markers.forEach((marker) => marker.build());
                    }
                    _buildShapes() {
                        this.shapes.forEach((shape) => shape.build());
                    }
                    _createGoogleMap() {
                        if (this.isReady === undefined) {
                            return;
                        }
                        const script = document.getElementById(Google.Constants.googleMapsScript);
                        const apiKey = /key=(.*)&libraries/.exec(script.src)[1];
                        if (this.config.apiKey !== apiKey) {
                            return OSFramework.Maps.Helper.ThrowError(this, OSFramework.Maps.Enum.ErrorCodes.CFG_APIKeyDiffersFromPlacesToMaps);
                        }
                        const currentCenter = this.config.center;
                        const mapElement = OSFramework.Maps.Helper.GetElementByUniqueId(this.uniqueId, false);
                        if (mapElement !== undefined) {
                            this._provider = new google.maps.Map(mapElement.querySelector(OSFramework.Maps.Helper.Constants.runtimeMapUniqueIdCss), this._getProviderConfig());
                            window[Google.Constants.googleMapsAuthFailure] = () => this.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.LIB_InvalidApiKeyMap);
                            this.buildFeatures();
                            this._buildMarkers();
                            this._buildShapes();
                            this._buildDrawingTools();
                            this._buildFileLayers();
                            this._buildHeatmapLayers();
                            this.finishBuild();
                            this.features.center.updateCenter(currentCenter);
                            this._provider.setOptions(Object.assign({ styles: Google.GetStyleByStyleId(this.config.style) }, this._advancedFormatObj));
                            this._setMapEvents(this._advancedFormatObj.mapEvents);
                            this._addMapZoomHandler();
                        }
                    }
                    _getProviderConfig() {
                        this.config.center = OSFramework.Maps.Helper.Constants.defaultMapCenter;
                        if (this.config.useAdvancedMarkers) {
                            if (!this.config.mapStyleId) {
                                this.config.mapStyleId = this.uniqueId;
                            }
                        }
                        this._advancedFormatObj = OSFramework.Maps.Helper.JsonFormatter(this.config.advancedFormat);
                        return this.config.getProviderConfig();
                    }
                    _removeMapZoomHandler() {
                        if (this._gZoomChangeListener) {
                            google.maps.event.removeListener(this._gZoomChangeListener);
                            this._gZoomChangeListener = undefined;
                        }
                    }
                    _setMapEvents(events) {
                        Google.SharedComponents.RemoveEventsFromProvider(this);
                        if (this.mapEvents.hasHandlers(OSFramework.Maps.Event.OSMap.MapEventType.OnEventTriggered) &&
                            events !== undefined) {
                            events.forEach((eventName) => {
                                this._addedEvents.push(eventName);
                                this._provider.addListener(eventName, () => {
                                    this.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.OnEventTriggered, this, eventName);
                                });
                            });
                        }
                        this.mapEvents.handlers.forEach((handler, eventName) => {
                            if (handler instanceof OSFramework.Maps.Event.OSMap.MapProviderEvent) {
                                this._addedEvents.push(eventName);
                                this._provider.addListener(Google.Constants.OSMap.ProviderEventNames[eventName], (e) => {
                                    this.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.ProviderEvent, this, eventName, e !== undefined
                                        ? JSON.stringify(new OSFramework.Maps.OSStructures.OSMap.OSCoordinates(e.latLng.lat(), e.latLng.lng()))
                                        : undefined);
                                });
                            }
                        });
                    }
                    get addedEvents() {
                        return this._addedEvents;
                    }
                    get mapTag() {
                        return OSFramework.Maps.Helper.Constants.mapTag;
                    }
                    get useAdvancedMarkers() {
                        return this.config.useAdvancedMarkers;
                    }
                    addDrawingTools(drawingTools) {
                        super.addDrawingTools(drawingTools);
                        if (this.isReady) {
                            drawingTools.build();
                        }
                        return drawingTools;
                    }
                    addFileLayer(fileLayer) {
                        super.addFileLayer(fileLayer);
                        if (this.isReady) {
                            fileLayer.build();
                        }
                        return fileLayer;
                    }
                    addHeatmapLayer(fileLayer) {
                        super.addHeatmapLayer(fileLayer);
                        if (this.isReady) {
                            fileLayer.build();
                        }
                        return fileLayer;
                    }
                    addMarker(marker) {
                        super.addMarker(marker);
                        if (this.isReady) {
                            marker.build();
                        }
                        return marker;
                    }
                    addShape(shape) {
                        super.addShape(shape);
                        if (this.isReady) {
                            shape.build();
                        }
                        return shape;
                    }
                    build() {
                        super.build();
                        Google.SharedComponents.InitializeScripts(this.config.apiKey, this.config.localization, this._scriptCallback);
                    }
                    buildFeatures() {
                        this._fBuilder = new Google.Feature.FeatureBuilder(this);
                        this._features = this._fBuilder.features;
                        this._fBuilder.build();
                    }
                    changeDrawingToolsProperty(drawingToolsId, propertyName, propertyValue) {
                        const drawingTools = this.drawingTools;
                        if (drawingTools === undefined || drawingTools.uniqueId !== drawingToolsId) {
                            console.error(`changeDrawingToolsProperty - drawingToold id:${drawingToolsId} not found.`);
                        }
                        else {
                            drawingTools.changeProperty(propertyName, propertyValue);
                        }
                    }
                    changeFileLayerProperty(fileLayerId, propertyName, propertyValue) {
                        const fileLayer = this.getFileLayer(fileLayerId);
                        if (!fileLayer) {
                            console.error(`changeFileLayerProperty - fileLayer id:${fileLayerId} not found.`);
                        }
                        else {
                            fileLayer.changeProperty(propertyName, propertyValue);
                        }
                    }
                    changeHeatmapLayerProperty(heatmapLayerId, propertyName, propertyValue) {
                        const heatmapLayer = this.getHeatmapLayer(heatmapLayerId);
                        if (!heatmapLayer) {
                            console.error(`changeHeatmapLayerProperty - heatmapLayer id:${heatmapLayerId} not found.`);
                        }
                        else {
                            heatmapLayer.changeProperty(propertyName, propertyValue);
                        }
                    }
                    changeMarkerProperty(markerId, propertyName, propertyValue) {
                        const marker = this.getMarker(markerId);
                        if (!marker) {
                            console.error(`changeMarkerProperty - marker id:${markerId} not found.`);
                        }
                        else {
                            marker.changeProperty(propertyName, propertyValue);
                        }
                    }
                    changeProperty(propertyName, propertyValue) {
                        const propValue = OSFramework.Maps.Enum.OS_Config_Map[propertyName];
                        if (OSFramework.Maps.Enum.OS_Config_Map.useAdvancedMarkers !== propValue &&
                            OSFramework.Maps.Enum.OS_Config_Map.mapStyleId !== propValue) {
                            super.changeProperty(propertyName, propertyValue);
                        }
                        if (this.isReady) {
                            switch (propValue) {
                                case OSFramework.Maps.Enum.OS_Config_Map.apiKey:
                                    if (this.config.apiKey !== '') {
                                        this.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.CFG_APIKeyAlreadySetMap);
                                    }
                                    break;
                                case OSFramework.Maps.Enum.OS_Config_Map.center:
                                    this.features.center.updateCenter(propertyValue);
                                    break;
                                case OSFramework.Maps.Enum.OS_Config_Map.offset:
                                    this.features.offset.setOffset(JSON.parse(propertyValue));
                                    break;
                                case OSFramework.Maps.Enum.OS_Config_Map.localization:
                                    this.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.CFG_LocalizationAlreadySetMap);
                                    break;
                                case OSFramework.Maps.Enum.OS_Config_Map.zoom:
                                    this.features.zoom.setLevel(propertyValue);
                                    break;
                                case OSFramework.Maps.Enum.OS_Config_Map.type:
                                    this._provider.setMapTypeId(propertyValue);
                                    break;
                                case OSFramework.Maps.Enum.OS_Config_Map.style:
                                    this._provider.setOptions({
                                        styles: Google.GetStyleByStyleId(propertyValue),
                                    });
                                    break;
                                case OSFramework.Maps.Enum.OS_Config_Map.advancedFormat:
                                    propertyValue = OSFramework.Maps.Helper.JsonFormatter(propertyValue);
                                    this._setMapEvents(propertyValue.mapEvents);
                                    this._provider.setOptions(propertyValue);
                                    break;
                                case OSFramework.Maps.Enum.OS_Config_Map.showTraffic:
                                    this.features.trafficLayer.setState(propertyValue);
                                    break;
                                case OSFramework.Maps.Enum.OS_Config_Map.markerClustererActive:
                                case OSFramework.Maps.Enum.OS_Config_Map.markerClustererMaxZoom:
                                case OSFramework.Maps.Enum.OS_Config_Map.markerClustererMinClusterSize:
                                case OSFramework.Maps.Enum.OS_Config_Map.markerClustererZoomOnClick:
                                    this.features.markerClusterer.changeProperty(propertyName, propertyValue);
                                    break;
                                case OSFramework.Maps.Enum.OS_Config_Map.useAdvancedMarkers:
                                    this.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.GEN_InvalidChangePropertyUseAdvancedMarkers);
                                    break;
                                case OSFramework.Maps.Enum.OS_Config_Map.mapStyleId:
                                    this.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.GEN_InvalidChangePropertyMapStyleId);
                                    break;
                            }
                        }
                    }
                    changeShapeProperty(shapeId, propertyName, propertyValue) {
                        const shape = this.getShape(shapeId);
                        if (!shape) {
                            console.error(`changeShapeProperty - shape id:${shapeId} not found.`);
                        }
                        else {
                            shape.changeProperty(propertyName, propertyValue);
                        }
                    }
                    dispose() {
                        super.dispose();
                        if (this._fBuilder) {
                            this._fBuilder.dispose();
                        }
                        this._provider = undefined;
                    }
                    refresh(centerChanged) {
                        this._removeMapZoomHandler();
                        let position = this.features.center.getCenter();
                        const isDefault = position.lat === OSFramework.Maps.Helper.Constants.defaultMapCenter.lat &&
                            position.lng === OSFramework.Maps.Helper.Constants.defaultMapCenter.lng;
                        if (this.markers.length > 0) {
                            const markerProvider = this.markers[0].provider;
                            if (this.markers.length > 1) {
                                if (this.allowRefreshZoom) {
                                    if (markerProvider !== undefined) {
                                        if (isDefault || this.features.zoom.isAutofit) {
                                            position = markerProvider.position.toJSON();
                                        }
                                    }
                                }
                                else {
                                    position = centerChanged
                                        ? this.config.center
                                        : this.provider.getCenter().toJSON();
                                }
                            }
                            else if (markerProvider !== undefined) {
                                position = markerProvider.position.toJSON();
                            }
                        }
                        this.features.center.refreshCenter(position);
                        if (this.allowRefreshZoom) {
                            this.features.zoom.refreshZoom();
                        }
                        this.features.offset.setOffset(this.features.offset.getOffset);
                        this.hasMarkerClusterer() && this.features.markerClusterer.repaint();
                        this._addMapZoomHandler();
                    }
                    refreshProviderEvents() {
                        if (this.isReady)
                            this._setMapEvents();
                    }
                    setClusterRenderer(renderer) {
                        if (this.isReady) {
                            this.features.markerClusterer.setClusterRenderer(renderer);
                        }
                    }
                    validateProviderEvent(eventName) {
                        return Google.Constants.OSMap.ProviderEventNames[eventName] !== undefined;
                    }
                }
                OSMap.Map = Map;
            })(OSMap = Google.OSMap || (Google.OSMap = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var OSMap;
            (function (OSMap) {
                class StaticMap extends OSFramework.Maps.OSMap.AbstractMap {
                    constructor(mapId, configs) {
                        super(mapId, OSFramework.Maps.Enum.ProviderType.Google, new Google.Configuration.OSMap.GoogleStaticMapConfig(configs), OSFramework.Maps.Enum.MapType.StaticMap);
                    }
                    _getCenter(center) {
                        let position = center === undefined ? this.config.center : center;
                        if (this.markers.length >= 1) {
                            position = this.markers[0].config.location;
                        }
                        return position;
                    }
                    _getMarkers() {
                        return this.markers.reduce((acc, curr) => {
                            if (curr.config.iconUrl !== '') {
                                acc +=
                                    '&markers=icon:' +
                                        encodeURIComponent(curr.config.iconUrl) +
                                        '%7C' +
                                        encodeURIComponent(curr.config.location.replace(/[^.,\-a-zA-Z0-9 ]/g, ''));
                            }
                            else {
                                acc += '&markers=' + encodeURIComponent(curr.config.location.replace(/[^.,\-a-zA-Z0-9 ]/g, ''));
                            }
                            return acc;
                        }, '');
                    }
                    _getSize() {
                        const container = OSFramework.Maps.Helper.GetElementByUniqueId(this.uniqueId);
                        const width = container.offsetWidth;
                        const height = container.offsetHeight;
                        return {
                            width: Math.round(width / 2),
                            height: Math.round(height / 2),
                        };
                    }
                    _getZoom(level) {
                        if (level === undefined)
                            level = this.config.zoom;
                        if (level === OSFramework.Maps.Enum.OSMap.Zoom.Auto) {
                            if (this.markers.length > 0) {
                                return -1;
                            }
                            else {
                                return OSFramework.Maps.Enum.OSMap.Zoom.Zoom8;
                            }
                        }
                        else {
                            return level;
                        }
                    }
                    _renderImage() {
                        const container = OSFramework.Maps.Helper.GetElementByUniqueId(this.uniqueId);
                        const image = container.querySelector(OSFramework.Maps.Helper.Constants.staticMapCss);
                        image.src =
                            `${Google.Constants.googleMapsApiStaticMap}?` +
                                'key=' +
                                this.config.apiKey +
                                '&center=' +
                                this._center +
                                this._markerString +
                                '&maptype=' +
                                this._type +
                                (this._zoom > -1 ? '&zoom=' + this._zoom : '') +
                                '&scale=' +
                                2 +
                                '&size=' +
                                this._size.width +
                                'x' +
                                this._size.height +
                                (this.config.localization.language !== '' ? `&language=${this.config.localization.language}` : '') +
                                (this.config.localization.region !== '' ? `&region=${this.config.localization.region}` : '');
                        image.onerror = () => {
                            this.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.LIB_InvalidApiKeyStaticMap);
                            image.alt = 'Image could not be loaded due to invalid APIKey.';
                        };
                    }
                    get addedEvents() {
                        throw new Error('StaticMap provider has no events');
                    }
                    get mapTag() {
                        return OSFramework.Maps.Helper.Constants.staticMapTag;
                    }
                    get useAdvancedMarkers() {
                        return this.config.useAdvancedMarkers;
                    }
                    addMarker(marker) {
                        if (this.isReady) {
                            this.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.CFG_CantChangeParamsStaticMap);
                            return;
                        }
                        super.addMarker(marker);
                        return marker;
                    }
                    build() {
                        super.build();
                        this._center = this._getCenter();
                        this._zoom = this._getZoom();
                        this._markerString = this._getMarkers();
                        this._size = this._getSize();
                        this._type = this.config.type;
                        this._renderImage();
                        this.finishBuild();
                    }
                    changeDrawingToolsProperty(drawingToolsId, propertyName, propertyValue) {
                        this.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.CFG_CantChangeParamsStaticMap);
                        return;
                    }
                    changeFileLayerProperty(fileLayerId, propertyName, propertyValue) {
                        this.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.CFG_CantChangeParamsStaticMap);
                        return;
                    }
                    changeHeatmapLayerProperty(heatmapLayerId, propertyName, propertyValue) {
                        this.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.CFG_CantChangeParamsStaticMap);
                        return;
                    }
                    changeMarkerProperty(markerId, propertyName, propertyValue) {
                        this.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.CFG_CantChangeParamsStaticMap);
                        return;
                    }
                    changeProperty(propertyName, propertyValue) {
                        if (this.isReady) {
                            this.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.CFG_CantChangeParamsStaticMap);
                            return;
                        }
                        const propValue = OSFramework.Maps.Enum.OS_Config_StaticMap[propertyName];
                        switch (propValue) {
                            case OSFramework.Maps.Enum.OS_Config_StaticMap.apiKey:
                                if (this.config.apiKey !== '') {
                                    this.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.CFG_APIKeyAlreadySetStaticMap);
                                }
                                return super.changeProperty(propertyName, propertyValue);
                            case OSFramework.Maps.Enum.OS_Config_StaticMap.center:
                                this._center = this._getCenter(propertyValue);
                                return;
                            case OSFramework.Maps.Enum.OS_Config_StaticMap.zoom:
                                this._zoom = this._getZoom(propertyValue);
                                return;
                            case OSFramework.Maps.Enum.OS_Config_StaticMap.type:
                                this._type = propertyValue;
                                return;
                            default:
                                this.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.CFG_CantChangeParamsStaticMap);
                                return;
                        }
                    }
                    changeShapeProperty(shapeId, propertyName, propertyValue) {
                        this.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.CFG_CantChangeParamsStaticMap);
                        return;
                    }
                    dispose() {
                        super.dispose();
                    }
                    refresh() {
                        throw new Error(`Refresh method can't be used on a StaticMap`);
                    }
                    refreshProviderEvents() {
                        throw new Error("Refresh Provider Events method can't be used on a StaticMap because Static Maps don't have events.");
                    }
                    validateProviderEvent(eventName) {
                        throw new Error('StaticMap provider has no supported events');
                    }
                }
                OSMap.StaticMap = StaticMap;
            })(OSMap = Google.OSMap || (Google.OSMap = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var SearchPlaces;
            (function (SearchPlaces) {
                let SearchPlacesFactory;
                (function (SearchPlacesFactory) {
                    function MakeSearchPlaces(searchPlacesId, configs, searchPlacesVersion) {
                        switch (searchPlacesVersion) {
                            case "v1":
                                return new SearchPlaces.SearchPlacesLegacy(searchPlacesId, configs);
                            case "v2":
                                return new SearchPlaces.SearchPlaces(searchPlacesId, configs);
                            default:
                                throw new Error(`There is no factory for this Google Places API version (${searchPlacesVersion})`);
                        }
                    }
                    SearchPlacesFactory.MakeSearchPlaces = MakeSearchPlaces;
                })(SearchPlacesFactory = SearchPlaces.SearchPlacesFactory || (SearchPlaces.SearchPlacesFactory = {}));
            })(SearchPlaces = Google.SearchPlaces || (Google.SearchPlaces = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var SearchPlaces;
            (function (SearchPlaces_1) {
                class SearchPlaces extends OSFramework.Maps.SearchPlaces.AbstractSearchPlaces {
                    constructor(searchPlacesId, configs) {
                        super(searchPlacesId, new Google.Configuration.SearchPlaces.SearchPlacesConfig(configs));
                        this._searchPlacesTag = OSFramework.Maps.Helper.Constants.searchPlacesTag;
                        this._addedEvents = [];
                        this._scriptCallback = this._createGooglePlaces.bind(this);
                    }
                    _buildSearchArea(boundsString) {
                        const searchArea = JSON.parse(boundsString);
                        if (OSFramework.Maps.Helper.HasAllEmptyBounds(searchArea)) {
                            return undefined;
                        }
                        return this._convertStringToBounds(searchArea);
                    }
                    _convertStringToBounds(bounds) {
                        const errorCallback = () => {
                            this.searchPlacesEvents.trigger(OSFramework.Maps.Event.SearchPlaces.SearchPlacesEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.CFG_InvalidSearchPlacesSearchArea);
                        };
                        return Google.SharedComponents.ConvertStringToBounds(bounds, this.config.apiKey, errorCallback);
                    }
                    _createGooglePlaces() {
                        var _a, _b;
                        if (this._built === undefined) {
                            return;
                        }
                        this._prepareProviderConfigs(!!((_b = (_a = google === null || google === void 0 ? void 0 : google.maps) === null || _a === void 0 ? void 0 : _a.places) === null || _b === void 0 ? void 0 : _b.PlaceAutocompleteElement));
                    }
                    _createProvider(configs) {
                        const placesElement = OSFramework.Maps.Helper.GetElementByUniqueId(this.uniqueId, false);
                        if (placesElement !== undefined) {
                            this._provider = new google.maps.places.PlaceAutocompleteElement(configs);
                            placesElement.appendChild(this.provider);
                            window[Google.Constants.googleMapsAuthFailure] = () => {
                                this.searchPlacesEvents.trigger(OSFramework.Maps.Event.SearchPlaces.SearchPlacesEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.LIB_InvalidApiKeySearchPlaces);
                            };
                            this.finishBuild();
                            this._setSearchPlacesEvents();
                        }
                    }
                    _prepareProviderConfigs(isModuleAvailable) {
                        if (isModuleAvailable) {
                            const local_configs = this.getProviderConfig();
                            if (OSFramework.Maps.Helper.HasAllEmptyBounds(local_configs.locationRestriction) === false) {
                                const bounds = this._convertStringToBounds(local_configs.locationRestriction);
                                if (this._validCountriesMaxLength(this.config.countries) && bounds !== undefined) {
                                    bounds
                                        .then((coords) => {
                                        local_configs.locationRestriction =
                                            coords;
                                        this._createProvider(local_configs);
                                    })
                                        .catch((error) => {
                                        this.searchPlacesEvents.trigger(OSFramework.Maps.Event.SearchPlaces.SearchPlacesEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.LIB_FailedGeocodingSearchAreaLocations, undefined, `${error}`);
                                    });
                                }
                            }
                            else {
                                delete local_configs.locationRestriction;
                                this._createProvider(local_configs);
                            }
                        }
                        else {
                            this.searchPlacesEvents.trigger(OSFramework.Maps.Event.SearchPlaces.SearchPlacesEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.LIB_FailedGeocodingSearchAreaLocations, undefined, `The google.maps.places lib has not been loaded, or the version of Google Maps does not support it. Requires version > "3.59", loaded version is "${Google.Version.Get()}".`);
                        }
                    }
                    _setSearchPlacesEvents() {
                        Google.SharedComponents.RemoveEventsFromProvider(this);
                        if (this.searchPlacesEvents.hasHandlers(OSFramework.Maps.Event.SearchPlaces.SearchPlacesEventType.OnPlaceSelect)) {
                            this._addedEvents.push(Google.Constants.SearchPlaces.Events.OnPlaceSelect);
                            this._provider.addEventListener(Google.Constants.SearchPlaces.Events.OnPlaceSelect, async ({ placePrediction }) => {
                                const place = placePrediction.toPlace();
                                await place.fetchFields({ fields: ['displayName', 'formattedAddress', 'location'] });
                                const spParams = {
                                    name: place.displayName,
                                    coordinates: JSON.stringify({
                                        Lat: Google.Helper.Conversions.GetCoordinateValue(place.location.lat),
                                        Lng: Google.Helper.Conversions.GetCoordinateValue(place.location.lng),
                                    }),
                                    address: place.formattedAddress,
                                };
                                this.searchPlacesEvents.trigger(OSFramework.Maps.Event.SearchPlaces.SearchPlacesEventType.OnPlaceSelect, this, Google.Constants.SearchPlaces.Events.OnPlaceSelect, spParams);
                            });
                        }
                    }
                    _validCountriesMaxLength(countries) {
                        if (countries.length > 5) {
                            this.searchPlacesEvents.trigger(OSFramework.Maps.Event.SearchPlaces.SearchPlacesEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.CFG_MaximumCountriesNumber);
                            return false;
                        }
                        return true;
                    }
                    _validInput(input) {
                        if (input === undefined) {
                            this.searchPlacesEvents.trigger(OSFramework.Maps.Event.SearchPlaces.SearchPlacesEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.CFG_InvalidInputSearchPlaces);
                            return false;
                        }
                        return true;
                    }
                    get addedEvents() {
                        return this._addedEvents;
                    }
                    build() {
                        super.build();
                        Google.SharedComponents.InitializeScripts(this.config.apiKey, this.config.localization, this._scriptCallback);
                    }
                    changeProperty(propertyName, propertyValue) {
                        super.changeProperty(propertyName, propertyValue);
                        if (this.isReady) {
                            switch (OSFramework.Maps.Enum.OS_Config_SearchPlaces[propertyName]) {
                                case OSFramework.Maps.Enum.OS_Config_SearchPlaces.apiKey:
                                    if (this.config.apiKey !== '') {
                                        this.searchPlacesEvents.trigger(OSFramework.Maps.Event.SearchPlaces.SearchPlacesEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.CFG_APIKeyAlreadySetSearchPlaces);
                                    }
                                    break;
                                case OSFramework.Maps.Enum.OS_Config_SearchPlaces.localization:
                                    this.searchPlacesEvents.trigger(OSFramework.Maps.Event.SearchPlaces.SearchPlacesEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.CFG_LocalizationAlreadySetMap);
                                    break;
                                case OSFramework.Maps.Enum.OS_Config_SearchPlaces.searchArea:
                                    const searchArea = this._buildSearchArea(propertyValue);
                                    if (searchArea !== undefined) {
                                        searchArea
                                            .then((bounds) => {
                                            this.provider.locationBias = bounds;
                                        })
                                            .catch((error) => {
                                            this.searchPlacesEvents.trigger(OSFramework.Maps.Event.SearchPlaces.SearchPlacesEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.CFG_InvalidSearchPlacesSearchArea, undefined, `${error}`);
                                        });
                                    }
                                    else {
                                        this.provider.locationBias = undefined;
                                    }
                                    break;
                                case OSFramework.Maps.Enum.OS_Config_SearchPlaces.countries:
                                    const countries = JSON.parse(propertyValue);
                                    this._validCountriesMaxLength(countries) &&
                                        (this.provider.includedRegionCodes = countries);
                                    break;
                                case OSFramework.Maps.Enum.OS_Config_SearchPlaces.searchType:
                                    this.provider.includedPrimaryTypes = [
                                        Provider.Maps.Google.SearchPlaces.SearchTypes[propertyValue],
                                    ];
                                    break;
                            }
                        }
                    }
                    dispose() {
                        this._provider = undefined;
                        this._scriptCallback = undefined;
                        this._addedEvents = undefined;
                        super.dispose();
                    }
                }
                SearchPlaces_1.SearchPlaces = SearchPlaces;
            })(SearchPlaces = Google.SearchPlaces || (Google.SearchPlaces = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var SearchPlaces;
            (function (SearchPlaces) {
                class SearchPlacesLegacy extends OSFramework.Maps.SearchPlaces.AbstractSearchPlaces {
                    constructor(searchPlacesId, configs) {
                        super(searchPlacesId, new Google.Configuration.SearchPlaces.SearchPlacesLegacyConfig(configs));
                        this._searchPlacesTag = OSFramework.Maps.Helper.Constants.searchPlacesTag_Legacy;
                        this._addedEvents = [];
                        this._scriptCallback = this._createGooglePlaces.bind(this);
                    }
                    _buildSearchArea(boundsString) {
                        const searchArea = JSON.parse(boundsString);
                        if (OSFramework.Maps.Helper.HasAllEmptyBounds(searchArea)) {
                            return undefined;
                        }
                        return this._convertStringToBounds(searchArea);
                    }
                    _convertStringToBounds(bounds) {
                        const errorCallback = () => {
                            this.searchPlacesEvents.trigger(OSFramework.Maps.Event.SearchPlaces.SearchPlacesEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.CFG_InvalidSearchPlacesSearchArea);
                        };
                        return Google.SharedComponents.ConvertStringToBounds(bounds, this.config.apiKey, errorCallback);
                    }
                    _createGooglePlaces() {
                        if (this._built === undefined) {
                            return;
                        }
                        const script = document.getElementById(Google.Constants.googleMapsScript);
                        const apiKey = /key=(.*)&libraries/.exec(script.src)[1];
                        if (this.config.apiKey !== apiKey) {
                            return this.searchPlacesEvents.trigger(OSFramework.Maps.Event.SearchPlaces.SearchPlacesEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.CFG_APIKeyDiffersFromPlacesToMaps);
                        }
                        this._prepareProviderConfigs(true);
                    }
                    _createProvider(configs) {
                        const placesElement = OSFramework.Maps.Helper.GetElementByUniqueId(this.uniqueId, false);
                        if (placesElement !== undefined) {
                            const input = placesElement.querySelector(`${OSFramework.Maps.Helper.Constants.runtimeSearchPlacesUniqueIdCss} input`);
                            if (this._validInput(input) === false)
                                return;
                            this._provider = new google.maps.places.Autocomplete(input, configs);
                            window[Google.Constants.googleMapsAuthFailure] = () => {
                                this.searchPlacesEvents.trigger(OSFramework.Maps.Event.SearchPlaces.SearchPlacesEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.LIB_InvalidApiKeySearchPlaces);
                            };
                            this.finishBuild();
                            this._setSearchPlacesEvents();
                        }
                    }
                    _prepareProviderConfigs(moduleAvailable) {
                        if (moduleAvailable) {
                            const local_configs = this.getProviderConfig();
                            if (OSFramework.Maps.Helper.HasAllEmptyBounds(local_configs.bounds) === false) {
                                const bounds = this._convertStringToBounds(local_configs.bounds);
                                if (this._validCountriesMaxLength(this.config.countries) && bounds !== undefined) {
                                    bounds
                                        .then((coords) => {
                                        local_configs.bounds =
                                            coords;
                                        this._createProvider(local_configs);
                                    })
                                        .catch((error) => {
                                        this.searchPlacesEvents.trigger(OSFramework.Maps.Event.SearchPlaces.SearchPlacesEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.LIB_FailedGeocodingSearchAreaLocations, undefined, `${error}`);
                                    });
                                }
                            }
                            else {
                                delete local_configs.bounds;
                                this._createProvider(local_configs);
                            }
                        }
                        else {
                            this.searchPlacesEvents.trigger(OSFramework.Maps.Event.SearchPlaces.SearchPlacesEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.LIB_FailedGeocodingSearchAreaLocations, undefined, `The google.maps.places lib has not been loaded.`);
                        }
                    }
                    _setSearchPlacesEvents() {
                        Google.SharedComponents.RemoveEventsFromProvider(this);
                        if (this.searchPlacesEvents.hasHandlers(OSFramework.Maps.Event.SearchPlaces.SearchPlacesEventType.OnPlaceSelect)) {
                            this._addedEvents.push(Google.Constants.SearchPlaces.EventsLegacy.OnPlaceSelect);
                            this._provider.addListener(Google.Constants.SearchPlaces.EventsLegacy.OnPlaceSelect, () => {
                                const place = this._provider.getPlace();
                                const spParams = {
                                    name: place.name,
                                    coordinates: JSON.stringify({
                                        Lat: place.geometry.location.lat(),
                                        Lng: place.geometry.location.lng(),
                                    }),
                                    address: place.formatted_address,
                                };
                                place.geometry &&
                                    this.searchPlacesEvents.trigger(OSFramework.Maps.Event.SearchPlaces.SearchPlacesEventType.OnPlaceSelect, this, Google.Constants.SearchPlaces.EventsLegacy.OnPlaceSelect, spParams);
                            });
                        }
                    }
                    _validCountriesMaxLength(countries) {
                        if (countries.length > 5) {
                            this.searchPlacesEvents.trigger(OSFramework.Maps.Event.SearchPlaces.SearchPlacesEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.CFG_MaximumCountriesNumber);
                            return false;
                        }
                        return true;
                    }
                    _validInput(input) {
                        if (input === undefined) {
                            this.searchPlacesEvents.trigger(OSFramework.Maps.Event.SearchPlaces.SearchPlacesEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.CFG_InvalidInputSearchPlaces);
                            return false;
                        }
                        return true;
                    }
                    get addedEvents() {
                        return this._addedEvents;
                    }
                    build() {
                        super.build();
                        Google.SharedComponents.InitializeScripts(this.config.apiKey, this.config.localization, this._scriptCallback);
                    }
                    changeProperty(propertyName, propertyValue) {
                        super.changeProperty(propertyName, propertyValue);
                        if (this.isReady) {
                            switch (OSFramework.Maps.Enum.OS_Config_SearchPlaces[propertyName]) {
                                case OSFramework.Maps.Enum.OS_Config_SearchPlaces.apiKey:
                                    if (this.config.apiKey !== '') {
                                        this.searchPlacesEvents.trigger(OSFramework.Maps.Event.SearchPlaces.SearchPlacesEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.CFG_APIKeyAlreadySetSearchPlaces);
                                    }
                                    break;
                                case OSFramework.Maps.Enum.OS_Config_SearchPlaces.localization:
                                    this.searchPlacesEvents.trigger(OSFramework.Maps.Event.SearchPlaces.SearchPlacesEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.CFG_LocalizationAlreadySetMap);
                                    break;
                                case OSFramework.Maps.Enum.OS_Config_SearchPlaces.searchArea:
                                    const searchArea = this._buildSearchArea(propertyValue);
                                    if (searchArea !== undefined) {
                                        searchArea
                                            .then((bounds) => {
                                            this.provider.setBounds(bounds);
                                            this.provider.set('strictBounds', true);
                                        })
                                            .catch((error) => {
                                            this.searchPlacesEvents.trigger(OSFramework.Maps.Event.SearchPlaces.SearchPlacesEventType.OnError, this, OSFramework.Maps.Enum.ErrorCodes.CFG_InvalidSearchPlacesSearchArea, undefined, `${error}`);
                                        });
                                    }
                                    else {
                                        this.provider.set('bounds', null);
                                        this.provider.set('strictBounds', false);
                                    }
                                    break;
                                case OSFramework.Maps.Enum.OS_Config_SearchPlaces.countries:
                                    const countries = JSON.parse(propertyValue);
                                    return (this._validCountriesMaxLength(countries) &&
                                        this.provider.setComponentRestrictions({
                                            country: countries,
                                        }));
                                case OSFramework.Maps.Enum.OS_Config_SearchPlaces.searchType:
                                    return this.provider.setTypes([
                                        Provider.Maps.Google.SearchPlaces.SearchTypes[propertyValue],
                                    ]);
                            }
                        }
                    }
                    dispose() {
                        this._provider = undefined;
                        this._scriptCallback = undefined;
                        this._addedEvents = undefined;
                        super.dispose();
                    }
                }
                SearchPlaces.SearchPlacesLegacy = SearchPlacesLegacy;
            })(SearchPlaces = Google.SearchPlaces || (Google.SearchPlaces = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var SearchPlaces;
            (function (SearchPlaces) {
                let SearchTypes;
                (function (SearchTypes) {
                    SearchTypes["Addresses"] = "address";
                    SearchTypes["Cities"] = "(cities)";
                    SearchTypes["Establishments"] = "establishment";
                    SearchTypes["Geocodes"] = "geocode";
                    SearchTypes["Regions"] = "(regions)";
                })(SearchTypes = SearchPlaces.SearchTypes || (SearchPlaces.SearchTypes = {}));
            })(SearchPlaces = Google.SearchPlaces || (Google.SearchPlaces = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Shape;
            (function (Shape) {
                class AbstractProviderShape extends OSFramework.Maps.Shape.AbstractShape {
                    _resetShapeEvents() {
                        this._addedEvents.forEach((eventListener, index) => {
                            google.maps.event.clearListeners(this.provider, eventListener);
                            this._addedEvents.splice(index, 1);
                        });
                    }
                    _buildProvider(coordinates) {
                        if (coordinates !== undefined) {
                            coordinates
                                .then((coords) => {
                                this._provider = this._createProvider(coords);
                                this._setShapeEvents();
                                this.finishBuild();
                                this.map.refresh();
                            })
                                .catch((error) => {
                                OSFramework.Maps.Helper.ThrowError(this.map, OSFramework.Maps.Enum.ErrorCodes.LIB_FailedGeocodingShapeLocations, error);
                            });
                        }
                    }
                    _setShapeEvents() {
                        this._resetShapeEvents();
                        if (this.shapeEvents.hasHandlers(OSFramework.Maps.Event.Shape.ShapeEventType.OnClick) &&
                            this.provider.get('clickable')) {
                            this.provider.addListener('click', () => {
                                this.shapeEvents.trigger(OSFramework.Maps.Event.Shape.ShapeEventType.OnClick);
                            });
                        }
                        this.shapeEvents.handlers.forEach((handler, eventName) => {
                            if (handler instanceof OSFramework.Maps.Event.Shape.ShapeProviderEvent) {
                                if (eventName === OSFramework.Maps.Helper.Constants.shapeChangedEvent) {
                                    this._addedEvents.push(eventName);
                                    this.providerEventsList.forEach((event) => this.providerObjectListener.addListener(event, () => {
                                        if (this._shapeChangedEventTimeout) {
                                            clearTimeout(this._shapeChangedEventTimeout);
                                        }
                                        this._shapeChangedEventTimeout = setTimeout(this.triggerShapeChangedEvent.bind(this), 500);
                                    }));
                                }
                                else if (Google.Constants.Shape.ProviderSpecialEvents.indexOf(eventName) !== -1) {
                                    this._addedEvents.push(eventName);
                                    this.providerObjectListener.addListener(eventName, () => {
                                        this.shapeEvents.trigger(OSFramework.Maps.Event.Shape.ShapeEventType.ProviderEvent, eventName);
                                    });
                                }
                                else {
                                    this._addedEvents.push(eventName);
                                    this.provider.addListener(eventName, () => {
                                        this.shapeEvents.trigger(OSFramework.Maps.Event.Shape.ShapeEventType.ProviderEvent, eventName);
                                    });
                                }
                            }
                        });
                    }
                    get hasEvents() {
                        return this.shapeEvents !== undefined;
                    }
                    get provider() {
                        return this._provider;
                    }
                    get shapeProviderEvents() {
                        return Google.Constants.Shape.Events;
                    }
                    changeProperty(propertyName, propertyValue) {
                        const propValue = OSFramework.Maps.Enum.OS_Config_Shape[propertyName];
                        super.changeProperty(propertyName, propertyValue);
                        if (this.isReady) {
                            switch (propValue) {
                                case OSFramework.Maps.Enum.OS_Config_Shape.allowDrag:
                                    return this.provider.set('draggable', propertyValue);
                                case OSFramework.Maps.Enum.OS_Config_Shape.allowEdit:
                                    return this.provider.set('editable', propertyValue);
                                case OSFramework.Maps.Enum.OS_Config_Shape.strokeOpacity:
                                    return this.provider.set('strokeOpacity', propertyValue);
                                case OSFramework.Maps.Enum.OS_Config_Shape.strokeColor:
                                    return this.provider.set('strokeColor', propertyValue);
                                case OSFramework.Maps.Enum.OS_Config_Shape.strokeWeight:
                                    return this.provider.set('strokeWeight', propertyValue);
                            }
                        }
                    }
                    dispose() {
                        if (this.isReady) {
                            this.provider.set('map', null);
                        }
                        this._provider = undefined;
                        super.dispose();
                    }
                    refreshProviderEvents() {
                        if (this.isReady)
                            this._setShapeEvents();
                    }
                }
                Shape.AbstractProviderShape = AbstractProviderShape;
            })(Shape = Google.Shape || (Google.Shape = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Shape;
            (function (Shape) {
                class AbstractPolyshape extends Shape.AbstractProviderShape {
                    _buildPath(loc) {
                        if (this._validateLocations(loc)) {
                            const _locations = JSON.parse(loc);
                            return new Promise((resolve, reject) => {
                                const shapePath = new Map();
                                _locations.every((location, index) => {
                                    if (OSFramework.Maps.Helper.IsEmptyString(location)) {
                                        OSFramework.Maps.Helper.ThrowError(this.map, this.invalidShapeLocationErrorCode);
                                        return false;
                                    }
                                    Google.Helper.Conversions.ConvertToCoordinates(location)
                                        .then((response) => {
                                        shapePath.set(index, {
                                            lat: response.lat,
                                            lng: response.lng,
                                        });
                                        if (shapePath.size === _locations.length) {
                                            resolve(Array.from(shapePath.keys())
                                                .sort((a, b) => a - b)
                                                .map((key) => shapePath.get(key)));
                                        }
                                    })
                                        .catch((e) => reject(e));
                                    return true;
                                });
                            });
                        }
                    }
                    _validateLocations(loc) {
                        if (OSFramework.Maps.Helper.IsEmptyString(loc) || JSON.parse(loc).length < this.minPath) {
                            OSFramework.Maps.Helper.ThrowError(this.map, this.invalidShapeLocationErrorCode);
                            return false;
                        }
                        return true;
                    }
                    _setProviderPath(path) {
                        this._provider.setPath(path);
                    }
                    get providerBounds() {
                        const bounds = new google.maps.LatLngBounds();
                        this.providerPath.forEach(function (item) {
                            bounds.extend(new google.maps.LatLng(item.lat, item.lng));
                        });
                        return bounds;
                    }
                    get providerEventsList() {
                        return Google.Constants.Shape.ProviderPolyshapeEvents;
                    }
                    get providerObjectListener() {
                        return this.provider.getPath();
                    }
                    get providerPath() {
                        const path = this.provider.getPath();
                        if (path === undefined) {
                            OSFramework.Maps.Helper.ThrowError(this.map, OSFramework.Maps.Enum.ErrorCodes.API_FailedGettingShapePath);
                            return [];
                        }
                        return path.getArray().map((coords) => coords.toJSON());
                    }
                    build() {
                        super.build();
                        const shapePath = this._buildPath(this.config.locations);
                        this._buildProvider(shapePath);
                    }
                    changeProperty(propertyName, propertyValue) {
                        const propValue = OSFramework.Maps.Enum.OS_Config_Shape[propertyName];
                        super.changeProperty(propertyName, propertyValue);
                        if (this.isReady) {
                            switch (propValue) {
                                case OSFramework.Maps.Enum.OS_Config_Shape.locations:
                                    const shapePath = this._buildPath(propertyValue);
                                    if (shapePath !== undefined) {
                                        shapePath
                                            .then((path) => {
                                            this._setProviderPath(path);
                                        })
                                            .catch((error) => {
                                            OSFramework.Maps.Helper.ThrowError(this.map, OSFramework.Maps.Enum.ErrorCodes.LIB_FailedGeocodingShapeLocations, error);
                                        });
                                    }
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Shape.fillColor:
                                case OSFramework.Maps.Enum.OS_Config_Shape.fillOpacity:
                                    return this.provider.set(propertyName, propertyValue);
                            }
                        }
                    }
                }
                Shape.AbstractPolyshape = AbstractPolyshape;
            })(Shape = Google.Shape || (Google.Shape = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Shape;
            (function (Shape) {
                class Circle extends Shape.AbstractProviderShape {
                    constructor(map, shapeId, type, configs) {
                        super(map, shapeId, type, new Google.Configuration.Shape.CircleShapeConfig(configs));
                    }
                    _buildCenter(location) {
                        if (OSFramework.Maps.Helper.IsEmptyString(location)) {
                            OSFramework.Maps.Helper.ThrowError(this.map, this.invalidShapeLocationErrorCode);
                            return;
                        }
                        return new Promise((resolve, reject) => {
                            Google.Helper.Conversions.ConvertToCoordinates(location)
                                .then((response) => {
                                const coordinates = {
                                    lat: response.lat,
                                    lng: response.lng,
                                };
                                resolve(coordinates);
                            })
                                .catch((e) => reject(e));
                        });
                    }
                    _changeCenter(location) {
                        const shapeCenter = this._buildCenter(location);
                        if (shapeCenter !== undefined) {
                            shapeCenter
                                .then((center) => {
                                this.provider.setCenter(center);
                            })
                                .catch((error) => {
                                OSFramework.Maps.Helper.ThrowError(this.map, OSFramework.Maps.Enum.ErrorCodes.LIB_FailedGeocodingShapeLocations, error);
                            });
                        }
                    }
                    _createProvider(center) {
                        return new google.maps.Circle(Object.assign({ map: this.map.provider, center: center }, this.getProviderConfig()));
                    }
                    get invalidShapeLocationErrorCode() {
                        return OSFramework.Maps.Enum.ErrorCodes.CFG_InvalidCircleShapeCenter;
                    }
                    getShapeCoordinates() {
                        return {
                            coordinates: {
                                Lat: this.providerCenter.lat,
                                Lng: this.providerCenter.lng,
                            },
                            location: {
                                location: `${this.providerCenter.lat.toString()},${this.providerCenter.lng.toString()}`,
                                radius: this.providerRadius,
                            },
                        };
                    }
                    get providerBounds() {
                        return this.provider.getBounds();
                    }
                    get providerCenter() {
                        const center = this.provider.get('center');
                        if (center === undefined) {
                            OSFramework.Maps.Helper.ThrowError(this.map, OSFramework.Maps.Enum.ErrorCodes.API_FailedGettingShapeCenter);
                        }
                        return center.toJSON();
                    }
                    get providerEventsList() {
                        return Google.Constants.Shape.ProviderCircleEvents;
                    }
                    get providerObjectListener() {
                        return this.provider;
                    }
                    get providerRadius() {
                        const center = this.provider.get('radius');
                        if (center === undefined) {
                            OSFramework.Maps.Helper.ThrowError(this.map, OSFramework.Maps.Enum.ErrorCodes.API_FailedGettingShapeRadius);
                        }
                        return center;
                    }
                    get shapeTag() {
                        return OSFramework.Maps.Helper.Constants.shapeCircleTag;
                    }
                    build() {
                        super.build();
                        const shapeCenter = this._buildCenter(this.config.center);
                        super._buildProvider(shapeCenter);
                    }
                    changeProperty(propertyName, propertyValue) {
                        const propValue = OSFramework.Maps.Enum.OS_Config_Shape[propertyName];
                        super.changeProperty(propertyName, propertyValue);
                        if (this.isReady) {
                            switch (propValue) {
                                case OSFramework.Maps.Enum.OS_Config_Shape.center:
                                    this._changeCenter(propertyValue);
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Shape.radius:
                                    return this.provider.setRadius(propertyValue);
                                case OSFramework.Maps.Enum.OS_Config_Shape.fillColor:
                                case OSFramework.Maps.Enum.OS_Config_Shape.fillOpacity:
                                    return this.provider.set(propertyName, propertyValue);
                            }
                        }
                    }
                }
                Shape.Circle = Circle;
            })(Shape = Google.Shape || (Google.Shape = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Shape;
            (function (Shape) {
                let ShapeFactory;
                (function (ShapeFactory) {
                    function MakeShape(map, shapeId, type, configs) {
                        switch (type) {
                            case OSFramework.Maps.Enum.ShapeType.Polygon:
                                return new Shape.Polygon(map, shapeId, type, configs);
                            case OSFramework.Maps.Enum.ShapeType.Polyline:
                                return new Shape.Polyline(map, shapeId, type, configs);
                            case OSFramework.Maps.Enum.ShapeType.Circle:
                                return new Shape.Circle(map, shapeId, type, configs);
                            case OSFramework.Maps.Enum.ShapeType.Rectangle:
                                return new Shape.Rectangle(map, shapeId, type, configs);
                            default:
                                throw new Error(`There is no factory for this type of Shape (${type})`);
                        }
                    }
                    ShapeFactory.MakeShape = MakeShape;
                })(ShapeFactory = Shape.ShapeFactory || (Shape.ShapeFactory = {}));
            })(Shape = Google.Shape || (Google.Shape = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Shape;
            (function (Shape) {
                class Polygon extends Shape.AbstractPolyshape {
                    constructor(map, shapeId, type, configs) {
                        super(map, shapeId, type, new Google.Configuration.Shape.FilledShapeConfig(configs));
                    }
                    _createProvider(path) {
                        return new google.maps.Polygon(Object.assign({ map: this.map.provider, paths: path }, this.getProviderConfig()));
                    }
                    getShapeCoordinates() {
                        const locations = this.providerObjectPath.getArray().map((elm) => `${elm.lat()},${elm.lng()}`);
                        const coordinates = this.providerObjectPath.getArray().map((elm) => {
                            return {
                                Lat: elm.lat(),
                                Lng: elm.lng(),
                            };
                        });
                        return {
                            location: locations,
                            coordinates: coordinates,
                        };
                    }
                    get invalidShapeLocationErrorCode() {
                        return OSFramework.Maps.Enum.ErrorCodes.CFG_InvalidPolygonShapeLocations;
                    }
                    get providerObjectPath() {
                        return this.provider.getPath();
                    }
                    get shapeTag() {
                        return OSFramework.Maps.Helper.Constants.shapePolygonTag;
                    }
                }
                Shape.Polygon = Polygon;
            })(Shape = Google.Shape || (Google.Shape = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Shape;
            (function (Shape) {
                class Polyline extends Shape.AbstractPolyshape {
                    constructor(map, shapeId, type, configs) {
                        super(map, shapeId, type, new Google.Configuration.Shape.BasicShapeConfig(configs));
                    }
                    _createProvider(path) {
                        return new google.maps.Polyline(Object.assign({ map: this.map.provider, path: path }, this.getProviderConfig()));
                    }
                    getShapeCoordinates() {
                        const locations = this.providerObjectPath.getArray().map((elm) => `${elm.lat()},${elm.lng()}`);
                        const coordinates = this.providerObjectPath.getArray().map((elm) => {
                            return {
                                Lat: elm.lat(),
                                Lng: elm.lng(),
                            };
                        });
                        return {
                            location: locations,
                            coordinates: coordinates,
                        };
                    }
                    get invalidShapeLocationErrorCode() {
                        return OSFramework.Maps.Enum.ErrorCodes.CFG_InvalidPolylineShapeLocations;
                    }
                    get providerObjectPath() {
                        return this.provider.getPath();
                    }
                    get shapeTag() {
                        return OSFramework.Maps.Helper.Constants.shapePolylineTag;
                    }
                }
                Shape.Polyline = Polyline;
            })(Shape = Google.Shape || (Google.Shape = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Shape;
            (function (Shape) {
                class Rectangle extends Shape.AbstractProviderShape {
                    constructor(map, shapeId, type, configs) {
                        super(map, shapeId, type, new Google.Configuration.Shape.RectangleShapeConfig(configs));
                    }
                    _buildBounds(boundsString) {
                        const bounds = JSON.parse(boundsString);
                        if (OSFramework.Maps.Helper.HasAnyEmptyBound(bounds)) {
                            OSFramework.Maps.Helper.ThrowError(this.map, this.invalidShapeLocationErrorCode);
                            return;
                        }
                        return this._convertStringToBounds(bounds);
                    }
                    _convertStringToBounds(bounds) {
                        const cardinalDirections = ['north', 'south', 'east', 'west'];
                        return new Promise((resolve, reject) => {
                            let boundsLength = 0;
                            const newBounds = new OSFramework.Maps.OSStructures.OSMap.Bounds();
                            cardinalDirections.forEach((cd) => {
                                const regexValidator = /^-{0,1}\d*\.{0,1}\d*$/;
                                if (regexValidator.test(bounds[cd])) {
                                    boundsLength++;
                                    newBounds[cd] = parseFloat(bounds[cd]);
                                    if (boundsLength === 4) {
                                        resolve(newBounds);
                                    }
                                }
                                else {
                                    Google.Helper.Conversions.ConvertToCoordinates(bounds[cd])
                                        .then((response) => {
                                        boundsLength++;
                                        switch (cd) {
                                            case 'north':
                                            case 'south':
                                                newBounds[cd] = response.lat;
                                                break;
                                            case 'east':
                                            case 'west':
                                            default:
                                                newBounds[cd] = response.lng;
                                                break;
                                        }
                                        if (boundsLength === 4) {
                                            resolve(newBounds);
                                        }
                                    })
                                        .catch((e) => reject(e));
                                }
                            });
                        });
                    }
                    _createProvider(bounds) {
                        return new google.maps.Rectangle(Object.assign({ map: this.map.provider, bounds: bounds }, this.getProviderConfig()));
                    }
                    getShapeCoordinates() {
                        const bounds = {
                            north: this.bounds.north,
                            south: this.bounds.south,
                            west: this.bounds.west,
                            east: this.bounds.east,
                        };
                        return {
                            location: bounds,
                            coordinates: bounds,
                        };
                    }
                    get invalidShapeLocationErrorCode() {
                        return OSFramework.Maps.Enum.ErrorCodes.CFG_InvalidRectangleShapeBounds;
                    }
                    get bounds() {
                        const providerBounds = this.providerBounds;
                        const bounds = new OSFramework.Maps.OSStructures.OSMap.Bounds();
                        bounds.east = providerBounds.getNorthEast().lng();
                        bounds.north = providerBounds.getNorthEast().lat();
                        bounds.west = providerBounds.getSouthWest().lng();
                        bounds.south = providerBounds.getSouthWest().lat();
                        return bounds;
                    }
                    get providerBounds() {
                        return this.provider.getBounds();
                    }
                    get providerEventsList() {
                        return Google.Constants.Shape.ProviderRectangleEvents;
                    }
                    get providerObjectListener() {
                        return this.provider;
                    }
                    get shapeTag() {
                        return OSFramework.Maps.Helper.Constants.shapeRectangleTag;
                    }
                    build() {
                        super.build();
                        const bounds = this._buildBounds(this.config.bounds);
                        super._buildProvider(bounds);
                    }
                    changeProperty(propertyName, propertyValue) {
                        const propValue = OSFramework.Maps.Enum.OS_Config_Shape[propertyName];
                        super.changeProperty(propertyName, propertyValue);
                        if (this.isReady) {
                            switch (propValue) {
                                case OSFramework.Maps.Enum.OS_Config_Shape.fillColor:
                                case OSFramework.Maps.Enum.OS_Config_Shape.fillOpacity:
                                    return this.provider.set(propertyName, propertyValue);
                                case OSFramework.Maps.Enum.OS_Config_Shape.bounds:
                                    const shapeBounds = this._buildBounds(propertyValue);
                                    if (shapeBounds !== undefined) {
                                        shapeBounds
                                            .then((bounds) => {
                                            this.provider.setBounds(bounds);
                                        })
                                            .catch((error) => {
                                            OSFramework.Maps.Helper.ThrowError(this.map, OSFramework.Maps.Enum.ErrorCodes.LIB_FailedGeocodingShapeLocations, error);
                                        });
                                    }
                                    return;
                            }
                        }
                    }
                }
                Shape.Rectangle = Rectangle;
            })(Shape = Google.Shape || (Google.Shape = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var SharedComponents;
            (function (SharedComponents) {
                let googleMapsLoadPromise = undefined;
                let googleMapsIsLoaded = false;
                function InitializeScripts(apiKey, localization, cb) {
                    if (googleMapsIsLoaded) {
                        cb();
                    }
                    else {
                        if (googleMapsLoadPromise === undefined) {
                            googleMapsLoadPromise = new Promise((resolve) => {
                                window.GMCB = () => {
                                    window.GMCB = undefined;
                                    resolve(0);
                                    googleMapsLoadPromise = undefined;
                                    googleMapsIsLoaded = true;
                                };
                                const script = document.createElement('script');
                                script.src =
                                    `${Google.Constants.googleMapsApiMap}?` +
                                        `key=${apiKey}` +
                                        `&libraries=${Google.Constants.GoogleMapsLibraries}` +
                                        `&v=${Google.Version.Get()}` +
                                        `&loading=async` +
                                        `&callback=GMCB` +
                                        (localization.language !== '' ? `&language=${localization.language}` : '') +
                                        (localization.region !== '' ? `&region=${localization.region}` : '');
                                script.async = true;
                                script.defer = true;
                                script.id = Google.Constants.googleMapsScript;
                                document.head.appendChild(script);
                            });
                        }
                        googleMapsLoadPromise.then(cb);
                    }
                }
                SharedComponents.InitializeScripts = InitializeScripts;
                function RemoveEventsFromProvider(object) {
                    object.addedEvents.forEach((eventListener, index) => {
                        google.maps.event.clearListeners(object.provider, eventListener);
                        object.addedEvents.splice(index, 1);
                    });
                }
                SharedComponents.RemoveEventsFromProvider = RemoveEventsFromProvider;
                function ConvertStringToBounds(bounds, apiKey, errorCb) {
                    if (OSFramework.Maps.Helper.HasAnyEmptyBound(bounds)) {
                        errorCb();
                        return;
                    }
                    const cardinalDirections = ['north', 'south', 'east', 'west'];
                    return new Promise((resolve, reject) => {
                        let boundsLength = 0;
                        const finalBounds = new OSFramework.Maps.OSStructures.OSMap.Bounds();
                        cardinalDirections.forEach((cd) => {
                            const regexValidator = /^-{0,1}\d*\.{0,1}\d*$/;
                            if (regexValidator.test(bounds[cd])) {
                                boundsLength++;
                                finalBounds[cd] = parseFloat(bounds[cd]);
                                if (boundsLength === 4) {
                                    resolve(finalBounds);
                                }
                            }
                            else {
                                Google.Helper.Conversions.ConvertToCoordinates(bounds[cd])
                                    .then((response) => {
                                    boundsLength++;
                                    switch (cd) {
                                        case 'north':
                                        case 'south':
                                            finalBounds[cd] = response.lat;
                                            break;
                                        case 'east':
                                        case 'west':
                                        default:
                                            finalBounds[cd] = response.lng;
                                            break;
                                    }
                                    if (boundsLength === 4) {
                                        resolve(finalBounds);
                                    }
                                })
                                    .catch((e) => reject(e));
                            }
                        });
                    });
                }
                SharedComponents.ConvertStringToBounds = ConvertStringToBounds;
            })(SharedComponents = Google.SharedComponents || (Google.SharedComponents = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Google;
        (function (Google) {
            var Version;
            (function (Version) {
                function GetGoogleMapsVersion() {
                    let version = undefined;
                    if (window.google && window.google.maps && window.google.maps.version) {
                        const gmVersion = window.google.maps.version;
                        const indexMajorMinor = gmVersion.lastIndexOf('.');
                        version = gmVersion.substring(0, indexMajorMinor);
                    }
                    return version;
                }
                function Change(newVersion) {
                    const currentVersion = OSFramework.Maps.Helper.LocalStorage.GetItem(Google.Constants.googleMapsLocalStorageVersionKey) ||
                        Google.Constants.googleMapsVersion;
                    const googleVersion = GetGoogleMapsVersion();
                    const versionChanged = currentVersion !== newVersion && newVersion !== googleVersion;
                    OSFramework.Maps.Helper.LocalStorage.SetItem(Google.Constants.googleMapsLocalStorageVersionKey, newVersion);
                    return versionChanged;
                }
                Version.Change = Change;
                function Get() {
                    let currentVersion = OSFramework.Maps.Helper.LocalStorage.GetItem(Google.Constants.googleMapsLocalStorageVersionKey) ||
                        Provider.Maps.Google.Constants.googleMapsVersion;
                    const googleVersion = GetGoogleMapsVersion();
                    if (googleVersion !== undefined && currentVersion !== googleVersion) {
                        OSFramework.Maps.Helper.LogWarningMessage(`Current version of Google Maps loaded is '${googleVersion}', but on the next page refresh the version will tentatively be '${currentVersion}'.`);
                        currentVersion = googleVersion;
                    }
                    return currentVersion;
                }
                Version.Get = Get;
            })(Version = Google.Version || (Google.Version = {}));
        })(Google = Maps.Google || (Maps.Google = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Configuration;
            (function (Configuration) {
                var DrawingTools;
                (function (DrawingTools) {
                    class DrawConfig extends OSFramework.Maps.Configuration.AbstractConfiguration {
                        getProviderConfig() {
                            let provider = {
                                repeatMode: false,
                            };
                            Object.keys(provider).forEach((key) => {
                                if (provider[key] === undefined)
                                    delete provider[key];
                            });
                            return provider;
                        }
                    }
                    DrawingTools.DrawConfig = DrawConfig;
                })(DrawingTools = Configuration.DrawingTools || (Configuration.DrawingTools = {}));
            })(Configuration = Leaflet.Configuration || (Leaflet.Configuration = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Configuration;
            (function (Configuration) {
                var DrawingTools;
                (function (DrawingTools) {
                    class DrawBasicShapeConfig extends DrawingTools.DrawConfig {
                        getProviderConfig() {
                            const configs = super.getProviderConfig();
                            let provider = Object.assign(Object.assign({}, configs), { shapeOptions: {
                                    color: this.strokeColor,
                                    opacity: this.strokeOpacity,
                                    weight: this.strokeWeight,
                                } });
                            Object.keys(provider).forEach((key) => {
                                if (provider[key] === undefined)
                                    delete provider[key];
                            });
                            return provider;
                        }
                    }
                    DrawingTools.DrawBasicShapeConfig = DrawBasicShapeConfig;
                })(DrawingTools = Configuration.DrawingTools || (Configuration.DrawingTools = {}));
            })(Configuration = Leaflet.Configuration || (Leaflet.Configuration = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Configuration;
            (function (Configuration) {
                var DrawingTools;
                (function (DrawingTools) {
                    class DrawFilledShapeConfig extends DrawingTools.DrawBasicShapeConfig {
                        getProviderConfig() {
                            let provider = super.getProviderConfig();
                            provider.shapeOptions.fillColor = this.fillColor;
                            provider.shapeOptions.fillOpacity = this.fillOpacity;
                            Object.keys(provider).forEach((key) => {
                                if (provider[key] === undefined)
                                    delete provider[key];
                            });
                            return provider;
                        }
                    }
                    DrawingTools.DrawFilledShapeConfig = DrawFilledShapeConfig;
                })(DrawingTools = Configuration.DrawingTools || (Configuration.DrawingTools = {}));
            })(Configuration = Leaflet.Configuration || (Leaflet.Configuration = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Configuration;
            (function (Configuration) {
                var DrawingTools;
                (function (DrawingTools) {
                    class DrawMarkerConfig extends DrawingTools.DrawConfig {
                    }
                    DrawingTools.DrawMarkerConfig = DrawMarkerConfig;
                })(DrawingTools = Configuration.DrawingTools || (Configuration.DrawingTools = {}));
            })(Configuration = Leaflet.Configuration || (Leaflet.Configuration = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Configuration;
            (function (Configuration) {
                var DrawingTools;
                (function (DrawingTools) {
                    class DrawingToolsConfig extends OSFramework.Maps.Configuration.AbstractConfiguration {
                        getProviderConfig() {
                            return {
                                position: this.position,
                            };
                        }
                    }
                    DrawingTools.DrawingToolsConfig = DrawingToolsConfig;
                })(DrawingTools = Configuration.DrawingTools || (Configuration.DrawingTools = {}));
            })(Configuration = Leaflet.Configuration || (Leaflet.Configuration = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Configuration;
            (function (Configuration) {
                var Marker;
                (function (Marker) {
                    class LeafletMarkerConfig extends OSFramework.Maps.Configuration.AbstractConfiguration {
                        constructor(config) {
                            super(config);
                            this.iconHeight = Number(this.iconHeight);
                            this.iconWidth = Number(this.iconWidth);
                        }
                        getProviderConfig() {
                            const provider = {
                                draggable: this.allowDrag,
                                title: this.title,
                            };
                            Object.keys(provider).forEach((key) => {
                                if (provider[key] === undefined)
                                    delete provider[key];
                            });
                            return provider;
                        }
                    }
                    Marker.LeafletMarkerConfig = LeafletMarkerConfig;
                })(Marker = Configuration.Marker || (Configuration.Marker = {}));
            })(Configuration = Leaflet.Configuration || (Leaflet.Configuration = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Configuration;
            (function (Configuration) {
                var OSMap;
                (function (OSMap) {
                    class LeafletMapConfig extends OSFramework.Maps.Configuration.AbstractConfiguration {
                        getProviderConfig() {
                            let provider = {
                                center: this.center,
                                zoom: this.zoom,
                                editable: true,
                            };
                            Object.keys(provider).forEach((key) => {
                                if (provider[key] === undefined) {
                                    delete provider[key];
                                }
                            });
                            return provider;
                        }
                    }
                    OSMap.LeafletMapConfig = LeafletMapConfig;
                })(OSMap = Configuration.OSMap || (Configuration.OSMap = {}));
            })(Configuration = Leaflet.Configuration || (Leaflet.Configuration = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Configuration;
            (function (Configuration) {
                var Shape;
                (function (Shape) {
                    class BasicShapeConfig extends OSFramework.Maps.Configuration.AbstractConfiguration {
                        getProviderConfig() {
                            const provider = {
                                draggable: true,
                                editable: false,
                                opacity: this.strokeOpacity,
                                color: this.strokeColor,
                                weight: this.strokeWeight,
                            };
                            Object.keys(provider).forEach((key) => {
                                if (provider[key] === undefined)
                                    delete provider[key];
                            });
                            return provider;
                        }
                    }
                    Shape.BasicShapeConfig = BasicShapeConfig;
                })(Shape = Configuration.Shape || (Configuration.Shape = {}));
            })(Configuration = Leaflet.Configuration || (Leaflet.Configuration = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Configuration;
            (function (Configuration) {
                var Shape;
                (function (Shape) {
                    class FilledShapeConfig extends Shape.BasicShapeConfig {
                        getProviderConfig() {
                            const provider = super.getProviderConfig();
                            provider.fillColor = this.fillColor;
                            provider.fillOpacity = this.fillOpacity;
                            return provider;
                        }
                    }
                    Shape.FilledShapeConfig = FilledShapeConfig;
                })(Shape = Configuration.Shape || (Configuration.Shape = {}));
            })(Configuration = Leaflet.Configuration || (Leaflet.Configuration = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Configuration;
            (function (Configuration) {
                var Shape;
                (function (Shape) {
                    class CircleShapeConfig extends Shape.FilledShapeConfig {
                        getProviderConfig() {
                            const provider = super.getProviderConfig();
                            provider.radius = this.radius;
                            delete provider.locations;
                            return provider;
                        }
                    }
                    Shape.CircleShapeConfig = CircleShapeConfig;
                })(Shape = Configuration.Shape || (Configuration.Shape = {}));
            })(Configuration = Leaflet.Configuration || (Leaflet.Configuration = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Configuration;
            (function (Configuration) {
                var Shape;
                (function (Shape) {
                    class RectangleShapeConfig extends Shape.FilledShapeConfig {
                        getProviderConfig() {
                            const provider = super.getProviderConfig();
                            delete provider.locations;
                            return provider;
                        }
                    }
                    Shape.RectangleShapeConfig = RectangleShapeConfig;
                })(Shape = Configuration.Shape || (Configuration.Shape = {}));
            })(Configuration = Leaflet.Configuration || (Leaflet.Configuration = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Constants;
            (function (Constants) {
                Constants.leafletVersion = '1.9.4';
                Constants.drawingLeafletCompleted = 'draw:created';
                Constants.openStreetMapTileLayer = {
                    url: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                };
            })(Constants = Leaflet.Constants || (Leaflet.Constants = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Constants;
            (function (Constants) {
                var Directions;
                (function (Directions) {
                    let Events;
                    (function (Events) {
                        Events["routesfound"] = "routesfound";
                    })(Events = Directions.Events || (Directions.Events = {}));
                })(Directions = Constants.Directions || (Constants.Directions = {}));
            })(Constants = Leaflet.Constants || (Leaflet.Constants = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider_1) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Constants;
            (function (Constants) {
                var Directions;
                (function (Directions) {
                    let Provider;
                    (function (Provider) {
                        Provider["OSRM"] = "osrmv1";
                        Provider["MapBox"] = "mapbox";
                        Provider["GraphHopper"] = "graphHopper";
                    })(Provider = Directions.Provider || (Directions.Provider = {}));
                })(Directions = Constants.Directions || (Constants.Directions = {}));
            })(Constants = Leaflet.Constants || (Leaflet.Constants = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider_1.Maps || (Provider_1.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Constants;
            (function (Constants) {
                var Directions;
                (function (Directions) {
                    var OSRM;
                    (function (OSRM) {
                        let TravelModes;
                        (function (TravelModes) {
                            TravelModes["DRIVING"] = "car";
                            TravelModes["BICYCLING"] = "bike";
                            TravelModes["WALKING"] = "foot";
                        })(TravelModes = OSRM.TravelModes || (OSRM.TravelModes = {}));
                    })(OSRM = Directions.OSRM || (Directions.OSRM = {}));
                })(Directions = Constants.Directions || (Constants.Directions = {}));
            })(Constants = Leaflet.Constants || (Leaflet.Constants = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Constants;
            (function (Constants) {
                var Directions;
                (function (Directions) {
                    var MapBox;
                    (function (MapBox) {
                        let TravelModes;
                        (function (TravelModes) {
                            TravelModes["DRIVING"] = "mapbox/driving";
                            TravelModes["BICYCLING"] = "mapbox/cycling";
                            TravelModes["WALKING"] = "mapbox/walking";
                        })(TravelModes = MapBox.TravelModes || (MapBox.TravelModes = {}));
                    })(MapBox = Directions.MapBox || (Directions.MapBox = {}));
                })(Directions = Constants.Directions || (Constants.Directions = {}));
            })(Constants = Leaflet.Constants || (Leaflet.Constants = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Constants;
            (function (Constants) {
                var Directions;
                (function (Directions) {
                    var GraphHopper;
                    (function (GraphHopper) {
                        let TravelModes;
                        (function (TravelModes) {
                            TravelModes["DRIVING"] = "car";
                            TravelModes["BICYCLING"] = "bike";
                            TravelModes["WALKING"] = "foot";
                        })(TravelModes = GraphHopper.TravelModes || (GraphHopper.TravelModes = {}));
                    })(GraphHopper = Directions.GraphHopper || (Directions.GraphHopper = {}));
                })(Directions = Constants.Directions || (Constants.Directions = {}));
            })(Constants = Leaflet.Constants || (Leaflet.Constants = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Constants;
            (function (Constants) {
                var Directions;
                (function (Directions) {
                    var TomTom;
                    (function (TomTom) {
                        let TravelModes;
                        (function (TravelModes) {
                            TravelModes["DRIVING"] = "car";
                            TravelModes["BICYCLING"] = "bicycle";
                            TravelModes["WALKING"] = "pedestrian";
                            TravelModes["TRANSIT"] = "bus";
                        })(TravelModes = TomTom.TravelModes || (TomTom.TravelModes = {}));
                    })(TomTom = Directions.TomTom || (Directions.TomTom = {}));
                })(Directions = Constants.Directions || (Constants.Directions = {}));
            })(Constants = Leaflet.Constants || (Leaflet.Constants = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Constants;
            (function (Constants) {
                var DrawingTools;
                (function (DrawingTools) {
                    DrawingTools.Events = [
                        'circlecomplete',
                        'markercomplete',
                        'polylinecomplete',
                        'polygoncomplete',
                        'rectanglecomplete',
                    ];
                })(DrawingTools = Constants.DrawingTools || (Constants.DrawingTools = {}));
            })(Constants = Leaflet.Constants || (Leaflet.Constants = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Constants;
            (function (Constants) {
                var DrawingTools;
                (function (DrawingTools) {
                    let Positions;
                    (function (Positions) {
                        Positions["BOTTOM_LEFT"] = "bottomleft";
                        Positions["BOTTOM_RIGHT"] = "bottomright";
                        Positions["TOP_LEFT"] = "topleft";
                        Positions["TOP_RIGHT"] = "topright";
                    })(Positions = DrawingTools.Positions || (DrawingTools.Positions = {}));
                })(DrawingTools = Constants.DrawingTools || (Constants.DrawingTools = {}));
            })(Constants = Leaflet.Constants || (Leaflet.Constants = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Constants;
            (function (Constants) {
                var Marker;
                (function (Marker) {
                    Marker.defaultSize = [24, 40];
                    Marker.defaultAnchor = [12, 40];
                })(Marker = Constants.Marker || (Constants.Marker = {}));
            })(Constants = Leaflet.Constants || (Leaflet.Constants = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Constants;
            (function (Constants) {
                var Marker;
                (function (Marker) {
                    let ProviderEventNames;
                    (function (ProviderEventNames) {
                        ProviderEventNames["click"] = "click";
                        ProviderEventNames["contextmenu"] = "contextmenu";
                        ProviderEventNames["rightclick"] = "contextmenu";
                        ProviderEventNames["dblclick"] = "dblclick";
                        ProviderEventNames["drag"] = "drag";
                        ProviderEventNames["dragend"] = "dragend";
                        ProviderEventNames["dragstart"] = "dragstart";
                        ProviderEventNames["mousedown"] = "mousedown";
                        ProviderEventNames["mouseout"] = "mouseout";
                        ProviderEventNames["mouseover"] = "mouseover";
                        ProviderEventNames["mouseup"] = "mouseup";
                    })(ProviderEventNames = Marker.ProviderEventNames || (Marker.ProviderEventNames = {}));
                })(Marker = Constants.Marker || (Constants.Marker = {}));
            })(Constants = Leaflet.Constants || (Leaflet.Constants = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Constants;
            (function (Constants) {
                var OSMap;
                (function (OSMap) {
                    let ProviderEventNames;
                    (function (ProviderEventNames) {
                        ProviderEventNames["click"] = "click";
                        ProviderEventNames["contextmenu"] = "contextmenu";
                        ProviderEventNames["rightclick"] = "contextmenu";
                        ProviderEventNames["dblclick"] = "dblclick";
                        ProviderEventNames["drag"] = "drag";
                        ProviderEventNames["dragend"] = "dragend";
                        ProviderEventNames["dragstart"] = "dragstart";
                        ProviderEventNames["mousemove"] = "mousemove";
                        ProviderEventNames["mouseout"] = "mouseout";
                        ProviderEventNames["mouseover"] = "mouseover";
                        ProviderEventNames["resize"] = "resize";
                        ProviderEventNames["tilesloaded"] = "load";
                        ProviderEventNames["load"] = "load";
                        ProviderEventNames["zoom_changed"] = "zoom";
                        ProviderEventNames["zoom_end"] = "zoomend";
                        ProviderEventNames["zoom"] = "zoom";
                    })(ProviderEventNames = OSMap.ProviderEventNames || (OSMap.ProviderEventNames = {}));
                })(OSMap = Constants.OSMap || (Constants.OSMap = {}));
            })(Constants = Leaflet.Constants || (Leaflet.Constants = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Constants;
            (function (Constants) {
                var Shape;
                (function (Shape) {
                    Shape.Events = [
                        'click',
                        'contextmenu',
                        'dblclick',
                        'drag',
                        'dragend',
                        'dragstart',
                        'mousedown',
                        'mouseout',
                        'mouseover',
                        'mouseup',
                        'rightclick',
                        'shape_changed',
                        'editable:editing',
                    ];
                    Shape.ProviderPolyshapeEvents = ['editable:editing', 'dragend'];
                    Shape.ProviderCircleEvents = Shape.ProviderPolyshapeEvents;
                    Shape.ProviderRectangleEvents = Shape.ProviderPolyshapeEvents;
                    Shape.ProviderSpecialEvents = [
                        'shape_changed',
                        ...Shape.ProviderPolyshapeEvents,
                        ...Shape.ProviderCircleEvents,
                        ...Shape.ProviderRectangleEvents,
                    ];
                })(Shape = Constants.Shape || (Constants.Shape = {}));
            })(Constants = Leaflet.Constants || (Leaflet.Constants = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var DrawingTools;
            (function (DrawingTools) {
                class AbstractProviderTool extends OSFramework.Maps.DrawingTools.AbstractTool {
                    constructor(map, drawingTools, drawingToolsId, type, configs) {
                        super(map, drawingTools, drawingToolsId, type, configs);
                        this.internalOptions = {};
                    }
                    _addCompletedEventHandler(event) {
                        const uniqueId = OSFramework.Maps.Helper.GenerateUniqueId();
                        this.newElm = this.createElement(uniqueId, event.layer, this.config);
                        this.drawingTools.createdElements.push(this.newElm);
                        const location = this.getLocation();
                        const coordinates = this.getCoordinates();
                        this.triggerOnDrawingChangeEvent(uniqueId, true, coordinates, location);
                    }
                    triggerOnDrawingChangeEvent(uniqueId, isNewElement, coordinates, location) {
                        this.drawingTools.drawingToolsEvents.trigger(OSFramework.Maps.Event.DrawingTools.DrawingToolsEventType.ProviderEvent, this.completedToolEventName, { uniqueId, isNewElement, coordinates, location });
                    }
                    addCompletedEvent(event) {
                        this._addCompletedEventHandler(event);
                    }
                    build() {
                        super.build();
                        this.options = this.getProviderConfig();
                        this.finishBuild();
                    }
                    dispose() {
                        super.dispose();
                    }
                }
                DrawingTools.AbstractProviderTool = AbstractProviderTool;
            })(DrawingTools = Leaflet.DrawingTools || (Leaflet.DrawingTools = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var DrawingTools;
            (function (DrawingTools) {
                class AbstractDrawShape extends DrawingTools.AbstractProviderTool {
                    constructor(map, drawingTools, drawingToolsId, type, configs) {
                        super(map, drawingTools, drawingToolsId, type, configs);
                    }
                    _setOnChangeEvent(_shape) {
                        _shape.shapeEvents.addHandler(OSFramework.Maps.Helper.Constants.shapeChangedEvent, (mapId, shapeId, eventName, shapeCoordinates) => {
                            const dtparams = {
                                uniqueId: _shape.uniqueId,
                                isNewElement: false,
                                location: JSON.stringify(shapeCoordinates.location),
                                coordinates: JSON.stringify(shapeCoordinates.coordinates),
                            };
                            this.drawingTools.drawingToolsEvents.trigger(OSFramework.Maps.Event.DrawingTools.DrawingToolsEventType.ProviderEvent, this.completedToolEventName, dtparams);
                        });
                    }
                    createShapeElement(uniqueId, type, configs) {
                        const _shape = Leaflet.Shape.ShapeFactory.MakeShape(this.map, uniqueId, type, configs);
                        this._setOnChangeEvent(_shape);
                        this.map.addShape(_shape);
                        return _shape;
                    }
                    getCoordinates() {
                        const locations = JSON.parse(this.newElm.config.locations);
                        const locationsArray = [];
                        for (const coord of locations) {
                            locationsArray.push(coord.toString().split(','));
                        }
                        const finalLocations = locationsArray.map((coords) => {
                            return { Lat: coords[0], Lng: coords[1] };
                        });
                        return JSON.stringify(finalLocations);
                    }
                    getLocation() {
                        return this.newElm.config.locations;
                    }
                    build() {
                        super.build();
                        this.options = this.getProviderConfig();
                    }
                    changeProperty(propertyName, propertyValue) {
                        const propValue = OSFramework.Maps.Enum.OS_Config_Shape[propertyName];
                        super.changeProperty(propertyName, propertyValue);
                        if (this.drawingTools.isReady) {
                            switch (propValue) {
                                case OSFramework.Maps.Enum.OS_Config_Shape.strokeOpacity:
                                    this.options = {
                                        shapeOptions: { opacity: propertyValue },
                                    };
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Shape.strokeColor:
                                    this.options = {
                                        shapeOptions: { color: propertyValue },
                                    };
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Shape.strokeWeight:
                                    this.options = {
                                        shapeOptions: { weight: propertyValue },
                                    };
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Shape.fillOpacity:
                                    this.options = {
                                        shapeOptions: { fillOpacity: propertyValue },
                                    };
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Shape.fillColor:
                                    this.options = {
                                        shapeOptions: { fillColor: propertyValue },
                                    };
                                    return;
                            }
                        }
                    }
                }
                DrawingTools.AbstractDrawShape = AbstractDrawShape;
            })(DrawingTools = Leaflet.DrawingTools || (Leaflet.DrawingTools = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var DrawingTools;
            (function (DrawingTools) {
                class DrawCircle extends DrawingTools.AbstractDrawShape {
                    constructor(map, drawingTools, drawingToolsId, type, configs) {
                        super(map, drawingTools, drawingToolsId, type, new Leaflet.Configuration.DrawingTools.DrawFilledShapeConfig(configs));
                    }
                    _createConfigsElement(shape, configs) {
                        const providerCenter = shape.getLatLng();
                        const center = `${providerCenter.lat},${providerCenter.lng}`;
                        const radius = shape.getRadius();
                        const finalConfigs = Object.assign(Object.assign({}, configs), { center,
                            radius });
                        return finalConfigs;
                    }
                    get completedToolEventName() {
                        return OSFramework.Maps.Helper.Constants.drawingCircleCompleted;
                    }
                    get options() {
                        return this.internalOptions;
                    }
                    set options(options) {
                        var _a;
                        const allOptions = Object.assign(Object.assign({}, this.options), options);
                        const shapeOptions = Object.assign(Object.assign({}, (_a = this.options) === null || _a === void 0 ? void 0 : _a.shapeOptions), options.shapeOptions);
                        allOptions.shapeOptions = shapeOptions;
                        this.drawingTools.provider.setDrawingOptions({
                            circle: allOptions,
                        });
                        this.internalOptions = allOptions;
                    }
                    createElement(uniqueId, shape, configs) {
                        const finalConfigs = this._createConfigsElement(shape, configs);
                        return super.createShapeElement(uniqueId, OSFramework.Maps.Enum.ShapeType.Circle, finalConfigs);
                    }
                    getCoordinates() {
                        const locations = this.newElm.config.center;
                        let coordinatesArray = [];
                        coordinatesArray = locations.split(',');
                        const coordinates = {
                            Lat: coordinatesArray[0],
                            Lng: coordinatesArray[1],
                        };
                        return JSON.stringify(coordinates);
                    }
                    getLocation() {
                        const location = this.newElm.config.center;
                        const radius = this.newElm.config.radius;
                        const locationConfig = { location: location, radius: radius };
                        return JSON.stringify(locationConfig);
                    }
                }
                DrawingTools.DrawCircle = DrawCircle;
            })(DrawingTools = Leaflet.DrawingTools || (Leaflet.DrawingTools = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var DrawingTools;
            (function (DrawingTools) {
                class DrawMarker extends DrawingTools.AbstractProviderTool {
                    constructor(map, drawingTools, drawingToolsId, type, configs) {
                        super(map, drawingTools, drawingToolsId, type, new Leaflet.Configuration.DrawingTools.DrawMarkerConfig(configs));
                        this._defaultIcon = new L.DivIcon({
                            iconSize: Leaflet.Constants.Marker.defaultSize,
                            className: 'marker-leaflet-icon',
                            iconAnchor: Leaflet.Constants.Marker.defaultAnchor,
                        });
                    }
                    _createIcon(iconUrl) {
                        let icon = this._defaultIcon;
                        if (iconUrl !== '') {
                            let iconSize;
                            let iconAnchor;
                            icon = new L.Icon({
                                iconUrl,
                                iconSize,
                                iconAnchor,
                            });
                        }
                        return icon;
                    }
                    _setOnChangeEvent(_marker) {
                        const markerProvider = _marker.provider;
                        _marker.markerEvents.addHandler('dragend', () => {
                            this.triggerOnDrawingChangeEvent(_marker.uniqueId, false, JSON.stringify({
                                Lat: markerProvider.getLatLng().lat,
                                Lng: markerProvider.getLatLng().lng,
                            }), `${markerProvider.getLatLng().lat}, ${markerProvider.getLatLng().lng}`);
                        });
                    }
                    get completedToolEventName() {
                        return OSFramework.Maps.Helper.Constants.drawingMarkerCompleted;
                    }
                    get options() {
                        return this.internalOptions;
                    }
                    set options(options) {
                        const allOptions = Object.assign(Object.assign({}, this.options), options);
                        this.drawingTools.provider.setDrawingOptions({
                            marker: allOptions,
                        });
                        this.internalOptions = allOptions;
                    }
                    createElement(uniqueId, marker, configs) {
                        const location = `${marker.getLatLng().lat},${marker.getLatLng().lng}`;
                        const finalConfigs = Object.assign(Object.assign({}, configs), { location });
                        const _marker = Leaflet.Marker.MarkerFactory.MakeMarker(this.map, uniqueId, OSFramework.Maps.Enum.MarkerType.Marker, finalConfigs);
                        this._setOnChangeEvent(_marker);
                        this.map.addMarker(_marker);
                        return _marker;
                    }
                    getCoordinates() {
                        const locations = this.newElm.config.location;
                        let coordinatesArray = [];
                        coordinatesArray = locations.split(',');
                        const coordinates = {
                            Lat: coordinatesArray[0],
                            Lng: coordinatesArray[1],
                        };
                        return JSON.stringify(coordinates);
                    }
                    getLocation() {
                        return this.newElm.config.location;
                    }
                    build() {
                        super.build();
                        this.options = Object.assign(Object.assign({}, this.getProviderConfig()), { icon: this._createIcon(this.config.iconUrl) });
                    }
                    changeProperty(propertyName, propertyValue) {
                        const propValue = OSFramework.Maps.Enum.OS_Config_Marker[propertyName];
                        super.changeProperty(propertyName, propertyValue);
                        if (this.drawingTools.isReady) {
                            switch (propValue) {
                                case OSFramework.Maps.Enum.OS_Config_Marker.iconUrl:
                                    this.options = {
                                        icon: this._createIcon(propertyValue),
                                    };
                                    return;
                            }
                        }
                    }
                }
                DrawingTools.DrawMarker = DrawMarker;
            })(DrawingTools = Leaflet.DrawingTools || (Leaflet.DrawingTools = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var DrawingTools;
            (function (DrawingTools) {
                class DrawPolygon extends DrawingTools.AbstractDrawShape {
                    constructor(map, drawingTools, drawingToolsId, type, configs) {
                        super(map, drawingTools, drawingToolsId, type, new Leaflet.Configuration.DrawingTools.DrawFilledShapeConfig(configs));
                    }
                    get completedToolEventName() {
                        return OSFramework.Maps.Helper.Constants.drawingPolygonCompleted;
                    }
                    get options() {
                        return this.internalOptions;
                    }
                    set options(options) {
                        var _a;
                        const allOptions = Object.assign(Object.assign({}, this.options), options);
                        const shapeOptions = Object.assign(Object.assign({}, (_a = this.options) === null || _a === void 0 ? void 0 : _a.shapeOptions), options.shapeOptions);
                        allOptions.shapeOptions = shapeOptions;
                        this.drawingTools.provider.setDrawingOptions({
                            polygon: allOptions,
                        });
                        this.internalOptions = allOptions;
                    }
                    _createConfigsElement(shape, configs) {
                        const locations = shape.getLatLngs()[0].map((elm) => `${elm.lat},${elm.lng}`);
                        const finalConfigs = Object.assign(Object.assign({}, configs), { locations: JSON.stringify(locations) });
                        return finalConfigs;
                    }
                    createElement(uniqueId, shape, configs) {
                        const finalConfigs = this._createConfigsElement(shape, configs);
                        return super.createShapeElement(uniqueId, OSFramework.Maps.Enum.ShapeType.Polygon, finalConfigs);
                    }
                }
                DrawingTools.DrawPolygon = DrawPolygon;
            })(DrawingTools = Leaflet.DrawingTools || (Leaflet.DrawingTools = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var DrawingTools;
            (function (DrawingTools) {
                class DrawPolyline extends DrawingTools.AbstractDrawShape {
                    constructor(map, drawingTools, drawingToolsId, type, configs) {
                        super(map, drawingTools, drawingToolsId, type, new Leaflet.Configuration.DrawingTools.DrawBasicShapeConfig(configs));
                    }
                    get completedToolEventName() {
                        return OSFramework.Maps.Helper.Constants.drawingPolylineCompleted;
                    }
                    get options() {
                        return this.internalOptions;
                    }
                    set options(options) {
                        var _a;
                        const allOptions = Object.assign(Object.assign({}, this.options), options);
                        const shapeOptions = Object.assign(Object.assign({}, (_a = this.options) === null || _a === void 0 ? void 0 : _a.shapeOptions), options.shapeOptions);
                        allOptions.shapeOptions = shapeOptions;
                        this.drawingTools.provider.setDrawingOptions({
                            polyline: allOptions,
                        });
                        this.internalOptions = allOptions;
                    }
                    _createConfigsElement(shape, configs) {
                        const locations = shape.getLatLngs().map((elm) => `${elm.lat},${elm.lng}`);
                        const finalConfigs = Object.assign(Object.assign({}, configs), { locations: JSON.stringify(locations) });
                        return finalConfigs;
                    }
                    createElement(uniqueId, shape, configs) {
                        const finalConfigs = this._createConfigsElement(shape, configs);
                        return super.createShapeElement(uniqueId, OSFramework.Maps.Enum.ShapeType.Polyline, finalConfigs);
                    }
                }
                DrawingTools.DrawPolyline = DrawPolyline;
            })(DrawingTools = Leaflet.DrawingTools || (Leaflet.DrawingTools = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var DrawingTools;
            (function (DrawingTools) {
                class DrawRectangle extends DrawingTools.AbstractDrawShape {
                    constructor(map, drawingTools, drawingToolsId, type, configs) {
                        super(map, drawingTools, drawingToolsId, type, new Leaflet.Configuration.DrawingTools.DrawFilledShapeConfig(configs));
                    }
                    _createConfigsElement(shape, configs) {
                        const providerBounds = shape.getBounds();
                        const bounds = {
                            north: providerBounds.getNorthEast().lat.toString(),
                            south: providerBounds.getSouthWest().lat.toString(),
                            west: providerBounds.getSouthWest().lng.toString(),
                            east: providerBounds.getNorthEast().lng.toString(),
                        };
                        const finalConfigs = Object.assign(Object.assign({}, configs), { bounds: JSON.stringify(bounds) });
                        return finalConfigs;
                    }
                    get completedToolEventName() {
                        return OSFramework.Maps.Helper.Constants.drawingRectangleCompleted;
                    }
                    get options() {
                        return this.internalOptions;
                    }
                    set options(options) {
                        var _a;
                        const allOptions = Object.assign(Object.assign({}, this.options), options);
                        const shapeOptions = Object.assign(Object.assign({}, (_a = this.options) === null || _a === void 0 ? void 0 : _a.shapeOptions), options.shapeOptions);
                        allOptions.shapeOptions = shapeOptions;
                        this.drawingTools.provider.setDrawingOptions({
                            rectangle: allOptions,
                        });
                        this.internalOptions = allOptions;
                    }
                    createElement(uniqueId, shape, configs) {
                        const finalConfigs = this._createConfigsElement(shape, configs);
                        return super.createShapeElement(uniqueId, OSFramework.Maps.Enum.ShapeType.Rectangle, finalConfigs);
                    }
                    getCoordinates() {
                        const coordinates = JSON.parse(this.newElm.config.bounds);
                        return JSON.stringify(coordinates);
                    }
                    getLocation() {
                        return this.newElm.config.bounds;
                    }
                }
                DrawingTools.DrawRectangle = DrawRectangle;
            })(DrawingTools = Leaflet.DrawingTools || (Leaflet.DrawingTools = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var DrawingTools;
            (function (DrawingTools_2) {
                class ToolsList {
                    constructor() {
                        this.circlemarker = false;
                        this.circle = false;
                        this.marker = false;
                        this.polygon = false;
                        this.polyline = false;
                        this.rectangle = false;
                    }
                }
                class DrawingTools extends OSFramework.Maps.DrawingTools.AbstractDrawingTools {
                    constructor(map, drawingToolsId, configs) {
                        super(map, drawingToolsId, new Leaflet.Configuration.DrawingTools.DrawingToolsConfig(configs));
                        this._toolsGroup = new L.FeatureGroup();
                    }
                    _addCompletedEventHandler(event) {
                        const toolType = event.layerType;
                        this.tools
                            .filter((element) => element.type === toolType)
                            .forEach((element) => element.addCompletedEvent(event));
                    }
                    _getDrawingToolsPosition(position) {
                        if (Leaflet.Constants.DrawingTools.Positions[position] === undefined) {
                            OSFramework.Maps.Helper.ThrowError(this.map, OSFramework.Maps.Enum.ErrorCodes.CFG_InvalidDrawingToolsPosition, `${position}`);
                        }
                        return Leaflet.Constants.DrawingTools.Positions[position];
                    }
                    _getTools() {
                        const _tools = new ToolsList();
                        this.tools.forEach((tool) => {
                            switch (tool.type) {
                                case OSFramework.Maps.Enum.DrawingToolsTypes.Circle:
                                    _tools.circle = tool.options;
                                    break;
                                case OSFramework.Maps.Enum.DrawingToolsTypes.Marker:
                                    _tools.marker = tool.options;
                                    break;
                                case OSFramework.Maps.Enum.DrawingToolsTypes.Polygon:
                                    _tools.polygon = tool.options;
                                    break;
                                case OSFramework.Maps.Enum.DrawingToolsTypes.Polyline:
                                    _tools.polyline = tool.options;
                                    break;
                                case OSFramework.Maps.Enum.DrawingToolsTypes.Rectangle:
                                    _tools.rectangle = tool.options;
                                    break;
                                default:
                                    break;
                            }
                        });
                        return _tools;
                    }
                    _refreshDrawingModes() {
                        const drawingOptions = this.provider.options;
                        const finalDrawingOptions = Object.assign(Object.assign({}, drawingOptions), { draw: this._getTools() });
                        this._provider.setDrawingOptions(finalDrawingOptions.draw);
                    }
                    _refreshDrawingTools() {
                        this._setDrawingToolsEvents();
                        this._refreshDrawingModes();
                        this.map.provider.addControl(this._provider);
                    }
                    _setDrawingToolsEvents() {
                        this.map.provider.off(Leaflet.Constants.drawingLeafletCompleted);
                        this.map.provider.on(Leaflet.Constants.drawingLeafletCompleted, this._addCompletedEventHandler.bind(this));
                    }
                    get controlOptions() {
                        return this._provider.get('drawingControlOptions');
                    }
                    set controlOptions(options) {
                        const allOptions = Object.assign(Object.assign({}, this.controlOptions), options);
                        this._provider.setOptions({
                            drawingControlOptions: allOptions,
                        });
                    }
                    get providerEvents() {
                        return Leaflet.Constants.DrawingTools.Events;
                    }
                    addTool(tool) {
                        super.addTool(tool);
                        if (this.isReady) {
                            tool.build();
                            this._refreshDrawingTools();
                        }
                        return tool;
                    }
                    build() {
                        super.build();
                        const configs = this.getProviderConfig();
                        this.map.provider.addLayer(this._toolsGroup);
                        this._provider = new L.Control.Draw({
                            position: this._getDrawingToolsPosition(configs.position) || Leaflet.Constants.DrawingTools.Positions.TOP_LEFT,
                            edit: {
                                featureGroup: this._toolsGroup,
                                edit: false,
                                remove: false,
                            },
                            draw: this._getTools(),
                        });
                        this.tools.forEach((tool) => tool.build());
                        this._refreshDrawingTools();
                        this.finishBuild();
                    }
                    changeProperty(propertyName, propertyValue) {
                        const propValue = OSFramework.Maps.Enum.OS_Config_DrawingTools[propertyName];
                        super.changeProperty(propertyName, propertyValue);
                        if (this.isReady) {
                            if (propValue === OSFramework.Maps.Enum.OS_Config_DrawingTools.position) {
                                const positionValue = this._getDrawingToolsPosition(propertyValue);
                                positionValue && this.provider.setPosition(positionValue);
                            }
                        }
                    }
                    dispose() {
                        if (this.isReady) {
                            this.map.provider.removeControl(this._provider);
                        }
                        this._provider = undefined;
                        super.dispose();
                    }
                    refreshProviderEvents() {
                        if (this.isReady)
                            this._setDrawingToolsEvents();
                    }
                    removeTool(toolId) {
                        super.removeTool(toolId);
                        this._refreshDrawingTools();
                    }
                }
                DrawingTools_2.DrawingTools = DrawingTools;
            })(DrawingTools = Leaflet.DrawingTools || (Leaflet.DrawingTools = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var DrawingTools;
            (function (DrawingTools) {
                let DrawingToolsFactory;
                (function (DrawingToolsFactory) {
                    function MakeDrawingTools(map, drawingToolsId, configs) {
                        return new DrawingTools.DrawingTools(map, drawingToolsId, configs);
                    }
                    DrawingToolsFactory.MakeDrawingTools = MakeDrawingTools;
                    function MakeTool(map, drawingTools, toolId, type, configs) {
                        switch (type) {
                            case OSFramework.Maps.Enum.DrawingToolsTypes.Marker:
                                return new DrawingTools.DrawMarker(map, drawingTools, toolId, type, configs);
                            case OSFramework.Maps.Enum.DrawingToolsTypes.Polyline:
                                return new DrawingTools.DrawPolyline(map, drawingTools, toolId, type, configs);
                            case OSFramework.Maps.Enum.DrawingToolsTypes.Polygon:
                                return new DrawingTools.DrawPolygon(map, drawingTools, toolId, type, configs);
                            case OSFramework.Maps.Enum.DrawingToolsTypes.Circle:
                                return new DrawingTools.DrawCircle(map, drawingTools, toolId, type, configs);
                            case OSFramework.Maps.Enum.DrawingToolsTypes.Rectangle:
                                return new DrawingTools.DrawRectangle(map, drawingTools, toolId, type, configs);
                            default:
                                throw new Error(`There is no factory for this type of Tool (${type}) using the Leaflet provider`);
                        }
                    }
                    DrawingToolsFactory.MakeTool = MakeTool;
                })(DrawingToolsFactory = DrawingTools.DrawingToolsFactory || (DrawingTools.DrawingToolsFactory = {}));
            })(DrawingTools = Leaflet.DrawingTools || (Leaflet.DrawingTools = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Feature;
            (function (Feature) {
                class Center {
                    constructor(map, center) {
                        this._map = map;
                        this._initialCenter = center;
                    }
                    build() { }
                    getCenter() {
                        return this._initialCenter;
                    }
                    getCurrentCenter() {
                        return this._currentCenter;
                    }
                    getMapCenter() {
                        const responseObj = {
                            isSuccess: true,
                            message: OSFramework.Maps.Enum.Success.message,
                            code: OSFramework.Maps.Enum.Success.code,
                        };
                        try {
                            const messageInfo = {
                                message: OSFramework.Maps.Enum.Success.message,
                                lat: this._map.provider.getCenter().lat,
                                lng: this._map.provider.getCenter().lng,
                            };
                            responseObj.message = JSON.stringify(messageInfo);
                        }
                        catch (error) {
                            responseObj.isSuccess = false;
                            responseObj.message = error.message;
                            responseObj.code = OSFramework.Maps.Enum.ErrorCodes.API_FailedGettingCenterCoordinates;
                        }
                        return responseObj;
                    }
                    refreshCenter(value, allowRefreshZoom) {
                        let coordinates = new L.LatLng(value.lat, value.lng);
                        this._map.provider.setView(coordinates);
                        if (allowRefreshZoom) {
                            if (this._map.features.zoom.isAutofit) {
                                if (this._map.markers.length > 1 ||
                                    (this._map.shapes.length > 0 && this._map.config.autoZoomOnShapes === true)) {
                                    this._map.provider.setView(coordinates);
                                    this._map.features.zoom.refreshZoom();
                                    const tempCenter = this._map.features.center.getCurrentCenter();
                                    coordinates = new L.LatLng(tempCenter.lat, tempCenter.lng);
                                }
                                else {
                                    this._map.provider.setView(coordinates, OSFramework.Maps.Helper.Constants.zoomAutofit);
                                }
                            }
                            else {
                                this._map.provider.setView(coordinates, this._map.features.zoom.level);
                            }
                        }
                        else {
                            this._map.provider.setView(coordinates);
                        }
                        this._currentCenter = coordinates;
                    }
                    setCurrentCenter(value) {
                        this._currentCenter = value;
                    }
                    updateCenter(location) {
                        Leaflet.Helper.Conversions.ValidateCoordinates(location)
                            .then((response) => {
                            this._map.config.center = response;
                            this._initialCenter = response;
                            this._map.refresh(true);
                        })
                            .catch(() => {
                            this._map.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.OnError, this._map, OSFramework.Maps.Enum.ErrorCodes.LIB_FailedGeocodingLeafletMap);
                        });
                    }
                }
                Feature.Center = Center;
            })(Feature = Leaflet.Feature || (Leaflet.Feature = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Feature;
            (function (Feature) {
                class Directions {
                    constructor(map) {
                        this._map = map;
                        this._isEnabled = false;
                        this._currentDistance = NaN;
                        this._currentDuration = NaN;
                        this._bindSetRoute = this._routesFoundHandler.bind(this, undefined, 0);
                        this._bindDistance = undefined;
                        this._bindDuration = undefined;
                        this._defaultIcon = {
                            iconSize: [24, 40],
                            className: 'marker-leaflet-icon-wp',
                            iconAnchor: [12, 40],
                        };
                        this._defaultTooltip = {
                            permanent: true,
                            direction: 'top',
                            className: 'marker-leaflet-transparent-tooltip-wp',
                        };
                    }
                    get isEnabled() {
                        return this._isEnabled;
                    }
                    _buildCharFromNumber(n) {
                        let char = '';
                        if (n >= 0 && n < 26) {
                            char = String.fromCharCode(65 + n);
                        }
                        else if (n < 702) {
                            char = String.fromCharCode(65 + (n - 26) / 26) + String.fromCharCode(65 + ((n - 26) % 26));
                        }
                        return char;
                    }
                    _buildDirectionsRenderer(provider, apiKey) {
                        this._directionsRenderer = new L.Routing.Control({
                            router: new L.Routing[provider](apiKey, {}),
                            fitSelectedRoutes: true,
                            plan: L.Routing.plan([], {
                                createMarker: function (i, wp) {
                                    return L.marker(wp.latLng, {
                                        icon: new L.DivIcon(this._defaultIcon),
                                    }).bindTooltip(`${this._buildCharFromNumber(i)}`, this._defaultTooltip);
                                }.bind(this),
                                routeWhileDragging: false,
                                draggableWaypoints: false,
                                createGeocoderElement: undefined,
                            }),
                        });
                    }
                    _hasDirectionsRenderer() {
                        return this._directionsRenderer !== undefined;
                    }
                    _routesFoundHandler(resolve, resolveType, e) {
                        let bind;
                        this._currentDistance = e.routes[0].summary.totalDistance;
                        this._currentDuration = e.routes[0].summary.totalTime;
                        if (resolve !== undefined) {
                            if (resolveType === 2) {
                                resolve(this._currentDistance);
                                bind = this._bindDistance;
                            }
                            else if (resolveType === 1) {
                                resolve(this._currentDuration);
                                bind = this._bindDuration;
                            }
                        }
                        else {
                            if (resolveType === 0) {
                                bind = this._bindSetRoute;
                            }
                        }
                        this._directionsRenderer.off(Leaflet.Constants.Directions.Events.routesfound, bind);
                    }
                    _setExcludes(dirExclude) {
                        if (this._hasDirectionsRenderer() === false)
                            return false;
                        const exclude = [];
                        dirExclude.avoidTolls && exclude.push('toll');
                        dirExclude.avoidHighways && exclude.push('motorway');
                        dirExclude.avoidFerries && exclude.push('ferry');
                        this._directionsRenderer.getRouter().options.exclude = exclude;
                        return true;
                    }
                    _setTravelMode(travelMode) {
                        var _a;
                        if (this._hasDirectionsRenderer() === false ||
                            ((_a = Leaflet.Constants.Directions[this._providerName]) === null || _a === void 0 ? void 0 : _a.TravelModes[travelMode]) === undefined) {
                            return false;
                        }
                        this._directionsRenderer.getRouter().options.profile =
                            Leaflet.Constants.Directions[this._providerName].TravelModes[travelMode];
                        return true;
                    }
                    _validateCoordinates(waypoints) {
                        const wayptsFinal = [];
                        return new Promise((resolve, reject) => {
                            waypoints.forEach((wpt) => Leaflet.Helper.Conversions.ValidateCoordinates(wpt)
                                .then((response) => {
                                wayptsFinal.push(new L.LatLng(response.lat, response.lng));
                                if (waypoints.length === wayptsFinal.length) {
                                    resolve(wayptsFinal);
                                }
                            })
                                .catch(() => {
                                reject({
                                    code: OSFramework.Maps.Enum.ErrorCodes.LIB_FailedSetDirections,
                                    message: `One or more set of coordinates is not valid`,
                                });
                            }));
                        });
                    }
                    build() {
                        this.setState(this._isEnabled);
                    }
                    dispose() {
                        this.setState(false);
                        this._directionsRenderer = undefined;
                    }
                    getLegsFromDirection() {
                        throw new Error('Method not implemented.');
                    }
                    getTotalDistanceFromDirection() {
                        if (this._hasDirectionsRenderer() === false) {
                            OSFramework.Maps.Helper.ThrowError(this._map, OSFramework.Maps.Enum.ErrorCodes.API_FailedNoPluginDirections);
                            return new Promise((resolve) => resolve(0));
                        }
                        return new Promise((resolve) => {
                            if (isNaN(this._currentDistance)) {
                                this._bindDistance = this._routesFoundHandler.bind(this, resolve, 2);
                                this._directionsRenderer.on(Leaflet.Constants.Directions.Events.routesfound, this._bindDistance);
                            }
                            else {
                                resolve(this._currentDistance);
                            }
                        });
                    }
                    getTotalDurationFromDirection() {
                        if (this._hasDirectionsRenderer() === false) {
                            OSFramework.Maps.Helper.ThrowError(this._map, OSFramework.Maps.Enum.ErrorCodes.API_FailedNoPluginDirections);
                            return new Promise((resolve) => resolve(0));
                        }
                        return new Promise((resolve) => {
                            if (isNaN(this._currentDuration)) {
                                this._bindDuration = this._routesFoundHandler.bind(this, resolve, 1);
                                this._directionsRenderer.on(Leaflet.Constants.Directions.Events.routesfound, this._bindDuration);
                            }
                            else {
                                resolve(this._currentDuration);
                            }
                        });
                    }
                    removeRoute() {
                        this.setState(false);
                        const returningMessage = new OSFramework.Maps.OSStructures.ReturnMessage();
                        if (this._hasDirectionsRenderer() === false) {
                            returningMessage.isSuccess = true;
                        }
                        else {
                            returningMessage.code = OSFramework.Maps.Enum.ErrorCodes.API_FailedRemoveDirections;
                        }
                        return returningMessage;
                    }
                    setPlugin(provider, apiKey) {
                        this._directionsRenderer && this.dispose();
                        this._buildDirectionsRenderer(Leaflet.Constants.Directions.Provider[provider] || provider, apiKey);
                        this._providerName = provider;
                        const returningMessage = new OSFramework.Maps.OSStructures.ReturnMessage();
                        if (this._hasDirectionsRenderer()) {
                            returningMessage.isSuccess = true;
                        }
                        else {
                            returningMessage.code = OSFramework.Maps.Enum.ErrorCodes.API_FailedLoadingPlugin;
                        }
                        return returningMessage;
                    }
                    setRoute(directionOptions) {
                        let returningMessage = new OSFramework.Maps.OSStructures.ReturnMessage();
                        this._currentDistance = NaN;
                        this._currentDuration = NaN;
                        if (this._hasDirectionsRenderer() === false) {
                            returningMessage.code = OSFramework.Maps.Enum.ErrorCodes.API_FailedNoPluginDirections;
                            return new Promise((resolve) => resolve(returningMessage));
                        }
                        if (this._setTravelMode(directionOptions.travelMode) === false) {
                            returningMessage.code = OSFramework.Maps.Enum.ErrorCodes.CFG_InvalidTravelMode;
                            return new Promise((resolve) => resolve(returningMessage));
                        }
                        this._setExcludes(directionOptions.exclude);
                        this._directionsRenderer.on(Leaflet.Constants.Directions.Events.routesfound, this._bindSetRoute);
                        this._directionsRenderer.route({});
                        const waypts = [
                            directionOptions.originRoute,
                            ...directionOptions.waypoints,
                            directionOptions.destinationRoute,
                        ];
                        return this._validateCoordinates(waypts)
                            .then((response) => {
                            this.setState(true);
                            this._directionsRenderer.setWaypoints(response);
                            this._directionsRenderer.getContainer().remove();
                            returningMessage.isSuccess = true;
                            return returningMessage;
                        })
                            .catch((error) => {
                            returningMessage = {
                                code: error.code,
                                message: error.message,
                            };
                            return returningMessage;
                        });
                    }
                    setState(value) {
                        if (value === true) {
                            this._directionsRenderer && this._directionsRenderer.addTo(this._map.provider);
                        }
                        else {
                            this._directionsRenderer &&
                                this._map.provider.removeControl(this._directionsRenderer);
                        }
                        this._isEnabled = value;
                    }
                }
                Feature.Directions = Directions;
            })(Feature = Leaflet.Feature || (Leaflet.Feature = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Feature;
            (function (Feature) {
                class AbstractFactoryBuilder {
                    constructor(map) {
                        this._map = map;
                        this._featureList = [];
                        this._features = new OSFramework.Maps.Feature.ExposedFeatures();
                    }
                    _instanceOfIDisposable(object) {
                        return 'dispose' in object;
                    }
                    _makeItem(c, ...args) {
                        const o = new c(this._map, ...args);
                        this._featureList.push(o);
                        return o;
                    }
                    get features() {
                        return this._features;
                    }
                    build() {
                        this._featureList.forEach((p) => p.build());
                    }
                    dispose() {
                        this._featureList.forEach((p) => {
                            this._instanceOfIDisposable(p) && p.dispose();
                            p = undefined;
                        });
                    }
                }
                Feature.AbstractFactoryBuilder = AbstractFactoryBuilder;
                class FeatureBuilder extends AbstractFactoryBuilder {
                    _makeCenter(center) {
                        this._features.center = this._makeItem(Feature.Center, center);
                        return this;
                    }
                    _makeDirections() {
                        this._features.directions = this._makeItem(Feature.Directions);
                        return this;
                    }
                    _makeInfoWindow() {
                        this._features.infoWindow = this._makeItem(Feature.InfoWindow);
                        return this;
                    }
                    _makeOffset(offset) {
                        this._features.offset = this._makeItem(Feature.Offset, offset);
                        return this;
                    }
                    _makeShape() {
                        this._features.shape = this._makeItem(Feature.Shape);
                        return this;
                    }
                    _makeZoom(level) {
                        this._features.zoom = this._makeItem(Feature.Zoom, level);
                        return this;
                    }
                    build() {
                        const config = this._map.config;
                        this._makeShape();
                        this._makeZoom(config.zoom)
                            ._makeCenter(config.center)
                            ._makeDirections()
                            ._makeOffset(config.offset)
                            ._makeInfoWindow();
                        super.build();
                    }
                }
                Feature.FeatureBuilder = FeatureBuilder;
            })(Feature = Leaflet.Feature || (Leaflet.Feature = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Feature;
            (function (Feature) {
                class InfoWindow {
                    _getOptions(marker) {
                        const offsetHeight = marker.config.iconHeight > 0 ? marker.config.iconHeight : marker.provider.getElement().offsetHeight;
                        const options = {
                            offset: [0, -offsetHeight],
                        };
                        return options;
                    }
                    build() {
                        this._infoWindow = new L.Popup();
                        this._popupIsOpened = false;
                    }
                    closePopup(marker) {
                        if (this._popupIsOpened) {
                            marker.provider.closePopup();
                            marker.provider.unbindPopup();
                            this._popupIsOpened = false;
                        }
                    }
                    openPopup(marker) {
                        if (this._popupIsOpened === true) {
                            this.closePopup(marker);
                        }
                        marker.provider.bindPopup(this._infoWindow.getContent(), this._getOptions(marker)).openPopup();
                        this._popupIsOpened = true;
                    }
                    setPopupContent(content, marker) {
                        this._infoWindow.setContent(content);
                        this._infoWindow.update();
                        marker.provider.setPopupContent(this._infoWindow.getContent());
                    }
                }
                Feature.InfoWindow = InfoWindow;
            })(Feature = Leaflet.Feature || (Leaflet.Feature = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Feature;
            (function (Feature) {
                class Offset {
                    constructor(map, offset) {
                        this._map = map;
                        this._offset = offset || { offsetX: 0, offsetY: 0 };
                    }
                    get getOffset() {
                        return this._offset;
                    }
                    build() { }
                    setOffset(value) {
                        this._offset = {
                            offsetX: value.offsetX || 0,
                            offsetY: value.offsetY || 0,
                        };
                        const point = this._map.provider.latLngToLayerPoint(this._map.features.center.getCurrentCenter());
                        const newPoint = new L.Point(point.x + this._offset.offsetX, point.y + this._offset.offsetY);
                        const latLng = this._map.provider.layerPointToLatLng(newPoint);
                        this._map.provider.setView(latLng);
                    }
                }
                Feature.Offset = Offset;
            })(Feature = Leaflet.Feature || (Leaflet.Feature = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Feature;
            (function (Feature) {
                class Shape {
                    _checkCircleContainsMarker() {
                        const circleCenter = this._shape.provider.getLatLng();
                        const circleRadius = this._shape.provider.getRadius();
                        this._markerCoordinates = new L.LatLng(this._markerCoordinates.lat, this._markerCoordinates.lng);
                        const distanceBetweenPoints = this._map.provider.distance(this._markerCoordinates, circleCenter);
                        this._isInsideShape = distanceBetweenPoints < circleRadius;
                        this._updateReturnMessage();
                    }
                    _checkContainsMarker() {
                        let xi;
                        let yi;
                        let xj;
                        let yj;
                        let intersect;
                        let previousPolyPoint = this._polyPoints.length - 1;
                        for (const { index } of this._polyPoints.map((value, index) => ({
                            value,
                            index,
                        }))) {
                            if (previousPolyPoint > this._polyPoints.length - 1) {
                                previousPolyPoint = index - 1;
                            }
                            xi = this._polyPoints[index].lat;
                            yi = this._polyPoints[index].lng;
                            xj = this._polyPoints[previousPolyPoint].lat;
                            yj = this._polyPoints[previousPolyPoint].lng;
                            intersect =
                                yi > this._markerCoordinates.lng !== yj > this._markerCoordinates.lng &&
                                    this._markerCoordinates.lat < ((xj - xi) * (this._markerCoordinates.lng - yi)) / (yj - yi) + xi;
                            if (intersect) {
                                this._isInsideShape = !this._isInsideShape;
                            }
                            previousPolyPoint = ++previousPolyPoint;
                        }
                        this._updateReturnMessage();
                    }
                    _updateReturnMessage() {
                        this._returnObjSuccess = true;
                        this._returnObjCode = OSFramework.Maps.Enum.Success.code;
                        this._returnObjMessage = this._isInsideShape.toString();
                    }
                    build() {
                    }
                    containsLocation(mapId, shapeId, pointCoordinates, coordinatesList) {
                        this._map = OutSystems.Maps.MapAPI.MapManager.GetMapById(mapId);
                        this._returnObjSuccess = false;
                        this._returnObjCode = OSFramework.Maps.Enum.ErrorCodes.CFG_InvalidMapId;
                        if (this._map) {
                            this._isInsideShape = false;
                            this._markerCoordinates = JSON.parse(pointCoordinates.toLocaleLowerCase());
                            if (shapeId) {
                                this._shape = OutSystems.Maps.MapAPI.ShapeManager.GetShapeById(shapeId);
                                switch (this._shape.type) {
                                    case OSFramework.Maps.Enum.ShapeType.Polyline:
                                        this._returnObjCode = OSFramework.Maps.Enum.Unsupported.code;
                                        this._returnObjMessage = OSFramework.Maps.Enum.Unsupported.message;
                                        break;
                                    case OSFramework.Maps.Enum.ShapeType.Circle: {
                                        this._checkCircleContainsMarker();
                                        break;
                                    }
                                    default: {
                                        this._polyPoints = this._shape.provider.getLatLngs()[0];
                                        this._checkContainsMarker();
                                    }
                                }
                            }
                            else {
                                const shapeCoordinatesList = JSON.parse(coordinatesList);
                                this._polyPoints = [];
                                if (shapeCoordinatesList.length >= 3) {
                                    shapeCoordinatesList.forEach((item) => {
                                        this._polyPoints.push(L.latLng(item.Lat, item.Lng));
                                    });
                                    this._checkContainsMarker();
                                }
                            }
                        }
                        return {
                            isSuccess: this._returnObjSuccess,
                            code: this._returnObjCode,
                            message: this._returnObjMessage,
                        };
                    }
                }
                Feature.Shape = Shape;
            })(Feature = Leaflet.Feature || (Leaflet.Feature = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Feature;
            (function (Feature) {
                class Zoom {
                    constructor(map, level) {
                        this._map = map;
                        this._level = level;
                    }
                    _setAutofit(value) {
                        this._autofitEnabled = value;
                    }
                    _setBounds(useShapes) {
                        let bounds;
                        this._map.markers.forEach(function (marker) {
                            if (marker.provider === undefined)
                                return;
                            const loc = marker.provider.getLatLng();
                            bounds = bounds ? bounds.extend(loc) : new L.LatLngBounds(loc, loc);
                        });
                        if (useShapes) {
                            this._map.shapes.forEach(function (shape) {
                                if (shape.provider === undefined)
                                    return;
                                const loc = shape.providerBounds;
                                bounds = bounds ? bounds.extend(loc) : loc;
                            });
                        }
                        this._map.provider.fitBounds(bounds);
                        this._map.provider.panInsideBounds(bounds);
                        this._map.features.center.setCurrentCenter(bounds.getCenter());
                    }
                    build() {
                        this._setAutofit(this._level === OSFramework.Maps.Enum.OSMap.Zoom.Auto);
                    }
                    get isAutofit() {
                        return this._autofitEnabled;
                    }
                    get level() {
                        return this._level;
                    }
                    refreshZoom() {
                        if (this._map.features.zoom.isAutofit) {
                            if (this._map.markers.length > 1 ||
                                (this._map.shapes.length > 0 && this._map.config.autoZoomOnShapes === true)) {
                                this._setBounds(this._map.config.autoZoomOnShapes);
                            }
                            else {
                                this._map.provider.setView(this._map.features.center.getCurrentCenter(), OSFramework.Maps.Helper.Constants.zoomAutofit);
                            }
                        }
                        else {
                            this._map.provider.setZoom(this._map.features.zoom.level);
                        }
                    }
                    setLevel(value) {
                        this._level = value;
                        this._setAutofit(value === OSFramework.Maps.Enum.OSMap.Zoom.Auto);
                        this._map.refresh();
                    }
                }
                Feature.Zoom = Zoom;
            })(Feature = Leaflet.Feature || (Leaflet.Feature = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Helper;
            (function (Helper) {
                var Conversions;
                (function (Conversions) {
                    function ValidateCoordinates(location) {
                        return new Promise((resolve, reject) => {
                            if (location === undefined || location.trim().length === 0) {
                                console.warn('Invalid location. Using the default location -> { lat: 42.3517926, lng: -71.0467845 }');
                                resolve(OSFramework.Maps.Helper.Constants.defaultMapCenter);
                            }
                            const regexValidator = /^-{0,1}\d*\.{0,1}\d*,( )?-{0,1}\d*\.{0,1}\d*$/;
                            if (regexValidator.test(location)) {
                                const coordinates = new OSFramework.Maps.OSStructures.OSMap.Coordinates();
                                if (location.indexOf(',') > -1) {
                                    coordinates.lat = parseFloat(location.split(',')[0].replace(' ', ''));
                                    coordinates.lng = parseFloat(location.split(',')[1].replace(' ', ''));
                                    resolve(coordinates);
                                }
                                else {
                                    reject();
                                }
                            }
                            else {
                                reject();
                            }
                        });
                    }
                    Conversions.ValidateCoordinates = ValidateCoordinates;
                })(Conversions = Helper.Conversions || (Helper.Conversions = {}));
            })(Helper = Leaflet.Helper || (Leaflet.Helper = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Marker;
            (function (Marker) {
                let MarkerFactory;
                (function (MarkerFactory) {
                    function MakeMarker(map, markerId, type, configs) {
                        switch (type) {
                            case OSFramework.Maps.Enum.MarkerType.Marker:
                                return new Marker.Marker(map, markerId, type, configs);
                            case OSFramework.Maps.Enum.MarkerType.MarkerPopup:
                                return new Marker.MarkerPopup(map, markerId, type, configs);
                            default:
                                throw new Error(`There is no factory for this type of Marker (${type})`);
                        }
                    }
                    MarkerFactory.MakeMarker = MakeMarker;
                })(MarkerFactory = Marker.MarkerFactory || (Marker.MarkerFactory = {}));
            })(Marker = Leaflet.Marker || (Leaflet.Marker = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Marker;
            (function (Marker_2) {
                class Marker extends OSFramework.Maps.Marker.AbstractMarker {
                    constructor(map, markerId, type, configs) {
                        super(map, markerId, type, new Leaflet.Configuration.Marker.LeafletMarkerConfig(configs));
                        this._defaultIcon = new L.DivIcon({
                            iconSize: Leaflet.Constants.Marker.defaultSize,
                            className: 'marker-leaflet-icon',
                            iconAnchor: Leaflet.Constants.Marker.defaultAnchor,
                        });
                        this._defaultTooltip = {
                            permanent: true,
                            direction: 'top',
                            className: 'marker-leaflet-transparent-tooltip',
                        };
                        this._addedEvents = [];
                    }
                    async _getMeta(url) {
                        return new Promise((resolve, reject) => {
                            const img = new Image();
                            img.onload = () => resolve({
                                width: img.width,
                                height: img.height,
                            });
                            img.onerror = (error) => reject(error);
                            img.src = url;
                        });
                    }
                    async _setIcon(iconUrl) {
                        let icon;
                        if (iconUrl === '') {
                            icon = this._defaultIcon;
                        }
                        else {
                            let iconSize;
                            let iconAnchor;
                            if (this.config.iconWidth > 0 && this.config.iconHeight > 0) {
                                iconSize = [this.config.iconWidth, this.config.iconHeight];
                                iconAnchor = [this.config.iconWidth / 2, this.config.iconHeight];
                            }
                            else {
                                try {
                                    const { width, height } = await this._getMeta(iconUrl);
                                    this.config.iconWidth = width;
                                    this.config.iconHeight = height;
                                    iconSize = [this.config.iconWidth, this.config.iconHeight];
                                    iconAnchor = [this.config.iconWidth / 2, this.config.iconHeight];
                                }
                                catch (e) {
                                    console.error(e);
                                }
                            }
                            icon = new L.Icon({
                                iconUrl,
                                iconSize,
                                iconAnchor,
                            });
                        }
                        this.provider.setIcon(icon);
                    }
                    _setIconSize() {
                        this._setIcon(this.config.iconUrl);
                    }
                    _setLabelContent(content) {
                        if (content === '') {
                            this.provider.unbindTooltip();
                            return;
                        }
                        const tooltip = this.provider.getTooltip();
                        if (tooltip) {
                            this.provider.setTooltipContent(content);
                        }
                        else {
                            this.provider.bindTooltip(content, this._defaultTooltip);
                        }
                    }
                    _buildMarkerLocation() {
                        let markerLocation;
                        if (typeof this.config.location === 'undefined') {
                            this.map.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.OnError, this.map, OSFramework.Maps.Enum.ErrorCodes.LIB_FailedGeocodingLeafletMarker, `Location of the Marker can't be empty.`);
                            return;
                        }
                        else {
                            return new Promise((resolve, reject) => {
                                Leaflet.Helper.Conversions.ValidateCoordinates(this.config.location)
                                    .then((response) => {
                                    markerLocation = new L.LatLng(response.lat, response.lng);
                                    resolve(markerLocation);
                                })
                                    .catch((e) => reject(e));
                            });
                        }
                    }
                    _setMarkerEvents() {
                        this._addedEvents.forEach((eventListener, index) => {
                            this.provider.removeEventListener(eventListener);
                            this._addedEvents.splice(index, 1);
                        });
                        if (this.markerEvents.hasHandlers(OSFramework.Maps.Event.Marker.MarkerEventType.OnClick)) {
                            this._addedEvents.push('click');
                            this._provider.addEventListener('click', (e) => {
                                const coordinates = new OSFramework.Maps.OSStructures.OSMap.OSCoordinates(e.latlng.lat, e.latlng.lng);
                                this.markerEvents.trigger(OSFramework.Maps.Event.Marker.MarkerEventType.OnClick, OSFramework.Maps.Event.Marker.MarkerEventType.OnClick, JSON.stringify(coordinates));
                            });
                        }
                        this.markerEvents.handlers.forEach((handler, eventName) => {
                            if (handler instanceof OSFramework.Maps.Event.Marker.MarkerProviderEvent) {
                                this._addedEvents.push(eventName);
                                this._provider.addEventListener(Leaflet.Constants.Marker.ProviderEventNames[eventName], (e) => {
                                    this.markerEvents.trigger(OSFramework.Maps.Event.Marker.MarkerEventType.ProviderEvent, eventName, e !== undefined && e.target.getLatLng !== undefined
                                        ? JSON.stringify({
                                            Lat: e.target.getLatLng().lat,
                                            Lng: e.target.getLatLng().lng,
                                        })
                                        : undefined);
                                });
                            }
                        });
                    }
                    get hasEvents() {
                        return this.markerEvents !== undefined;
                    }
                    get markerTag() {
                        return OSFramework.Maps.Helper.Constants.markerTag;
                    }
                    build() {
                        super.build();
                        const markerLocation = this._buildMarkerLocation();
                        const provider_configs = this.getProviderConfig();
                        if (markerLocation !== undefined) {
                            this.map.cancelScheduledResfresh();
                            markerLocation
                                .then((location) => {
                                if (this._destroyed)
                                    return;
                                this._provider = L.marker(location, provider_configs);
                                this._setIcon(this.config.iconUrl);
                                this._setLabelContent(this.config.label);
                                this._provider.addTo(this.map.provider);
                                this._setMarkerEvents();
                                this.finishBuild();
                                this.map.scheduleRefresh();
                            })
                                .catch(() => {
                                this.map.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.OnError, this.map, OSFramework.Maps.Enum.ErrorCodes.LIB_FailedGeocodingLeafletMarker);
                            });
                        }
                    }
                    changeProperty(propertyName, propertyValue) {
                        const property = OSFramework.Maps.Enum.OS_Config_Marker[propertyName];
                        super.changeProperty(propertyName, propertyValue);
                        if (this.isReady) {
                            switch (property) {
                                case OSFramework.Maps.Enum.OS_Config_Marker.location:
                                    Leaflet.Helper.Conversions.ValidateCoordinates(propertyValue)
                                        .then((response) => {
                                        this._provider.setLatLng({
                                            lat: response.lat,
                                            lng: response.lng,
                                        });
                                        this.map.refresh();
                                    })
                                        .catch(() => {
                                        this.map.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.OnError, this.map, OSFramework.Maps.Enum.ErrorCodes.LIB_FailedGeocodingLeafletMarker);
                                    });
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Marker.allowDrag:
                                    propertyValue ? this._provider.dragging.enable() : this._provider.dragging.disable();
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Marker.iconHeight:
                                    this._setIconSize();
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Marker.iconUrl:
                                    this._setIcon(propertyValue);
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Marker.iconWidth:
                                    this._setIconSize();
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Marker.label:
                                    this._setLabelContent(propertyValue);
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Marker.title:
                                    this._provider.getElement().title = propertyValue;
                                    return;
                            }
                        }
                    }
                    dispose() {
                        if (this.isReady) {
                            this.map.provider.removeLayer(this.provider);
                        }
                        this._provider = undefined;
                        super.dispose();
                    }
                    refreshProviderEvents() {
                        if (this.isReady)
                            this._setMarkerEvents();
                    }
                    validateProviderEvent(eventName) {
                        return Leaflet.Constants.Marker.ProviderEventNames[eventName] !== undefined;
                    }
                }
                Marker_2.Marker = Marker;
            })(Marker = Leaflet.Marker || (Leaflet.Marker = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Marker;
            (function (Marker) {
                class MarkerPopup extends Marker.Marker {
                    _setMarkerEvents() {
                        super._setMarkerEvents();
                        this._provider.addEventListener('click', () => {
                            this.openPopup();
                        });
                    }
                    get hasPopup() {
                        return true;
                    }
                    get markerTag() {
                        return OSFramework.Maps.Helper.Constants.markerPopupTag;
                    }
                    closePopup() {
                        this.map.features.infoWindow.closePopup(this);
                    }
                    openPopup() {
                        this.refreshPopupContent();
                        this.map.features.infoWindow.openPopup(this);
                    }
                    refreshPopupContent() {
                        this._contentString = OSFramework.Maps.Helper.GetElementByUniqueId(this.uniqueId).querySelector(OSFramework.Maps.Helper.Constants.markerPopup).innerHTML;
                        this.map.features.infoWindow.setPopupContent(this._contentString, this);
                    }
                }
                Marker.MarkerPopup = MarkerPopup;
            })(Marker = Leaflet.Marker || (Leaflet.Marker = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var OSMap;
            (function (OSMap) {
                let MapFactory;
                (function (MapFactory) {
                    function MakeMap(type, mapdId, configs) {
                        switch (type) {
                            case OSFramework.Maps.Enum.MapType.Map:
                                return new OSMap.Map(mapdId, configs);
                            case OSFramework.Maps.Enum.MapType.StaticMap:
                            default:
                                throw new Error(`There is no factory for this type of Map (${type})`);
                        }
                    }
                    MapFactory.MakeMap = MakeMap;
                })(MapFactory = OSMap.MapFactory || (OSMap.MapFactory = {}));
            })(OSMap = Leaflet.OSMap || (Leaflet.OSMap = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var OSMap;
            (function (OSMap) {
                class Map extends OSFramework.Maps.OSMap.AbstractMap {
                    constructor(mapId, configs) {
                        super(mapId, OSFramework.Maps.Enum.ProviderType.Leaflet, new Leaflet.Configuration.OSMap.LeafletMapConfig(configs), OSFramework.Maps.Enum.MapType.Map);
                        this._addedEvents = [];
                        this._openStreetMapLayer = new L.TileLayer(Leaflet.Constants.openStreetMapTileLayer.url, {
                            attribution: Leaflet.Constants.openStreetMapTileLayer.attribution,
                        });
                    }
                    _addMapZoomHandler() {
                        this._provider.on(Leaflet.Constants.OSMap.ProviderEventNames.zoom_end, this._mapZoomChangeCallback);
                    }
                    _buildDrawingTools() {
                        this.drawingTools && this.drawingTools.build();
                    }
                    _buildMarkers() {
                        this.markers.forEach((marker) => marker.build());
                    }
                    _buildShapes() {
                        this.shapes.forEach((shape) => shape.build());
                    }
                    _getProviderConfig() {
                        this.config.center = OSFramework.Maps.Helper.Constants.defaultMapCenter;
                        return this.config.getProviderConfig();
                    }
                    _removeMapZoomHandler() {
                        this._provider.off(Leaflet.Constants.OSMap.ProviderEventNames.zoom_end, this._mapZoomChangeCallback);
                    }
                    _setMapEvents() {
                        this.mapEvents.handlers.forEach((handler, eventName) => {
                            if (handler instanceof OSFramework.Maps.Event.OSMap.MapProviderEvent) {
                                this._addedEvents.push(eventName);
                                this._provider.addEventListener(Leaflet.Constants.OSMap.ProviderEventNames[eventName], (e) => {
                                    this.mapEvents.trigger(OSFramework.Maps.Event.OSMap.MapEventType.ProviderEvent, this, eventName, e && e.latlng !== undefined
                                        ? JSON.stringify({
                                            Lat: e.latlng.lat,
                                            Lng: e.latlng.lng,
                                        })
                                        : undefined);
                                });
                            }
                        });
                    }
                    get addedEvents() {
                        return this._addedEvents;
                    }
                    get mapTag() {
                        return OSFramework.Maps.Helper.Constants.mapTag;
                    }
                    addDrawingTools(drawingTools) {
                        super.addDrawingTools(drawingTools);
                        if (this.isReady) {
                            drawingTools.build();
                        }
                        return drawingTools;
                    }
                    addFileLayer(fileLayer) {
                        super.addFileLayer(fileLayer);
                        if (this.isReady) {
                            fileLayer.build();
                        }
                        return fileLayer;
                    }
                    addHeatmapLayer(fileLayer) {
                        super.addHeatmapLayer(fileLayer);
                        if (this.isReady) {
                            fileLayer.build();
                        }
                        return fileLayer;
                    }
                    addMarker(marker) {
                        super.addMarker(marker);
                        if (this.isReady) {
                            marker.build();
                        }
                        return marker;
                    }
                    addShape(shape) {
                        super.addShape(shape);
                        if (this.isReady) {
                            shape.build();
                        }
                        return shape;
                    }
                    build() {
                        super.build();
                        const currentCenter = this.config.center;
                        this._provider = new L.Map(OSFramework.Maps.Helper.GetElementByUniqueId(this.uniqueId).querySelector(OSFramework.Maps.Helper.Constants.runtimeMapUniqueIdCss), Object.assign(Object.assign({}, this._getProviderConfig()), { layers: [this._openStreetMapLayer] }));
                        this.buildFeatures();
                        this._buildMarkers();
                        this._buildShapes();
                        this._buildDrawingTools();
                        this.finishBuild();
                        this.features.center.updateCenter(currentCenter);
                        this._setMapEvents();
                        this._addMapZoomHandler();
                    }
                    buildFeatures() {
                        this._fBuilder = new Leaflet.Feature.FeatureBuilder(this);
                        this._features = this._fBuilder.features;
                        this._fBuilder.build();
                    }
                    changeDrawingToolsProperty(drawingToolsId, propertyName, propertyValue) {
                        const drawingTools = this.drawingTools;
                        if (drawingTools === undefined || drawingTools.uniqueId !== drawingToolsId) {
                            console.error(`changeDrawingToolsProperty - drawingToold id:${drawingToolsId} not found.`);
                        }
                        else {
                            drawingTools.changeProperty(propertyName, propertyValue);
                        }
                    }
                    changeFileLayerProperty(fileLayerId, propertyName, propertyValue) {
                        const fileLayer = this.getFileLayer(fileLayerId);
                        if (!fileLayer) {
                            console.error(`changeFileLayerProperty - fileLayer id:${fileLayerId} not found.`);
                        }
                        else {
                            fileLayer.changeProperty(propertyName, propertyValue);
                        }
                    }
                    changeHeatmapLayerProperty(heatmapLayerId, propertyName, propertyValue) {
                        const heatmapLayer = this.getHeatmapLayer(heatmapLayerId);
                        if (!heatmapLayer) {
                            console.error(`changeHeatmapLayerProperty - heatmapLayer id:${heatmapLayerId} not found.`);
                        }
                        else {
                            heatmapLayer.changeProperty(propertyName, propertyValue);
                        }
                    }
                    changeMarkerProperty(markerId, propertyName, propertyValue) {
                        const marker = this.getMarker(markerId);
                        if (!marker) {
                            console.error(`changeMarkerProperty - marker id:${markerId} not found.`);
                        }
                        else {
                            marker.changeProperty(propertyName, propertyValue);
                        }
                    }
                    changeProperty(propertyName, propertyValue) {
                        const propValue = OSFramework.Maps.Enum.OS_Config_Map[propertyName];
                        super.changeProperty(propertyName, propertyValue);
                        if (this.isReady) {
                            switch (propValue) {
                                case OSFramework.Maps.Enum.OS_Config_Map.center:
                                    return this.features.center.updateCenter(propertyValue);
                                case OSFramework.Maps.Enum.OS_Config_Map.offset:
                                    return this.features.offset.setOffset(JSON.parse(propertyValue));
                                case OSFramework.Maps.Enum.OS_Config_Map.zoom:
                                    return this.features.zoom.setLevel(propertyValue);
                            }
                        }
                    }
                    changeShapeProperty(shapeId, propertyName, propertyValue) {
                        const shape = this.getShape(shapeId);
                        if (!shape) {
                            console.error(`changeShapeProperty - shape id:${shapeId} not found.`);
                        }
                        else {
                            shape.changeProperty(propertyName, propertyValue);
                        }
                    }
                    dispose() {
                        super.dispose();
                        if (this._fBuilder) {
                            this._fBuilder.dispose();
                        }
                        this._provider = undefined;
                    }
                    refresh(centerChanged) {
                        this._removeMapZoomHandler();
                        let position = this.features.center.getCenter();
                        if (this.markers.length > 0) {
                            const markerProvider = this.markers[0].provider;
                            if (this.markers.length > 1) {
                                if (this.allowRefreshZoom) {
                                    if (this.features.zoom.isAutofit) {
                                        position = markerProvider.getLatLng();
                                    }
                                }
                                else {
                                    position = centerChanged
                                        ? this.config.center
                                        : this.provider.getCenter();
                                }
                            }
                            else if (markerProvider !== undefined) {
                                position = markerProvider.getLatLng();
                            }
                        }
                        this.features.center.refreshCenter(position, this.allowRefreshZoom);
                        this.features.offset.setOffset(this.features.offset.getOffset);
                        this.hasMarkerClusterer() && this.features.markerClusterer.repaint();
                        this._addMapZoomHandler();
                    }
                    refreshProviderEvents() {
                        if (this.isReady)
                            this._setMapEvents();
                    }
                    updateHeight() {
                        if (this.isReady)
                            this._provider.invalidateSize();
                    }
                    validateProviderEvent(eventName) {
                        return Leaflet.Constants.OSMap.ProviderEventNames[eventName] !== undefined;
                    }
                }
                OSMap.Map = Map;
            })(OSMap = Leaflet.OSMap || (Leaflet.OSMap = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Shape;
            (function (Shape) {
                class AbstractProviderShape extends OSFramework.Maps.Shape.AbstractShape {
                    get hasEvents() {
                        return this.shapeEvents !== undefined;
                    }
                    get shapeProviderEvents() {
                        return Leaflet.Constants.Shape.Events;
                    }
                    _resetShapeEvents() {
                        this._addedEvents.forEach((eventListener, index) => {
                            this._addedEvents.splice(index, 1);
                        });
                    }
                    _setDragEditConfigs(allowDrag, allowEdit) {
                        const providerShape = this.provider;
                        allowEdit ? providerShape.enableEdit() : providerShape.disableEdit();
                        allowDrag ? providerShape.dragging.enable() : providerShape.dragging.disable();
                    }
                    buildProvider(coordinates) {
                        if (coordinates !== undefined) {
                            coordinates
                                .then((coords) => {
                                this._provider = this.createProvider(coords);
                                this._provider.addTo(this.map.provider);
                                this._setDragEditConfigs(this.config.allowDrag, this.config.allowEdit);
                                this.setShapeEvents();
                                this.finishBuild();
                                this.map.refresh();
                            })
                                .catch((error) => {
                                OSFramework.Maps.Helper.ThrowError(this.map, OSFramework.Maps.Enum.ErrorCodes.LIB_FailedGeocodingShapeLocations, error);
                            });
                        }
                    }
                    setShapeEvents() {
                        this._resetShapeEvents();
                        if (this.shapeEvents.hasHandlers(OSFramework.Maps.Event.Shape.ShapeEventType.OnClick)) {
                            this.provider.addEventListener('click', () => {
                                this.shapeEvents.trigger(OSFramework.Maps.Event.Shape.ShapeEventType.OnClick);
                            });
                        }
                        this.shapeEvents.handlers.forEach((handler, eventName) => {
                            if (handler instanceof OSFramework.Maps.Event.Shape.ShapeProviderEvent) {
                                if (eventName === OSFramework.Maps.Helper.Constants.shapeChangedEvent) {
                                    this._addedEvents.push(eventName);
                                    this.providerEventsList.forEach((event) => this.provider.addEventListener(event, () => {
                                        if (this._shapeChangedEventTimeout) {
                                            clearTimeout(this._shapeChangedEventTimeout);
                                        }
                                        this._shapeChangedEventTimeout = setTimeout(this.triggerShapeChangedEvent.bind(this), 500);
                                    }));
                                }
                                else if (Leaflet.Constants.Shape.Events.indexOf(eventName) !== -1 ||
                                    Leaflet.Constants.Shape.ProviderSpecialEvents.indexOf(eventName) !== -1) {
                                    this._addedEvents.push(eventName);
                                    this.provider.addEventListener(eventName, () => {
                                        this.shapeEvents.trigger(OSFramework.Maps.Event.Shape.ShapeEventType.ProviderEvent, eventName);
                                    });
                                }
                            }
                        });
                    }
                    changeProperty(propertyName, propertyValue) {
                        const propValue = OSFramework.Maps.Enum.OS_Config_Shape[propertyName];
                        super.changeProperty(propertyName, propertyValue);
                        if (this.isReady) {
                            switch (propValue) {
                                case OSFramework.Maps.Enum.OS_Config_Shape.allowDrag:
                                    this._setDragEditConfigs(propertyValue, this.config.allowEdit);
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Shape.allowEdit:
                                    this._setDragEditConfigs(this.config.allowDrag, propertyValue);
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Shape.strokeOpacity:
                                    this.provider.setStyle({
                                        opacity: propertyValue,
                                    });
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Shape.strokeColor:
                                    this.provider.setStyle({
                                        color: propertyValue,
                                    });
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Shape.strokeWeight:
                                    this.provider.setStyle({
                                        weight: propertyValue,
                                    });
                                    return;
                            }
                        }
                    }
                    dispose() {
                        if (this.isReady) {
                            this._provider.remove();
                        }
                        this._provider = undefined;
                        super.dispose();
                    }
                    refreshProviderEvents() {
                        if (this.isReady)
                            this.setShapeEvents();
                    }
                }
                Shape.AbstractProviderShape = AbstractProviderShape;
            })(Shape = Leaflet.Shape || (Leaflet.Shape = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Shape;
            (function (Shape) {
                class AbstractPolyshape extends Shape.AbstractProviderShape {
                    get providerEventsList() {
                        return Leaflet.Constants.Shape.ProviderPolyshapeEvents;
                    }
                    get providerPath() {
                        const path = this.providerObjectPath;
                        if (path === undefined) {
                            OSFramework.Maps.Helper.ThrowError(this.map, OSFramework.Maps.Enum.ErrorCodes.API_FailedGettingShapePath);
                            return [];
                        }
                        return path;
                    }
                    _buildPath(loc) {
                        if (this._validateLocations(loc)) {
                            const _locations = JSON.parse(loc);
                            return new Promise((resolve, reject) => {
                                const shapePath = new Map();
                                _locations.every((location, index) => {
                                    if (OSFramework.Maps.Helper.IsEmptyString(location)) {
                                        OSFramework.Maps.Helper.ThrowError(this.map, this.invalidShapeLocationErrorCode);
                                        return false;
                                    }
                                    Leaflet.Helper.Conversions.ValidateCoordinates(location)
                                        .then((response) => {
                                        shapePath.set(index, {
                                            lat: response.lat,
                                            lng: response.lng,
                                        });
                                        if (shapePath.size === _locations.length) {
                                            resolve(Array.from(shapePath.keys())
                                                .sort((a, b) => a - b)
                                                .map((key) => shapePath.get(key)));
                                        }
                                    })
                                        .catch((e) => reject(e));
                                    return true;
                                });
                            });
                        }
                    }
                    _setProviderPath(path) {
                        this._provider.setLatLngs(path);
                    }
                    _validateLocations(loc) {
                        if (OSFramework.Maps.Helper.IsEmptyString(loc) || JSON.parse(loc).length < this.minPath) {
                            OSFramework.Maps.Helper.ThrowError(this.map, this.invalidShapeLocationErrorCode);
                            return false;
                        }
                        return true;
                    }
                    build() {
                        super.build();
                        const shapePath = this._buildPath(this.config.locations);
                        this.buildProvider(shapePath);
                    }
                    changeProperty(propertyName, propertyValue) {
                        const propValue = OSFramework.Maps.Enum.OS_Config_Shape[propertyName];
                        super.changeProperty(propertyName, propertyValue);
                        if (this.isReady) {
                            switch (propValue) {
                                case OSFramework.Maps.Enum.OS_Config_Shape.locations:
                                    const shapePath = this._buildPath(propertyValue);
                                    if (shapePath !== undefined) {
                                        shapePath
                                            .then((path) => {
                                            this._setProviderPath(path);
                                        })
                                            .catch((error) => {
                                            OSFramework.Maps.Helper.ThrowError(this.map, OSFramework.Maps.Enum.ErrorCodes.LIB_FailedGeocodingShapeLocations, error);
                                        });
                                    }
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Shape.fillColor:
                                    this.provider.setStyle({
                                        fillColor: propertyValue,
                                    });
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Shape.fillOpacity:
                                    this.provider.setStyle({
                                        fillOpacity: propertyValue,
                                    });
                                    return;
                            }
                        }
                    }
                }
                Shape.AbstractPolyshape = AbstractPolyshape;
            })(Shape = Leaflet.Shape || (Leaflet.Shape = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Shape;
            (function (Shape) {
                class Circle extends Shape.AbstractProviderShape {
                    constructor(map, shapeId, type, configs) {
                        super(map, shapeId, type, new Leaflet.Configuration.Shape.CircleShapeConfig(configs));
                    }
                    get invalidShapeLocationErrorCode() {
                        return OSFramework.Maps.Enum.ErrorCodes.CFG_InvalidCircleShapeCenter;
                    }
                    get providerObjectListener() {
                        return this.provider;
                    }
                    get providerBounds() {
                        return this.provider.getBounds();
                    }
                    get providerCenter() {
                        const center = this.provider.getLatLng();
                        if (center === undefined) {
                            OSFramework.Maps.Helper.ThrowError(this.map, OSFramework.Maps.Enum.ErrorCodes.API_FailedGettingShapeCenter);
                        }
                        return center;
                    }
                    get providerEventsList() {
                        return Leaflet.Constants.Shape.ProviderCircleEvents;
                    }
                    get providerRadius() {
                        const center = this.provider.getRadius();
                        if (center === undefined) {
                            OSFramework.Maps.Helper.ThrowError(this.map, OSFramework.Maps.Enum.ErrorCodes.API_FailedGettingShapeRadius);
                        }
                        return center;
                    }
                    get shapeTag() {
                        return OSFramework.Maps.Helper.Constants.shapeCircleTag;
                    }
                    _buildCenter(location) {
                        if (OSFramework.Maps.Helper.IsEmptyString(location)) {
                            OSFramework.Maps.Helper.ThrowError(this.map, this.invalidShapeLocationErrorCode);
                            return;
                        }
                        return new Promise((resolve, reject) => {
                            Leaflet.Helper.Conversions.ValidateCoordinates(location)
                                .then((response) => {
                                const coordinates = {
                                    lat: response.lat,
                                    lng: response.lng,
                                };
                                resolve(coordinates);
                            })
                                .catch((e) => reject(e));
                        });
                    }
                    _changeCenter(location) {
                        const shapeCenter = this._buildCenter(location);
                        if (shapeCenter !== undefined) {
                            shapeCenter
                                .then((center) => {
                                this.provider.setLatLng(center);
                            })
                                .catch((error) => {
                                OSFramework.Maps.Helper.ThrowError(this.map, OSFramework.Maps.Enum.ErrorCodes.LIB_FailedGeocodingShapeLocations, error);
                            });
                        }
                    }
                    createProvider(center) {
                        return new L.Circle(center, this.getProviderConfig());
                    }
                    getShapeCoordinates() {
                        return {
                            coordinates: {
                                Lat: this.providerCenter.lat,
                                Lng: this.providerCenter.lng,
                            },
                            location: {
                                location: `${this.providerCenter.lat.toString()},${this.providerCenter.lng.toString()}`,
                                radius: this.providerRadius,
                            },
                        };
                    }
                    build() {
                        super.build();
                        const shapeCenter = this._buildCenter(this.config.center);
                        super.buildProvider(shapeCenter);
                    }
                    changeProperty(propertyName, propertyValue) {
                        const propValue = OSFramework.Maps.Enum.OS_Config_Shape[propertyName];
                        super.changeProperty(propertyName, propertyValue);
                        if (this.isReady) {
                            switch (propValue) {
                                case OSFramework.Maps.Enum.OS_Config_Shape.center:
                                    this._changeCenter(propertyValue);
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Shape.radius:
                                    this.provider.setRadius(propertyValue);
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Shape.fillColor:
                                    this.provider.setStyle({
                                        fillColor: propertyValue,
                                    });
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Shape.fillOpacity:
                                    this.provider.setStyle({
                                        fillOpacity: propertyValue,
                                    });
                                    return;
                            }
                        }
                    }
                }
                Shape.Circle = Circle;
            })(Shape = Leaflet.Shape || (Leaflet.Shape = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Shape;
            (function (Shape) {
                let ShapeFactory;
                (function (ShapeFactory) {
                    function MakeShape(map, shapeId, type, configs) {
                        switch (type) {
                            case OSFramework.Maps.Enum.ShapeType.Polygon:
                                return new Shape.Polygon(map, shapeId, type, configs);
                            case OSFramework.Maps.Enum.ShapeType.Polyline:
                                return new Shape.Polyline(map, shapeId, type, configs);
                            case OSFramework.Maps.Enum.ShapeType.Circle:
                                return new Shape.Circle(map, shapeId, type, configs);
                            case OSFramework.Maps.Enum.ShapeType.Rectangle:
                                return new Shape.Rectangle(map, shapeId, type, configs);
                            default:
                                throw new Error(`There is no factory for this type of Shape (${type})`);
                        }
                    }
                    ShapeFactory.MakeShape = MakeShape;
                })(ShapeFactory = Shape.ShapeFactory || (Shape.ShapeFactory = {}));
            })(Shape = Leaflet.Shape || (Leaflet.Shape = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Shape;
            (function (Shape) {
                class Polygon extends Shape.AbstractPolyshape {
                    constructor(map, shapeId, type, configs) {
                        super(map, shapeId, type, new Leaflet.Configuration.Shape.FilledShapeConfig(configs));
                    }
                    get invalidShapeLocationErrorCode() {
                        return OSFramework.Maps.Enum.ErrorCodes.CFG_InvalidPolygonShapeLocations;
                    }
                    get providerObjectPath() {
                        return this.provider.getLatLngs()[0];
                    }
                    get providerBounds() {
                        return this.provider.getBounds();
                    }
                    get shapeTag() {
                        return OSFramework.Maps.Helper.Constants.shapePolygonTag;
                    }
                    createProvider(path) {
                        return new L.Polygon(path, this.getProviderConfig());
                    }
                    getShapeCoordinates() {
                        const locations = this.providerObjectPath.map((elm) => `${elm.lat},${elm.lng}`);
                        const coordinates = this.providerObjectPath.map((elm) => {
                            return {
                                Lat: elm.lat,
                                Lng: elm.lng,
                            };
                        });
                        return {
                            location: locations,
                            coordinates: coordinates,
                        };
                    }
                }
                Shape.Polygon = Polygon;
            })(Shape = Leaflet.Shape || (Leaflet.Shape = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Shape;
            (function (Shape) {
                class Polyline extends Shape.AbstractPolyshape {
                    constructor(map, shapeId, type, configs) {
                        super(map, shapeId, type, new Leaflet.Configuration.Shape.BasicShapeConfig(configs));
                    }
                    get invalidShapeLocationErrorCode() {
                        return OSFramework.Maps.Enum.ErrorCodes.CFG_InvalidPolylineShapeLocations;
                    }
                    get providerObjectPath() {
                        return this.provider.getLatLngs();
                    }
                    get providerBounds() {
                        return this.provider.getBounds();
                    }
                    get shapeTag() {
                        return OSFramework.Maps.Helper.Constants.shapePolylineTag;
                    }
                    createProvider(path) {
                        return new L.Polyline(path, this.getProviderConfig());
                    }
                    getShapeCoordinates() {
                        const locations = this.providerObjectPath.map((elm) => `${elm.lat},${elm.lng}`);
                        const coordinates = this.providerObjectPath.map((elm) => {
                            return {
                                Lat: elm.lat,
                                Lng: elm.lng,
                            };
                        });
                        return {
                            location: locations,
                            coordinates: coordinates,
                        };
                    }
                }
                Shape.Polyline = Polyline;
            })(Shape = Leaflet.Shape || (Leaflet.Shape = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Shape;
            (function (Shape) {
                class Rectangle extends Shape.AbstractProviderShape {
                    constructor(map, shapeId, type, configs) {
                        super(map, shapeId, type, new Leaflet.Configuration.Shape.RectangleShapeConfig(configs));
                    }
                    get invalidShapeLocationErrorCode() {
                        return OSFramework.Maps.Enum.ErrorCodes.CFG_InvalidRectangleShapeBounds;
                    }
                    get bounds() {
                        const bounds = new OSFramework.Maps.OSStructures.OSMap.Bounds();
                        bounds.east = this.providerBounds.getNorthEast().lng;
                        bounds.north = this.providerBounds.getNorthEast().lat;
                        bounds.west = this.providerBounds.getSouthWest().lng;
                        bounds.south = this.providerBounds.getSouthWest().lat;
                        return bounds;
                    }
                    get providerBounds() {
                        return this.provider.getBounds();
                    }
                    get providerEventsList() {
                        return Leaflet.Constants.Shape.ProviderRectangleEvents;
                    }
                    get shapeTag() {
                        return OSFramework.Maps.Helper.Constants.shapeRectangleTag;
                    }
                    _buildBounds(boundsString) {
                        const bounds = JSON.parse(boundsString);
                        if (OSFramework.Maps.Helper.HasAnyEmptyBound(bounds)) {
                            OSFramework.Maps.Helper.ThrowError(this.map, this.invalidShapeLocationErrorCode);
                            return;
                        }
                        return this._convertStringToBounds(bounds);
                    }
                    _convertStringToBounds(bounds) {
                        const cardinalDirections = ['north', 'south', 'east', 'west'];
                        return new Promise((resolve, reject) => {
                            let boundsLength = 0;
                            const newBounds = new OSFramework.Maps.OSStructures.OSMap.Bounds();
                            cardinalDirections.forEach((cd) => {
                                const regexValidator = /^-{0,1}\d*\.{0,1}\d*$/;
                                if (regexValidator.test(bounds[cd])) {
                                    boundsLength++;
                                    newBounds[cd] = parseFloat(bounds[cd]);
                                    if (boundsLength === 4) {
                                        resolve(newBounds);
                                    }
                                }
                                else {
                                    Leaflet.Helper.Conversions.ValidateCoordinates(bounds[cd])
                                        .then((response) => {
                                        boundsLength++;
                                        switch (cd) {
                                            case 'north':
                                            case 'south':
                                                newBounds[cd] = response.lat;
                                                break;
                                            case 'east':
                                            case 'west':
                                            default:
                                                newBounds[cd] = response.lng;
                                                break;
                                        }
                                        if (boundsLength === 4) {
                                            resolve(newBounds);
                                        }
                                    })
                                        .catch((e) => reject(e));
                                }
                            });
                        });
                    }
                    createProvider(bounds) {
                        const providerBounds = [
                            [bounds.south, bounds.west],
                            [bounds.north, bounds.east],
                        ];
                        return new L.Rectangle(providerBounds, Object.assign({}, this.getProviderConfig()));
                    }
                    getShapeCoordinates() {
                        const bounds = {
                            north: this.bounds.north,
                            south: this.bounds.south,
                            west: this.bounds.west,
                            east: this.bounds.east,
                        };
                        return {
                            location: bounds,
                            coordinates: bounds,
                        };
                    }
                    build() {
                        super.build();
                        const bounds = this._buildBounds(this.config.bounds);
                        super.buildProvider(bounds);
                    }
                    changeProperty(propertyName, propertyValue) {
                        const propValue = OSFramework.Maps.Enum.OS_Config_Shape[propertyName];
                        super.changeProperty(propertyName, propertyValue);
                        if (this.isReady) {
                            switch (propValue) {
                                case OSFramework.Maps.Enum.OS_Config_Shape.fillColor:
                                    this.provider.setStyle({
                                        fillColor: propertyValue,
                                    });
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Shape.fillOpacity:
                                    this.provider.setStyle({
                                        fillOpacity: propertyValue,
                                    });
                                    return;
                                case OSFramework.Maps.Enum.OS_Config_Shape.bounds:
                                    const shapeBounds = this._buildBounds(propertyValue);
                                    if (shapeBounds !== undefined) {
                                        shapeBounds
                                            .then((bounds) => {
                                            const providerBounds = [
                                                [bounds.south, bounds.west],
                                                [bounds.north, bounds.east],
                                            ];
                                            this.provider.setBounds(providerBounds);
                                        })
                                            .catch((error) => {
                                            OSFramework.Maps.Helper.ThrowError(this.map, OSFramework.Maps.Enum.ErrorCodes.LIB_FailedGeocodingShapeLocations, error);
                                        });
                                    }
                                    return;
                            }
                        }
                    }
                }
                Shape.Rectangle = Rectangle;
            })(Shape = Leaflet.Shape || (Leaflet.Shape = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
var Provider;
(function (Provider) {
    var Maps;
    (function (Maps) {
        var Leaflet;
        (function (Leaflet) {
            var Version;
            (function (Version) {
                function Change(newVersion) {
                    OSFramework.Maps.Helper.LogWarningMessage(`Changing Leaflet version is not supported. Using version '${Leaflet.Constants.leafletVersion}'.`);
                    return false;
                }
                Version.Change = Change;
                function Get() {
                    return Leaflet.Constants.leafletVersion;
                }
                Version.Get = Get;
            })(Version = Leaflet.Version || (Leaflet.Version = {}));
        })(Leaflet = Maps.Leaflet || (Maps.Leaflet = {}));
    })(Maps = Provider.Maps || (Provider.Maps = {}));
})(Provider || (Provider = {}));
